// Code generated by mockery v2.42.1. DO NOT EDIT.

package redis_mocks

import (
	context "context"

	redis "github.com/go-redis/redis/v8"
	mock "github.com/stretchr/testify/mock"

	time "time"
)

// MockUniversalClient is an autogenerated mock type for the UniversalClient type
type MockUniversalClient struct {
	mock.Mock
}

type MockUniversalClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUniversalClient) EXPECT() *MockUniversalClient_Expecter {
	return &MockUniversalClient_Expecter{mock: &_m.Mock}
}

// AddHook provides a mock function with given fields: _a0
func (_m *MockUniversalClient) AddHook(_a0 redis.Hook) {
	_m.Called(_a0)
}

// MockUniversalClient_AddHook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddHook'
type MockUniversalClient_AddHook_Call struct {
	*mock.Call
}

// AddHook is a helper method to define mock.On call
//   - _a0 redis.Hook
func (_e *MockUniversalClient_Expecter) AddHook(_a0 interface{}) *MockUniversalClient_AddHook_Call {
	return &MockUniversalClient_AddHook_Call{Call: _e.mock.On("AddHook", _a0)}
}

func (_c *MockUniversalClient_AddHook_Call) Run(run func(_a0 redis.Hook)) *MockUniversalClient_AddHook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(redis.Hook))
	})
	return _c
}

func (_c *MockUniversalClient_AddHook_Call) Return() *MockUniversalClient_AddHook_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockUniversalClient_AddHook_Call) RunAndReturn(run func(redis.Hook)) *MockUniversalClient_AddHook_Call {
	_c.Call.Return(run)
	return _c
}

// Append provides a mock function with given fields: ctx, key, value
func (_m *MockUniversalClient) Append(ctx context.Context, key string, value string) *redis.IntCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for Append")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_Append_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Append'
type MockUniversalClient_Append_Call struct {
	*mock.Call
}

// Append is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value string
func (_e *MockUniversalClient_Expecter) Append(ctx interface{}, key interface{}, value interface{}) *MockUniversalClient_Append_Call {
	return &MockUniversalClient_Append_Call{Call: _e.mock.On("Append", ctx, key, value)}
}

func (_c *MockUniversalClient_Append_Call) Run(run func(ctx context.Context, key string, value string)) *MockUniversalClient_Append_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUniversalClient_Append_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_Append_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Append_Call) RunAndReturn(run func(context.Context, string, string) *redis.IntCmd) *MockUniversalClient_Append_Call {
	_c.Call.Return(run)
	return _c
}

// BLMove provides a mock function with given fields: ctx, source, destination, srcpos, destpos, timeout
func (_m *MockUniversalClient) BLMove(ctx context.Context, source string, destination string, srcpos string, destpos string, timeout time.Duration) *redis.StringCmd {
	ret := _m.Called(ctx, source, destination, srcpos, destpos, timeout)

	if len(ret) == 0 {
		panic("no return value specified for BLMove")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, time.Duration) *redis.StringCmd); ok {
		r0 = rf(ctx, source, destination, srcpos, destpos, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_BLMove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BLMove'
type MockUniversalClient_BLMove_Call struct {
	*mock.Call
}

// BLMove is a helper method to define mock.On call
//   - ctx context.Context
//   - source string
//   - destination string
//   - srcpos string
//   - destpos string
//   - timeout time.Duration
func (_e *MockUniversalClient_Expecter) BLMove(ctx interface{}, source interface{}, destination interface{}, srcpos interface{}, destpos interface{}, timeout interface{}) *MockUniversalClient_BLMove_Call {
	return &MockUniversalClient_BLMove_Call{Call: _e.mock.On("BLMove", ctx, source, destination, srcpos, destpos, timeout)}
}

func (_c *MockUniversalClient_BLMove_Call) Run(run func(ctx context.Context, source string, destination string, srcpos string, destpos string, timeout time.Duration)) *MockUniversalClient_BLMove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(time.Duration))
	})
	return _c
}

func (_c *MockUniversalClient_BLMove_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_BLMove_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_BLMove_Call) RunAndReturn(run func(context.Context, string, string, string, string, time.Duration) *redis.StringCmd) *MockUniversalClient_BLMove_Call {
	_c.Call.Return(run)
	return _c
}

// BLPop provides a mock function with given fields: ctx, timeout, keys
func (_m *MockUniversalClient) BLPop(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BLPop")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_BLPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BLPop'
type MockUniversalClient_BLPop_Call struct {
	*mock.Call
}

// BLPop is a helper method to define mock.On call
//   - ctx context.Context
//   - timeout time.Duration
//   - keys ...string
func (_e *MockUniversalClient_Expecter) BLPop(ctx interface{}, timeout interface{}, keys ...interface{}) *MockUniversalClient_BLPop_Call {
	return &MockUniversalClient_BLPop_Call{Call: _e.mock.On("BLPop",
		append([]interface{}{ctx, timeout}, keys...)...)}
}

func (_c *MockUniversalClient_BLPop_Call) Run(run func(ctx context.Context, timeout time.Duration, keys ...string)) *MockUniversalClient_BLPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(time.Duration), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_BLPop_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_BLPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_BLPop_Call) RunAndReturn(run func(context.Context, time.Duration, ...string) *redis.StringSliceCmd) *MockUniversalClient_BLPop_Call {
	_c.Call.Return(run)
	return _c
}

// BRPop provides a mock function with given fields: ctx, timeout, keys
func (_m *MockUniversalClient) BRPop(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BRPop")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_BRPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BRPop'
type MockUniversalClient_BRPop_Call struct {
	*mock.Call
}

// BRPop is a helper method to define mock.On call
//   - ctx context.Context
//   - timeout time.Duration
//   - keys ...string
func (_e *MockUniversalClient_Expecter) BRPop(ctx interface{}, timeout interface{}, keys ...interface{}) *MockUniversalClient_BRPop_Call {
	return &MockUniversalClient_BRPop_Call{Call: _e.mock.On("BRPop",
		append([]interface{}{ctx, timeout}, keys...)...)}
}

func (_c *MockUniversalClient_BRPop_Call) Run(run func(ctx context.Context, timeout time.Duration, keys ...string)) *MockUniversalClient_BRPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(time.Duration), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_BRPop_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_BRPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_BRPop_Call) RunAndReturn(run func(context.Context, time.Duration, ...string) *redis.StringSliceCmd) *MockUniversalClient_BRPop_Call {
	_c.Call.Return(run)
	return _c
}

// BRPopLPush provides a mock function with given fields: ctx, source, destination, timeout
func (_m *MockUniversalClient) BRPopLPush(ctx context.Context, source string, destination string, timeout time.Duration) *redis.StringCmd {
	ret := _m.Called(ctx, source, destination, timeout)

	if len(ret) == 0 {
		panic("no return value specified for BRPopLPush")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) *redis.StringCmd); ok {
		r0 = rf(ctx, source, destination, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_BRPopLPush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BRPopLPush'
type MockUniversalClient_BRPopLPush_Call struct {
	*mock.Call
}

// BRPopLPush is a helper method to define mock.On call
//   - ctx context.Context
//   - source string
//   - destination string
//   - timeout time.Duration
func (_e *MockUniversalClient_Expecter) BRPopLPush(ctx interface{}, source interface{}, destination interface{}, timeout interface{}) *MockUniversalClient_BRPopLPush_Call {
	return &MockUniversalClient_BRPopLPush_Call{Call: _e.mock.On("BRPopLPush", ctx, source, destination, timeout)}
}

func (_c *MockUniversalClient_BRPopLPush_Call) Run(run func(ctx context.Context, source string, destination string, timeout time.Duration)) *MockUniversalClient_BRPopLPush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockUniversalClient_BRPopLPush_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_BRPopLPush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_BRPopLPush_Call) RunAndReturn(run func(context.Context, string, string, time.Duration) *redis.StringCmd) *MockUniversalClient_BRPopLPush_Call {
	_c.Call.Return(run)
	return _c
}

// BZPopMax provides a mock function with given fields: ctx, timeout, keys
func (_m *MockUniversalClient) BZPopMax(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BZPopMax")
	}

	var r0 *redis.ZWithKeyCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, ...string) *redis.ZWithKeyCmd); ok {
		r0 = rf(ctx, timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZWithKeyCmd)
		}
	}

	return r0
}

// MockUniversalClient_BZPopMax_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BZPopMax'
type MockUniversalClient_BZPopMax_Call struct {
	*mock.Call
}

// BZPopMax is a helper method to define mock.On call
//   - ctx context.Context
//   - timeout time.Duration
//   - keys ...string
func (_e *MockUniversalClient_Expecter) BZPopMax(ctx interface{}, timeout interface{}, keys ...interface{}) *MockUniversalClient_BZPopMax_Call {
	return &MockUniversalClient_BZPopMax_Call{Call: _e.mock.On("BZPopMax",
		append([]interface{}{ctx, timeout}, keys...)...)}
}

func (_c *MockUniversalClient_BZPopMax_Call) Run(run func(ctx context.Context, timeout time.Duration, keys ...string)) *MockUniversalClient_BZPopMax_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(time.Duration), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_BZPopMax_Call) Return(_a0 *redis.ZWithKeyCmd) *MockUniversalClient_BZPopMax_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_BZPopMax_Call) RunAndReturn(run func(context.Context, time.Duration, ...string) *redis.ZWithKeyCmd) *MockUniversalClient_BZPopMax_Call {
	_c.Call.Return(run)
	return _c
}

// BZPopMin provides a mock function with given fields: ctx, timeout, keys
func (_m *MockUniversalClient) BZPopMin(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BZPopMin")
	}

	var r0 *redis.ZWithKeyCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, ...string) *redis.ZWithKeyCmd); ok {
		r0 = rf(ctx, timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZWithKeyCmd)
		}
	}

	return r0
}

// MockUniversalClient_BZPopMin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BZPopMin'
type MockUniversalClient_BZPopMin_Call struct {
	*mock.Call
}

// BZPopMin is a helper method to define mock.On call
//   - ctx context.Context
//   - timeout time.Duration
//   - keys ...string
func (_e *MockUniversalClient_Expecter) BZPopMin(ctx interface{}, timeout interface{}, keys ...interface{}) *MockUniversalClient_BZPopMin_Call {
	return &MockUniversalClient_BZPopMin_Call{Call: _e.mock.On("BZPopMin",
		append([]interface{}{ctx, timeout}, keys...)...)}
}

func (_c *MockUniversalClient_BZPopMin_Call) Run(run func(ctx context.Context, timeout time.Duration, keys ...string)) *MockUniversalClient_BZPopMin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(time.Duration), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_BZPopMin_Call) Return(_a0 *redis.ZWithKeyCmd) *MockUniversalClient_BZPopMin_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_BZPopMin_Call) RunAndReturn(run func(context.Context, time.Duration, ...string) *redis.ZWithKeyCmd) *MockUniversalClient_BZPopMin_Call {
	_c.Call.Return(run)
	return _c
}

// BgRewriteAOF provides a mock function with given fields: ctx
func (_m *MockUniversalClient) BgRewriteAOF(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for BgRewriteAOF")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_BgRewriteAOF_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BgRewriteAOF'
type MockUniversalClient_BgRewriteAOF_Call struct {
	*mock.Call
}

// BgRewriteAOF is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) BgRewriteAOF(ctx interface{}) *MockUniversalClient_BgRewriteAOF_Call {
	return &MockUniversalClient_BgRewriteAOF_Call{Call: _e.mock.On("BgRewriteAOF", ctx)}
}

func (_c *MockUniversalClient_BgRewriteAOF_Call) Run(run func(ctx context.Context)) *MockUniversalClient_BgRewriteAOF_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_BgRewriteAOF_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_BgRewriteAOF_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_BgRewriteAOF_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_BgRewriteAOF_Call {
	_c.Call.Return(run)
	return _c
}

// BgSave provides a mock function with given fields: ctx
func (_m *MockUniversalClient) BgSave(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for BgSave")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_BgSave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BgSave'
type MockUniversalClient_BgSave_Call struct {
	*mock.Call
}

// BgSave is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) BgSave(ctx interface{}) *MockUniversalClient_BgSave_Call {
	return &MockUniversalClient_BgSave_Call{Call: _e.mock.On("BgSave", ctx)}
}

func (_c *MockUniversalClient_BgSave_Call) Run(run func(ctx context.Context)) *MockUniversalClient_BgSave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_BgSave_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_BgSave_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_BgSave_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_BgSave_Call {
	_c.Call.Return(run)
	return _c
}

// BitCount provides a mock function with given fields: ctx, key, bitCount
func (_m *MockUniversalClient) BitCount(ctx context.Context, key string, bitCount *redis.BitCount) *redis.IntCmd {
	ret := _m.Called(ctx, key, bitCount)

	if len(ret) == 0 {
		panic("no return value specified for BitCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.BitCount) *redis.IntCmd); ok {
		r0 = rf(ctx, key, bitCount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_BitCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitCount'
type MockUniversalClient_BitCount_Call struct {
	*mock.Call
}

// BitCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - bitCount *redis.BitCount
func (_e *MockUniversalClient_Expecter) BitCount(ctx interface{}, key interface{}, bitCount interface{}) *MockUniversalClient_BitCount_Call {
	return &MockUniversalClient_BitCount_Call{Call: _e.mock.On("BitCount", ctx, key, bitCount)}
}

func (_c *MockUniversalClient_BitCount_Call) Run(run func(ctx context.Context, key string, bitCount *redis.BitCount)) *MockUniversalClient_BitCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*redis.BitCount))
	})
	return _c
}

func (_c *MockUniversalClient_BitCount_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_BitCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_BitCount_Call) RunAndReturn(run func(context.Context, string, *redis.BitCount) *redis.IntCmd) *MockUniversalClient_BitCount_Call {
	_c.Call.Return(run)
	return _c
}

// BitField provides a mock function with given fields: ctx, key, args
func (_m *MockUniversalClient) BitField(ctx context.Context, key string, args ...interface{}) *redis.IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitField")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_BitField_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitField'
type MockUniversalClient_BitField_Call struct {
	*mock.Call
}

// BitField is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - args ...interface{}
func (_e *MockUniversalClient_Expecter) BitField(ctx interface{}, key interface{}, args ...interface{}) *MockUniversalClient_BitField_Call {
	return &MockUniversalClient_BitField_Call{Call: _e.mock.On("BitField",
		append([]interface{}{ctx, key}, args...)...)}
}

func (_c *MockUniversalClient_BitField_Call) Run(run func(ctx context.Context, key string, args ...interface{})) *MockUniversalClient_BitField_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_BitField_Call) Return(_a0 *redis.IntSliceCmd) *MockUniversalClient_BitField_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_BitField_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *redis.IntSliceCmd) *MockUniversalClient_BitField_Call {
	_c.Call.Return(run)
	return _c
}

// BitOpAnd provides a mock function with given fields: ctx, destKey, keys
func (_m *MockUniversalClient) BitOpAnd(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitOpAnd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_BitOpAnd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitOpAnd'
type MockUniversalClient_BitOpAnd_Call struct {
	*mock.Call
}

// BitOpAnd is a helper method to define mock.On call
//   - ctx context.Context
//   - destKey string
//   - keys ...string
func (_e *MockUniversalClient_Expecter) BitOpAnd(ctx interface{}, destKey interface{}, keys ...interface{}) *MockUniversalClient_BitOpAnd_Call {
	return &MockUniversalClient_BitOpAnd_Call{Call: _e.mock.On("BitOpAnd",
		append([]interface{}{ctx, destKey}, keys...)...)}
}

func (_c *MockUniversalClient_BitOpAnd_Call) Run(run func(ctx context.Context, destKey string, keys ...string)) *MockUniversalClient_BitOpAnd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_BitOpAnd_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_BitOpAnd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_BitOpAnd_Call) RunAndReturn(run func(context.Context, string, ...string) *redis.IntCmd) *MockUniversalClient_BitOpAnd_Call {
	_c.Call.Return(run)
	return _c
}

// BitOpNot provides a mock function with given fields: ctx, destKey, key
func (_m *MockUniversalClient) BitOpNot(ctx context.Context, destKey string, key string) *redis.IntCmd {
	ret := _m.Called(ctx, destKey, key)

	if len(ret) == 0 {
		panic("no return value specified for BitOpNot")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, destKey, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_BitOpNot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitOpNot'
type MockUniversalClient_BitOpNot_Call struct {
	*mock.Call
}

// BitOpNot is a helper method to define mock.On call
//   - ctx context.Context
//   - destKey string
//   - key string
func (_e *MockUniversalClient_Expecter) BitOpNot(ctx interface{}, destKey interface{}, key interface{}) *MockUniversalClient_BitOpNot_Call {
	return &MockUniversalClient_BitOpNot_Call{Call: _e.mock.On("BitOpNot", ctx, destKey, key)}
}

func (_c *MockUniversalClient_BitOpNot_Call) Run(run func(ctx context.Context, destKey string, key string)) *MockUniversalClient_BitOpNot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUniversalClient_BitOpNot_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_BitOpNot_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_BitOpNot_Call) RunAndReturn(run func(context.Context, string, string) *redis.IntCmd) *MockUniversalClient_BitOpNot_Call {
	_c.Call.Return(run)
	return _c
}

// BitOpOr provides a mock function with given fields: ctx, destKey, keys
func (_m *MockUniversalClient) BitOpOr(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitOpOr")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_BitOpOr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitOpOr'
type MockUniversalClient_BitOpOr_Call struct {
	*mock.Call
}

// BitOpOr is a helper method to define mock.On call
//   - ctx context.Context
//   - destKey string
//   - keys ...string
func (_e *MockUniversalClient_Expecter) BitOpOr(ctx interface{}, destKey interface{}, keys ...interface{}) *MockUniversalClient_BitOpOr_Call {
	return &MockUniversalClient_BitOpOr_Call{Call: _e.mock.On("BitOpOr",
		append([]interface{}{ctx, destKey}, keys...)...)}
}

func (_c *MockUniversalClient_BitOpOr_Call) Run(run func(ctx context.Context, destKey string, keys ...string)) *MockUniversalClient_BitOpOr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_BitOpOr_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_BitOpOr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_BitOpOr_Call) RunAndReturn(run func(context.Context, string, ...string) *redis.IntCmd) *MockUniversalClient_BitOpOr_Call {
	_c.Call.Return(run)
	return _c
}

// BitOpXor provides a mock function with given fields: ctx, destKey, keys
func (_m *MockUniversalClient) BitOpXor(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitOpXor")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_BitOpXor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitOpXor'
type MockUniversalClient_BitOpXor_Call struct {
	*mock.Call
}

// BitOpXor is a helper method to define mock.On call
//   - ctx context.Context
//   - destKey string
//   - keys ...string
func (_e *MockUniversalClient_Expecter) BitOpXor(ctx interface{}, destKey interface{}, keys ...interface{}) *MockUniversalClient_BitOpXor_Call {
	return &MockUniversalClient_BitOpXor_Call{Call: _e.mock.On("BitOpXor",
		append([]interface{}{ctx, destKey}, keys...)...)}
}

func (_c *MockUniversalClient_BitOpXor_Call) Run(run func(ctx context.Context, destKey string, keys ...string)) *MockUniversalClient_BitOpXor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_BitOpXor_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_BitOpXor_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_BitOpXor_Call) RunAndReturn(run func(context.Context, string, ...string) *redis.IntCmd) *MockUniversalClient_BitOpXor_Call {
	_c.Call.Return(run)
	return _c
}

// BitPos provides a mock function with given fields: ctx, key, bit, pos
func (_m *MockUniversalClient) BitPos(ctx context.Context, key string, bit int64, pos ...int64) *redis.IntCmd {
	_va := make([]interface{}, len(pos))
	for _i := range pos {
		_va[_i] = pos[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, bit)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitPos")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, ...int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, bit, pos...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_BitPos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitPos'
type MockUniversalClient_BitPos_Call struct {
	*mock.Call
}

// BitPos is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - bit int64
//   - pos ...int64
func (_e *MockUniversalClient_Expecter) BitPos(ctx interface{}, key interface{}, bit interface{}, pos ...interface{}) *MockUniversalClient_BitPos_Call {
	return &MockUniversalClient_BitPos_Call{Call: _e.mock.On("BitPos",
		append([]interface{}{ctx, key, bit}, pos...)...)}
}

func (_c *MockUniversalClient_BitPos_Call) Run(run func(ctx context.Context, key string, bit int64, pos ...int64)) *MockUniversalClient_BitPos_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int64, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(int64)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(int64), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_BitPos_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_BitPos_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_BitPos_Call) RunAndReturn(run func(context.Context, string, int64, ...int64) *redis.IntCmd) *MockUniversalClient_BitPos_Call {
	_c.Call.Return(run)
	return _c
}

// ClientGetName provides a mock function with given fields: ctx
func (_m *MockUniversalClient) ClientGetName(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClientGetName")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClientGetName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientGetName'
type MockUniversalClient_ClientGetName_Call struct {
	*mock.Call
}

// ClientGetName is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) ClientGetName(ctx interface{}) *MockUniversalClient_ClientGetName_Call {
	return &MockUniversalClient_ClientGetName_Call{Call: _e.mock.On("ClientGetName", ctx)}
}

func (_c *MockUniversalClient_ClientGetName_Call) Run(run func(ctx context.Context)) *MockUniversalClient_ClientGetName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_ClientGetName_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_ClientGetName_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClientGetName_Call) RunAndReturn(run func(context.Context) *redis.StringCmd) *MockUniversalClient_ClientGetName_Call {
	_c.Call.Return(run)
	return _c
}

// ClientID provides a mock function with given fields: ctx
func (_m *MockUniversalClient) ClientID(ctx context.Context) *redis.IntCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClientID")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.IntCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClientID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientID'
type MockUniversalClient_ClientID_Call struct {
	*mock.Call
}

// ClientID is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) ClientID(ctx interface{}) *MockUniversalClient_ClientID_Call {
	return &MockUniversalClient_ClientID_Call{Call: _e.mock.On("ClientID", ctx)}
}

func (_c *MockUniversalClient_ClientID_Call) Run(run func(ctx context.Context)) *MockUniversalClient_ClientID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_ClientID_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ClientID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClientID_Call) RunAndReturn(run func(context.Context) *redis.IntCmd) *MockUniversalClient_ClientID_Call {
	_c.Call.Return(run)
	return _c
}

// ClientKill provides a mock function with given fields: ctx, ipPort
func (_m *MockUniversalClient) ClientKill(ctx context.Context, ipPort string) *redis.StatusCmd {
	ret := _m.Called(ctx, ipPort)

	if len(ret) == 0 {
		panic("no return value specified for ClientKill")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, ipPort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClientKill_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientKill'
type MockUniversalClient_ClientKill_Call struct {
	*mock.Call
}

// ClientKill is a helper method to define mock.On call
//   - ctx context.Context
//   - ipPort string
func (_e *MockUniversalClient_Expecter) ClientKill(ctx interface{}, ipPort interface{}) *MockUniversalClient_ClientKill_Call {
	return &MockUniversalClient_ClientKill_Call{Call: _e.mock.On("ClientKill", ctx, ipPort)}
}

func (_c *MockUniversalClient_ClientKill_Call) Run(run func(ctx context.Context, ipPort string)) *MockUniversalClient_ClientKill_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ClientKill_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ClientKill_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClientKill_Call) RunAndReturn(run func(context.Context, string) *redis.StatusCmd) *MockUniversalClient_ClientKill_Call {
	_c.Call.Return(run)
	return _c
}

// ClientKillByFilter provides a mock function with given fields: ctx, keys
func (_m *MockUniversalClient) ClientKillByFilter(ctx context.Context, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClientKillByFilter")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClientKillByFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientKillByFilter'
type MockUniversalClient_ClientKillByFilter_Call struct {
	*mock.Call
}

// ClientKillByFilter is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockUniversalClient_Expecter) ClientKillByFilter(ctx interface{}, keys ...interface{}) *MockUniversalClient_ClientKillByFilter_Call {
	return &MockUniversalClient_ClientKillByFilter_Call{Call: _e.mock.On("ClientKillByFilter",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockUniversalClient_ClientKillByFilter_Call) Run(run func(ctx context.Context, keys ...string)) *MockUniversalClient_ClientKillByFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_ClientKillByFilter_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ClientKillByFilter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClientKillByFilter_Call) RunAndReturn(run func(context.Context, ...string) *redis.IntCmd) *MockUniversalClient_ClientKillByFilter_Call {
	_c.Call.Return(run)
	return _c
}

// ClientList provides a mock function with given fields: ctx
func (_m *MockUniversalClient) ClientList(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClientList")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClientList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientList'
type MockUniversalClient_ClientList_Call struct {
	*mock.Call
}

// ClientList is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) ClientList(ctx interface{}) *MockUniversalClient_ClientList_Call {
	return &MockUniversalClient_ClientList_Call{Call: _e.mock.On("ClientList", ctx)}
}

func (_c *MockUniversalClient_ClientList_Call) Run(run func(ctx context.Context)) *MockUniversalClient_ClientList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_ClientList_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_ClientList_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClientList_Call) RunAndReturn(run func(context.Context) *redis.StringCmd) *MockUniversalClient_ClientList_Call {
	_c.Call.Return(run)
	return _c
}

// ClientPause provides a mock function with given fields: ctx, dur
func (_m *MockUniversalClient) ClientPause(ctx context.Context, dur time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, dur)

	if len(ret) == 0 {
		panic("no return value specified for ClientPause")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, dur)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClientPause_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientPause'
type MockUniversalClient_ClientPause_Call struct {
	*mock.Call
}

// ClientPause is a helper method to define mock.On call
//   - ctx context.Context
//   - dur time.Duration
func (_e *MockUniversalClient_Expecter) ClientPause(ctx interface{}, dur interface{}) *MockUniversalClient_ClientPause_Call {
	return &MockUniversalClient_ClientPause_Call{Call: _e.mock.On("ClientPause", ctx, dur)}
}

func (_c *MockUniversalClient_ClientPause_Call) Run(run func(ctx context.Context, dur time.Duration)) *MockUniversalClient_ClientPause_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(time.Duration))
	})
	return _c
}

func (_c *MockUniversalClient_ClientPause_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_ClientPause_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClientPause_Call) RunAndReturn(run func(context.Context, time.Duration) *redis.BoolCmd) *MockUniversalClient_ClientPause_Call {
	_c.Call.Return(run)
	return _c
}

// Close provides a mock function with given fields:
func (_m *MockUniversalClient) Close() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockUniversalClient_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockUniversalClient_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockUniversalClient_Expecter) Close() *MockUniversalClient_Close_Call {
	return &MockUniversalClient_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockUniversalClient_Close_Call) Run(run func()) *MockUniversalClient_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockUniversalClient_Close_Call) Return(_a0 error) *MockUniversalClient_Close_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Close_Call) RunAndReturn(run func() error) *MockUniversalClient_Close_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterAddSlots provides a mock function with given fields: ctx, slots
func (_m *MockUniversalClient) ClusterAddSlots(ctx context.Context, slots ...int) *redis.StatusCmd {
	_va := make([]interface{}, len(slots))
	for _i := range slots {
		_va[_i] = slots[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterAddSlots")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...int) *redis.StatusCmd); ok {
		r0 = rf(ctx, slots...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClusterAddSlots_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterAddSlots'
type MockUniversalClient_ClusterAddSlots_Call struct {
	*mock.Call
}

// ClusterAddSlots is a helper method to define mock.On call
//   - ctx context.Context
//   - slots ...int
func (_e *MockUniversalClient_Expecter) ClusterAddSlots(ctx interface{}, slots ...interface{}) *MockUniversalClient_ClusterAddSlots_Call {
	return &MockUniversalClient_ClusterAddSlots_Call{Call: _e.mock.On("ClusterAddSlots",
		append([]interface{}{ctx}, slots...)...)}
}

func (_c *MockUniversalClient_ClusterAddSlots_Call) Run(run func(ctx context.Context, slots ...int)) *MockUniversalClient_ClusterAddSlots_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_ClusterAddSlots_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ClusterAddSlots_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClusterAddSlots_Call) RunAndReturn(run func(context.Context, ...int) *redis.StatusCmd) *MockUniversalClient_ClusterAddSlots_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterAddSlotsRange provides a mock function with given fields: ctx, min, max
func (_m *MockUniversalClient) ClusterAddSlotsRange(ctx context.Context, min int, max int) *redis.StatusCmd {
	ret := _m.Called(ctx, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ClusterAddSlotsRange")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int) *redis.StatusCmd); ok {
		r0 = rf(ctx, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClusterAddSlotsRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterAddSlotsRange'
type MockUniversalClient_ClusterAddSlotsRange_Call struct {
	*mock.Call
}

// ClusterAddSlotsRange is a helper method to define mock.On call
//   - ctx context.Context
//   - min int
//   - max int
func (_e *MockUniversalClient_Expecter) ClusterAddSlotsRange(ctx interface{}, min interface{}, max interface{}) *MockUniversalClient_ClusterAddSlotsRange_Call {
	return &MockUniversalClient_ClusterAddSlotsRange_Call{Call: _e.mock.On("ClusterAddSlotsRange", ctx, min, max)}
}

func (_c *MockUniversalClient_ClusterAddSlotsRange_Call) Run(run func(ctx context.Context, min int, max int)) *MockUniversalClient_ClusterAddSlotsRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockUniversalClient_ClusterAddSlotsRange_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ClusterAddSlotsRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClusterAddSlotsRange_Call) RunAndReturn(run func(context.Context, int, int) *redis.StatusCmd) *MockUniversalClient_ClusterAddSlotsRange_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterCountFailureReports provides a mock function with given fields: ctx, nodeID
func (_m *MockUniversalClient) ClusterCountFailureReports(ctx context.Context, nodeID string) *redis.IntCmd {
	ret := _m.Called(ctx, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterCountFailureReports")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClusterCountFailureReports_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterCountFailureReports'
type MockUniversalClient_ClusterCountFailureReports_Call struct {
	*mock.Call
}

// ClusterCountFailureReports is a helper method to define mock.On call
//   - ctx context.Context
//   - nodeID string
func (_e *MockUniversalClient_Expecter) ClusterCountFailureReports(ctx interface{}, nodeID interface{}) *MockUniversalClient_ClusterCountFailureReports_Call {
	return &MockUniversalClient_ClusterCountFailureReports_Call{Call: _e.mock.On("ClusterCountFailureReports", ctx, nodeID)}
}

func (_c *MockUniversalClient_ClusterCountFailureReports_Call) Run(run func(ctx context.Context, nodeID string)) *MockUniversalClient_ClusterCountFailureReports_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ClusterCountFailureReports_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ClusterCountFailureReports_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClusterCountFailureReports_Call) RunAndReturn(run func(context.Context, string) *redis.IntCmd) *MockUniversalClient_ClusterCountFailureReports_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterCountKeysInSlot provides a mock function with given fields: ctx, slot
func (_m *MockUniversalClient) ClusterCountKeysInSlot(ctx context.Context, slot int) *redis.IntCmd {
	ret := _m.Called(ctx, slot)

	if len(ret) == 0 {
		panic("no return value specified for ClusterCountKeysInSlot")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, int) *redis.IntCmd); ok {
		r0 = rf(ctx, slot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClusterCountKeysInSlot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterCountKeysInSlot'
type MockUniversalClient_ClusterCountKeysInSlot_Call struct {
	*mock.Call
}

// ClusterCountKeysInSlot is a helper method to define mock.On call
//   - ctx context.Context
//   - slot int
func (_e *MockUniversalClient_Expecter) ClusterCountKeysInSlot(ctx interface{}, slot interface{}) *MockUniversalClient_ClusterCountKeysInSlot_Call {
	return &MockUniversalClient_ClusterCountKeysInSlot_Call{Call: _e.mock.On("ClusterCountKeysInSlot", ctx, slot)}
}

func (_c *MockUniversalClient_ClusterCountKeysInSlot_Call) Run(run func(ctx context.Context, slot int)) *MockUniversalClient_ClusterCountKeysInSlot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockUniversalClient_ClusterCountKeysInSlot_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ClusterCountKeysInSlot_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClusterCountKeysInSlot_Call) RunAndReturn(run func(context.Context, int) *redis.IntCmd) *MockUniversalClient_ClusterCountKeysInSlot_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterDelSlots provides a mock function with given fields: ctx, slots
func (_m *MockUniversalClient) ClusterDelSlots(ctx context.Context, slots ...int) *redis.StatusCmd {
	_va := make([]interface{}, len(slots))
	for _i := range slots {
		_va[_i] = slots[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterDelSlots")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...int) *redis.StatusCmd); ok {
		r0 = rf(ctx, slots...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClusterDelSlots_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterDelSlots'
type MockUniversalClient_ClusterDelSlots_Call struct {
	*mock.Call
}

// ClusterDelSlots is a helper method to define mock.On call
//   - ctx context.Context
//   - slots ...int
func (_e *MockUniversalClient_Expecter) ClusterDelSlots(ctx interface{}, slots ...interface{}) *MockUniversalClient_ClusterDelSlots_Call {
	return &MockUniversalClient_ClusterDelSlots_Call{Call: _e.mock.On("ClusterDelSlots",
		append([]interface{}{ctx}, slots...)...)}
}

func (_c *MockUniversalClient_ClusterDelSlots_Call) Run(run func(ctx context.Context, slots ...int)) *MockUniversalClient_ClusterDelSlots_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_ClusterDelSlots_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ClusterDelSlots_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClusterDelSlots_Call) RunAndReturn(run func(context.Context, ...int) *redis.StatusCmd) *MockUniversalClient_ClusterDelSlots_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterDelSlotsRange provides a mock function with given fields: ctx, min, max
func (_m *MockUniversalClient) ClusterDelSlotsRange(ctx context.Context, min int, max int) *redis.StatusCmd {
	ret := _m.Called(ctx, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ClusterDelSlotsRange")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int) *redis.StatusCmd); ok {
		r0 = rf(ctx, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClusterDelSlotsRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterDelSlotsRange'
type MockUniversalClient_ClusterDelSlotsRange_Call struct {
	*mock.Call
}

// ClusterDelSlotsRange is a helper method to define mock.On call
//   - ctx context.Context
//   - min int
//   - max int
func (_e *MockUniversalClient_Expecter) ClusterDelSlotsRange(ctx interface{}, min interface{}, max interface{}) *MockUniversalClient_ClusterDelSlotsRange_Call {
	return &MockUniversalClient_ClusterDelSlotsRange_Call{Call: _e.mock.On("ClusterDelSlotsRange", ctx, min, max)}
}

func (_c *MockUniversalClient_ClusterDelSlotsRange_Call) Run(run func(ctx context.Context, min int, max int)) *MockUniversalClient_ClusterDelSlotsRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockUniversalClient_ClusterDelSlotsRange_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ClusterDelSlotsRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClusterDelSlotsRange_Call) RunAndReturn(run func(context.Context, int, int) *redis.StatusCmd) *MockUniversalClient_ClusterDelSlotsRange_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterFailover provides a mock function with given fields: ctx
func (_m *MockUniversalClient) ClusterFailover(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterFailover")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClusterFailover_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterFailover'
type MockUniversalClient_ClusterFailover_Call struct {
	*mock.Call
}

// ClusterFailover is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) ClusterFailover(ctx interface{}) *MockUniversalClient_ClusterFailover_Call {
	return &MockUniversalClient_ClusterFailover_Call{Call: _e.mock.On("ClusterFailover", ctx)}
}

func (_c *MockUniversalClient_ClusterFailover_Call) Run(run func(ctx context.Context)) *MockUniversalClient_ClusterFailover_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_ClusterFailover_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ClusterFailover_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClusterFailover_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_ClusterFailover_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterForget provides a mock function with given fields: ctx, nodeID
func (_m *MockUniversalClient) ClusterForget(ctx context.Context, nodeID string) *redis.StatusCmd {
	ret := _m.Called(ctx, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterForget")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClusterForget_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterForget'
type MockUniversalClient_ClusterForget_Call struct {
	*mock.Call
}

// ClusterForget is a helper method to define mock.On call
//   - ctx context.Context
//   - nodeID string
func (_e *MockUniversalClient_Expecter) ClusterForget(ctx interface{}, nodeID interface{}) *MockUniversalClient_ClusterForget_Call {
	return &MockUniversalClient_ClusterForget_Call{Call: _e.mock.On("ClusterForget", ctx, nodeID)}
}

func (_c *MockUniversalClient_ClusterForget_Call) Run(run func(ctx context.Context, nodeID string)) *MockUniversalClient_ClusterForget_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ClusterForget_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ClusterForget_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClusterForget_Call) RunAndReturn(run func(context.Context, string) *redis.StatusCmd) *MockUniversalClient_ClusterForget_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterGetKeysInSlot provides a mock function with given fields: ctx, slot, count
func (_m *MockUniversalClient) ClusterGetKeysInSlot(ctx context.Context, slot int, count int) *redis.StringSliceCmd {
	ret := _m.Called(ctx, slot, count)

	if len(ret) == 0 {
		panic("no return value specified for ClusterGetKeysInSlot")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, slot, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClusterGetKeysInSlot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterGetKeysInSlot'
type MockUniversalClient_ClusterGetKeysInSlot_Call struct {
	*mock.Call
}

// ClusterGetKeysInSlot is a helper method to define mock.On call
//   - ctx context.Context
//   - slot int
//   - count int
func (_e *MockUniversalClient_Expecter) ClusterGetKeysInSlot(ctx interface{}, slot interface{}, count interface{}) *MockUniversalClient_ClusterGetKeysInSlot_Call {
	return &MockUniversalClient_ClusterGetKeysInSlot_Call{Call: _e.mock.On("ClusterGetKeysInSlot", ctx, slot, count)}
}

func (_c *MockUniversalClient_ClusterGetKeysInSlot_Call) Run(run func(ctx context.Context, slot int, count int)) *MockUniversalClient_ClusterGetKeysInSlot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockUniversalClient_ClusterGetKeysInSlot_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_ClusterGetKeysInSlot_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClusterGetKeysInSlot_Call) RunAndReturn(run func(context.Context, int, int) *redis.StringSliceCmd) *MockUniversalClient_ClusterGetKeysInSlot_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterInfo provides a mock function with given fields: ctx
func (_m *MockUniversalClient) ClusterInfo(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterInfo")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClusterInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterInfo'
type MockUniversalClient_ClusterInfo_Call struct {
	*mock.Call
}

// ClusterInfo is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) ClusterInfo(ctx interface{}) *MockUniversalClient_ClusterInfo_Call {
	return &MockUniversalClient_ClusterInfo_Call{Call: _e.mock.On("ClusterInfo", ctx)}
}

func (_c *MockUniversalClient_ClusterInfo_Call) Run(run func(ctx context.Context)) *MockUniversalClient_ClusterInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_ClusterInfo_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_ClusterInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClusterInfo_Call) RunAndReturn(run func(context.Context) *redis.StringCmd) *MockUniversalClient_ClusterInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterKeySlot provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) ClusterKeySlot(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ClusterKeySlot")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClusterKeySlot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterKeySlot'
type MockUniversalClient_ClusterKeySlot_Call struct {
	*mock.Call
}

// ClusterKeySlot is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) ClusterKeySlot(ctx interface{}, key interface{}) *MockUniversalClient_ClusterKeySlot_Call {
	return &MockUniversalClient_ClusterKeySlot_Call{Call: _e.mock.On("ClusterKeySlot", ctx, key)}
}

func (_c *MockUniversalClient_ClusterKeySlot_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_ClusterKeySlot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ClusterKeySlot_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ClusterKeySlot_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClusterKeySlot_Call) RunAndReturn(run func(context.Context, string) *redis.IntCmd) *MockUniversalClient_ClusterKeySlot_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterMeet provides a mock function with given fields: ctx, host, port
func (_m *MockUniversalClient) ClusterMeet(ctx context.Context, host string, port string) *redis.StatusCmd {
	ret := _m.Called(ctx, host, port)

	if len(ret) == 0 {
		panic("no return value specified for ClusterMeet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, host, port)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClusterMeet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterMeet'
type MockUniversalClient_ClusterMeet_Call struct {
	*mock.Call
}

// ClusterMeet is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port string
func (_e *MockUniversalClient_Expecter) ClusterMeet(ctx interface{}, host interface{}, port interface{}) *MockUniversalClient_ClusterMeet_Call {
	return &MockUniversalClient_ClusterMeet_Call{Call: _e.mock.On("ClusterMeet", ctx, host, port)}
}

func (_c *MockUniversalClient_ClusterMeet_Call) Run(run func(ctx context.Context, host string, port string)) *MockUniversalClient_ClusterMeet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ClusterMeet_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ClusterMeet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClusterMeet_Call) RunAndReturn(run func(context.Context, string, string) *redis.StatusCmd) *MockUniversalClient_ClusterMeet_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterNodes provides a mock function with given fields: ctx
func (_m *MockUniversalClient) ClusterNodes(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterNodes")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClusterNodes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterNodes'
type MockUniversalClient_ClusterNodes_Call struct {
	*mock.Call
}

// ClusterNodes is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) ClusterNodes(ctx interface{}) *MockUniversalClient_ClusterNodes_Call {
	return &MockUniversalClient_ClusterNodes_Call{Call: _e.mock.On("ClusterNodes", ctx)}
}

func (_c *MockUniversalClient_ClusterNodes_Call) Run(run func(ctx context.Context)) *MockUniversalClient_ClusterNodes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_ClusterNodes_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_ClusterNodes_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClusterNodes_Call) RunAndReturn(run func(context.Context) *redis.StringCmd) *MockUniversalClient_ClusterNodes_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterReplicate provides a mock function with given fields: ctx, nodeID
func (_m *MockUniversalClient) ClusterReplicate(ctx context.Context, nodeID string) *redis.StatusCmd {
	ret := _m.Called(ctx, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterReplicate")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClusterReplicate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterReplicate'
type MockUniversalClient_ClusterReplicate_Call struct {
	*mock.Call
}

// ClusterReplicate is a helper method to define mock.On call
//   - ctx context.Context
//   - nodeID string
func (_e *MockUniversalClient_Expecter) ClusterReplicate(ctx interface{}, nodeID interface{}) *MockUniversalClient_ClusterReplicate_Call {
	return &MockUniversalClient_ClusterReplicate_Call{Call: _e.mock.On("ClusterReplicate", ctx, nodeID)}
}

func (_c *MockUniversalClient_ClusterReplicate_Call) Run(run func(ctx context.Context, nodeID string)) *MockUniversalClient_ClusterReplicate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ClusterReplicate_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ClusterReplicate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClusterReplicate_Call) RunAndReturn(run func(context.Context, string) *redis.StatusCmd) *MockUniversalClient_ClusterReplicate_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterResetHard provides a mock function with given fields: ctx
func (_m *MockUniversalClient) ClusterResetHard(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterResetHard")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClusterResetHard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterResetHard'
type MockUniversalClient_ClusterResetHard_Call struct {
	*mock.Call
}

// ClusterResetHard is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) ClusterResetHard(ctx interface{}) *MockUniversalClient_ClusterResetHard_Call {
	return &MockUniversalClient_ClusterResetHard_Call{Call: _e.mock.On("ClusterResetHard", ctx)}
}

func (_c *MockUniversalClient_ClusterResetHard_Call) Run(run func(ctx context.Context)) *MockUniversalClient_ClusterResetHard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_ClusterResetHard_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ClusterResetHard_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClusterResetHard_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_ClusterResetHard_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterResetSoft provides a mock function with given fields: ctx
func (_m *MockUniversalClient) ClusterResetSoft(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterResetSoft")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClusterResetSoft_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterResetSoft'
type MockUniversalClient_ClusterResetSoft_Call struct {
	*mock.Call
}

// ClusterResetSoft is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) ClusterResetSoft(ctx interface{}) *MockUniversalClient_ClusterResetSoft_Call {
	return &MockUniversalClient_ClusterResetSoft_Call{Call: _e.mock.On("ClusterResetSoft", ctx)}
}

func (_c *MockUniversalClient_ClusterResetSoft_Call) Run(run func(ctx context.Context)) *MockUniversalClient_ClusterResetSoft_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_ClusterResetSoft_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ClusterResetSoft_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClusterResetSoft_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_ClusterResetSoft_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterSaveConfig provides a mock function with given fields: ctx
func (_m *MockUniversalClient) ClusterSaveConfig(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterSaveConfig")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClusterSaveConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterSaveConfig'
type MockUniversalClient_ClusterSaveConfig_Call struct {
	*mock.Call
}

// ClusterSaveConfig is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) ClusterSaveConfig(ctx interface{}) *MockUniversalClient_ClusterSaveConfig_Call {
	return &MockUniversalClient_ClusterSaveConfig_Call{Call: _e.mock.On("ClusterSaveConfig", ctx)}
}

func (_c *MockUniversalClient_ClusterSaveConfig_Call) Run(run func(ctx context.Context)) *MockUniversalClient_ClusterSaveConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_ClusterSaveConfig_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ClusterSaveConfig_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClusterSaveConfig_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_ClusterSaveConfig_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterSlaves provides a mock function with given fields: ctx, nodeID
func (_m *MockUniversalClient) ClusterSlaves(ctx context.Context, nodeID string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterSlaves")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClusterSlaves_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterSlaves'
type MockUniversalClient_ClusterSlaves_Call struct {
	*mock.Call
}

// ClusterSlaves is a helper method to define mock.On call
//   - ctx context.Context
//   - nodeID string
func (_e *MockUniversalClient_Expecter) ClusterSlaves(ctx interface{}, nodeID interface{}) *MockUniversalClient_ClusterSlaves_Call {
	return &MockUniversalClient_ClusterSlaves_Call{Call: _e.mock.On("ClusterSlaves", ctx, nodeID)}
}

func (_c *MockUniversalClient_ClusterSlaves_Call) Run(run func(ctx context.Context, nodeID string)) *MockUniversalClient_ClusterSlaves_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ClusterSlaves_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_ClusterSlaves_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClusterSlaves_Call) RunAndReturn(run func(context.Context, string) *redis.StringSliceCmd) *MockUniversalClient_ClusterSlaves_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterSlots provides a mock function with given fields: ctx
func (_m *MockUniversalClient) ClusterSlots(ctx context.Context) *redis.ClusterSlotsCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterSlots")
	}

	var r0 *redis.ClusterSlotsCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.ClusterSlotsCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ClusterSlotsCmd)
		}
	}

	return r0
}

// MockUniversalClient_ClusterSlots_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterSlots'
type MockUniversalClient_ClusterSlots_Call struct {
	*mock.Call
}

// ClusterSlots is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) ClusterSlots(ctx interface{}) *MockUniversalClient_ClusterSlots_Call {
	return &MockUniversalClient_ClusterSlots_Call{Call: _e.mock.On("ClusterSlots", ctx)}
}

func (_c *MockUniversalClient_ClusterSlots_Call) Run(run func(ctx context.Context)) *MockUniversalClient_ClusterSlots_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_ClusterSlots_Call) Return(_a0 *redis.ClusterSlotsCmd) *MockUniversalClient_ClusterSlots_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ClusterSlots_Call) RunAndReturn(run func(context.Context) *redis.ClusterSlotsCmd) *MockUniversalClient_ClusterSlots_Call {
	_c.Call.Return(run)
	return _c
}

// Command provides a mock function with given fields: ctx
func (_m *MockUniversalClient) Command(ctx context.Context) *redis.CommandsInfoCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Command")
	}

	var r0 *redis.CommandsInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.CommandsInfoCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.CommandsInfoCmd)
		}
	}

	return r0
}

// MockUniversalClient_Command_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Command'
type MockUniversalClient_Command_Call struct {
	*mock.Call
}

// Command is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) Command(ctx interface{}) *MockUniversalClient_Command_Call {
	return &MockUniversalClient_Command_Call{Call: _e.mock.On("Command", ctx)}
}

func (_c *MockUniversalClient_Command_Call) Run(run func(ctx context.Context)) *MockUniversalClient_Command_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_Command_Call) Return(_a0 *redis.CommandsInfoCmd) *MockUniversalClient_Command_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Command_Call) RunAndReturn(run func(context.Context) *redis.CommandsInfoCmd) *MockUniversalClient_Command_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigGet provides a mock function with given fields: ctx, parameter
func (_m *MockUniversalClient) ConfigGet(ctx context.Context, parameter string) *redis.SliceCmd {
	ret := _m.Called(ctx, parameter)

	if len(ret) == 0 {
		panic("no return value specified for ConfigGet")
	}

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.SliceCmd); ok {
		r0 = rf(ctx, parameter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ConfigGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigGet'
type MockUniversalClient_ConfigGet_Call struct {
	*mock.Call
}

// ConfigGet is a helper method to define mock.On call
//   - ctx context.Context
//   - parameter string
func (_e *MockUniversalClient_Expecter) ConfigGet(ctx interface{}, parameter interface{}) *MockUniversalClient_ConfigGet_Call {
	return &MockUniversalClient_ConfigGet_Call{Call: _e.mock.On("ConfigGet", ctx, parameter)}
}

func (_c *MockUniversalClient_ConfigGet_Call) Run(run func(ctx context.Context, parameter string)) *MockUniversalClient_ConfigGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ConfigGet_Call) Return(_a0 *redis.SliceCmd) *MockUniversalClient_ConfigGet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ConfigGet_Call) RunAndReturn(run func(context.Context, string) *redis.SliceCmd) *MockUniversalClient_ConfigGet_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigResetStat provides a mock function with given fields: ctx
func (_m *MockUniversalClient) ConfigResetStat(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ConfigResetStat")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ConfigResetStat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigResetStat'
type MockUniversalClient_ConfigResetStat_Call struct {
	*mock.Call
}

// ConfigResetStat is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) ConfigResetStat(ctx interface{}) *MockUniversalClient_ConfigResetStat_Call {
	return &MockUniversalClient_ConfigResetStat_Call{Call: _e.mock.On("ConfigResetStat", ctx)}
}

func (_c *MockUniversalClient_ConfigResetStat_Call) Run(run func(ctx context.Context)) *MockUniversalClient_ConfigResetStat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_ConfigResetStat_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ConfigResetStat_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ConfigResetStat_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_ConfigResetStat_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigRewrite provides a mock function with given fields: ctx
func (_m *MockUniversalClient) ConfigRewrite(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ConfigRewrite")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ConfigRewrite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigRewrite'
type MockUniversalClient_ConfigRewrite_Call struct {
	*mock.Call
}

// ConfigRewrite is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) ConfigRewrite(ctx interface{}) *MockUniversalClient_ConfigRewrite_Call {
	return &MockUniversalClient_ConfigRewrite_Call{Call: _e.mock.On("ConfigRewrite", ctx)}
}

func (_c *MockUniversalClient_ConfigRewrite_Call) Run(run func(ctx context.Context)) *MockUniversalClient_ConfigRewrite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_ConfigRewrite_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ConfigRewrite_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ConfigRewrite_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_ConfigRewrite_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigSet provides a mock function with given fields: ctx, parameter, value
func (_m *MockUniversalClient) ConfigSet(ctx context.Context, parameter string, value string) *redis.StatusCmd {
	ret := _m.Called(ctx, parameter, value)

	if len(ret) == 0 {
		panic("no return value specified for ConfigSet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, parameter, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ConfigSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigSet'
type MockUniversalClient_ConfigSet_Call struct {
	*mock.Call
}

// ConfigSet is a helper method to define mock.On call
//   - ctx context.Context
//   - parameter string
//   - value string
func (_e *MockUniversalClient_Expecter) ConfigSet(ctx interface{}, parameter interface{}, value interface{}) *MockUniversalClient_ConfigSet_Call {
	return &MockUniversalClient_ConfigSet_Call{Call: _e.mock.On("ConfigSet", ctx, parameter, value)}
}

func (_c *MockUniversalClient_ConfigSet_Call) Run(run func(ctx context.Context, parameter string, value string)) *MockUniversalClient_ConfigSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ConfigSet_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ConfigSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ConfigSet_Call) RunAndReturn(run func(context.Context, string, string) *redis.StatusCmd) *MockUniversalClient_ConfigSet_Call {
	_c.Call.Return(run)
	return _c
}

// Context provides a mock function with given fields:
func (_m *MockUniversalClient) Context() context.Context {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Context")
	}

	var r0 context.Context
	if rf, ok := ret.Get(0).(func() context.Context); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(context.Context)
		}
	}

	return r0
}

// MockUniversalClient_Context_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Context'
type MockUniversalClient_Context_Call struct {
	*mock.Call
}

// Context is a helper method to define mock.On call
func (_e *MockUniversalClient_Expecter) Context() *MockUniversalClient_Context_Call {
	return &MockUniversalClient_Context_Call{Call: _e.mock.On("Context")}
}

func (_c *MockUniversalClient_Context_Call) Run(run func()) *MockUniversalClient_Context_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockUniversalClient_Context_Call) Return(_a0 context.Context) *MockUniversalClient_Context_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Context_Call) RunAndReturn(run func() context.Context) *MockUniversalClient_Context_Call {
	_c.Call.Return(run)
	return _c
}

// Copy provides a mock function with given fields: ctx, sourceKey, destKey, db, replace
func (_m *MockUniversalClient) Copy(ctx context.Context, sourceKey string, destKey string, db int, replace bool) *redis.IntCmd {
	ret := _m.Called(ctx, sourceKey, destKey, db, replace)

	if len(ret) == 0 {
		panic("no return value specified for Copy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, bool) *redis.IntCmd); ok {
		r0 = rf(ctx, sourceKey, destKey, db, replace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_Copy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Copy'
type MockUniversalClient_Copy_Call struct {
	*mock.Call
}

// Copy is a helper method to define mock.On call
//   - ctx context.Context
//   - sourceKey string
//   - destKey string
//   - db int
//   - replace bool
func (_e *MockUniversalClient_Expecter) Copy(ctx interface{}, sourceKey interface{}, destKey interface{}, db interface{}, replace interface{}) *MockUniversalClient_Copy_Call {
	return &MockUniversalClient_Copy_Call{Call: _e.mock.On("Copy", ctx, sourceKey, destKey, db, replace)}
}

func (_c *MockUniversalClient_Copy_Call) Run(run func(ctx context.Context, sourceKey string, destKey string, db int, replace bool)) *MockUniversalClient_Copy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int), args[4].(bool))
	})
	return _c
}

func (_c *MockUniversalClient_Copy_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_Copy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Copy_Call) RunAndReturn(run func(context.Context, string, string, int, bool) *redis.IntCmd) *MockUniversalClient_Copy_Call {
	_c.Call.Return(run)
	return _c
}

// DBSize provides a mock function with given fields: ctx
func (_m *MockUniversalClient) DBSize(ctx context.Context) *redis.IntCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for DBSize")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.IntCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_DBSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DBSize'
type MockUniversalClient_DBSize_Call struct {
	*mock.Call
}

// DBSize is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) DBSize(ctx interface{}) *MockUniversalClient_DBSize_Call {
	return &MockUniversalClient_DBSize_Call{Call: _e.mock.On("DBSize", ctx)}
}

func (_c *MockUniversalClient_DBSize_Call) Run(run func(ctx context.Context)) *MockUniversalClient_DBSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_DBSize_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_DBSize_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_DBSize_Call) RunAndReturn(run func(context.Context) *redis.IntCmd) *MockUniversalClient_DBSize_Call {
	_c.Call.Return(run)
	return _c
}

// DebugObject provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) DebugObject(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for DebugObject")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_DebugObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DebugObject'
type MockUniversalClient_DebugObject_Call struct {
	*mock.Call
}

// DebugObject is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) DebugObject(ctx interface{}, key interface{}) *MockUniversalClient_DebugObject_Call {
	return &MockUniversalClient_DebugObject_Call{Call: _e.mock.On("DebugObject", ctx, key)}
}

func (_c *MockUniversalClient_DebugObject_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_DebugObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_DebugObject_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_DebugObject_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_DebugObject_Call) RunAndReturn(run func(context.Context, string) *redis.StringCmd) *MockUniversalClient_DebugObject_Call {
	_c.Call.Return(run)
	return _c
}

// Decr provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) Decr(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Decr")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_Decr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Decr'
type MockUniversalClient_Decr_Call struct {
	*mock.Call
}

// Decr is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) Decr(ctx interface{}, key interface{}) *MockUniversalClient_Decr_Call {
	return &MockUniversalClient_Decr_Call{Call: _e.mock.On("Decr", ctx, key)}
}

func (_c *MockUniversalClient_Decr_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_Decr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_Decr_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_Decr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Decr_Call) RunAndReturn(run func(context.Context, string) *redis.IntCmd) *MockUniversalClient_Decr_Call {
	_c.Call.Return(run)
	return _c
}

// DecrBy provides a mock function with given fields: ctx, key, decrement
func (_m *MockUniversalClient) DecrBy(ctx context.Context, key string, decrement int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, decrement)

	if len(ret) == 0 {
		panic("no return value specified for DecrBy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, decrement)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_DecrBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DecrBy'
type MockUniversalClient_DecrBy_Call struct {
	*mock.Call
}

// DecrBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - decrement int64
func (_e *MockUniversalClient_Expecter) DecrBy(ctx interface{}, key interface{}, decrement interface{}) *MockUniversalClient_DecrBy_Call {
	return &MockUniversalClient_DecrBy_Call{Call: _e.mock.On("DecrBy", ctx, key, decrement)}
}

func (_c *MockUniversalClient_DecrBy_Call) Run(run func(ctx context.Context, key string, decrement int64)) *MockUniversalClient_DecrBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_DecrBy_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_DecrBy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_DecrBy_Call) RunAndReturn(run func(context.Context, string, int64) *redis.IntCmd) *MockUniversalClient_DecrBy_Call {
	_c.Call.Return(run)
	return _c
}

// Del provides a mock function with given fields: ctx, keys
func (_m *MockUniversalClient) Del(ctx context.Context, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Del")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_Del_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Del'
type MockUniversalClient_Del_Call struct {
	*mock.Call
}

// Del is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockUniversalClient_Expecter) Del(ctx interface{}, keys ...interface{}) *MockUniversalClient_Del_Call {
	return &MockUniversalClient_Del_Call{Call: _e.mock.On("Del",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockUniversalClient_Del_Call) Run(run func(ctx context.Context, keys ...string)) *MockUniversalClient_Del_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_Del_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_Del_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Del_Call) RunAndReturn(run func(context.Context, ...string) *redis.IntCmd) *MockUniversalClient_Del_Call {
	_c.Call.Return(run)
	return _c
}

// Do provides a mock function with given fields: ctx, args
func (_m *MockUniversalClient) Do(ctx context.Context, args ...interface{}) *redis.Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Do")
	}

	var r0 *redis.Cmd
	if rf, ok := ret.Get(0).(func(context.Context, ...interface{}) *redis.Cmd); ok {
		r0 = rf(ctx, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.Cmd)
		}
	}

	return r0
}

// MockUniversalClient_Do_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Do'
type MockUniversalClient_Do_Call struct {
	*mock.Call
}

// Do is a helper method to define mock.On call
//   - ctx context.Context
//   - args ...interface{}
func (_e *MockUniversalClient_Expecter) Do(ctx interface{}, args ...interface{}) *MockUniversalClient_Do_Call {
	return &MockUniversalClient_Do_Call{Call: _e.mock.On("Do",
		append([]interface{}{ctx}, args...)...)}
}

func (_c *MockUniversalClient_Do_Call) Run(run func(ctx context.Context, args ...interface{})) *MockUniversalClient_Do_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_Do_Call) Return(_a0 *redis.Cmd) *MockUniversalClient_Do_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Do_Call) RunAndReturn(run func(context.Context, ...interface{}) *redis.Cmd) *MockUniversalClient_Do_Call {
	_c.Call.Return(run)
	return _c
}

// Dump provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) Dump(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Dump")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_Dump_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Dump'
type MockUniversalClient_Dump_Call struct {
	*mock.Call
}

// Dump is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) Dump(ctx interface{}, key interface{}) *MockUniversalClient_Dump_Call {
	return &MockUniversalClient_Dump_Call{Call: _e.mock.On("Dump", ctx, key)}
}

func (_c *MockUniversalClient_Dump_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_Dump_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_Dump_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_Dump_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Dump_Call) RunAndReturn(run func(context.Context, string) *redis.StringCmd) *MockUniversalClient_Dump_Call {
	_c.Call.Return(run)
	return _c
}

// Echo provides a mock function with given fields: ctx, message
func (_m *MockUniversalClient) Echo(ctx context.Context, message interface{}) *redis.StringCmd {
	ret := _m.Called(ctx, message)

	if len(ret) == 0 {
		panic("no return value specified for Echo")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, interface{}) *redis.StringCmd); ok {
		r0 = rf(ctx, message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_Echo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Echo'
type MockUniversalClient_Echo_Call struct {
	*mock.Call
}

// Echo is a helper method to define mock.On call
//   - ctx context.Context
//   - message interface{}
func (_e *MockUniversalClient_Expecter) Echo(ctx interface{}, message interface{}) *MockUniversalClient_Echo_Call {
	return &MockUniversalClient_Echo_Call{Call: _e.mock.On("Echo", ctx, message)}
}

func (_c *MockUniversalClient_Echo_Call) Run(run func(ctx context.Context, message interface{})) *MockUniversalClient_Echo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(interface{}))
	})
	return _c
}

func (_c *MockUniversalClient_Echo_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_Echo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Echo_Call) RunAndReturn(run func(context.Context, interface{}) *redis.StringCmd) *MockUniversalClient_Echo_Call {
	_c.Call.Return(run)
	return _c
}

// Eval provides a mock function with given fields: ctx, script, keys, args
func (_m *MockUniversalClient) Eval(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, script, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Eval")
	}

	var r0 *redis.Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *redis.Cmd); ok {
		r0 = rf(ctx, script, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.Cmd)
		}
	}

	return r0
}

// MockUniversalClient_Eval_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Eval'
type MockUniversalClient_Eval_Call struct {
	*mock.Call
}

// Eval is a helper method to define mock.On call
//   - ctx context.Context
//   - script string
//   - keys []string
//   - args ...interface{}
func (_e *MockUniversalClient_Expecter) Eval(ctx interface{}, script interface{}, keys interface{}, args ...interface{}) *MockUniversalClient_Eval_Call {
	return &MockUniversalClient_Eval_Call{Call: _e.mock.On("Eval",
		append([]interface{}{ctx, script, keys}, args...)...)}
}

func (_c *MockUniversalClient_Eval_Call) Run(run func(ctx context.Context, script string, keys []string, args ...interface{})) *MockUniversalClient_Eval_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_Eval_Call) Return(_a0 *redis.Cmd) *MockUniversalClient_Eval_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Eval_Call) RunAndReturn(run func(context.Context, string, []string, ...interface{}) *redis.Cmd) *MockUniversalClient_Eval_Call {
	_c.Call.Return(run)
	return _c
}

// EvalSha provides a mock function with given fields: ctx, sha1, keys, args
func (_m *MockUniversalClient) EvalSha(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, sha1, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EvalSha")
	}

	var r0 *redis.Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *redis.Cmd); ok {
		r0 = rf(ctx, sha1, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.Cmd)
		}
	}

	return r0
}

// MockUniversalClient_EvalSha_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EvalSha'
type MockUniversalClient_EvalSha_Call struct {
	*mock.Call
}

// EvalSha is a helper method to define mock.On call
//   - ctx context.Context
//   - sha1 string
//   - keys []string
//   - args ...interface{}
func (_e *MockUniversalClient_Expecter) EvalSha(ctx interface{}, sha1 interface{}, keys interface{}, args ...interface{}) *MockUniversalClient_EvalSha_Call {
	return &MockUniversalClient_EvalSha_Call{Call: _e.mock.On("EvalSha",
		append([]interface{}{ctx, sha1, keys}, args...)...)}
}

func (_c *MockUniversalClient_EvalSha_Call) Run(run func(ctx context.Context, sha1 string, keys []string, args ...interface{})) *MockUniversalClient_EvalSha_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_EvalSha_Call) Return(_a0 *redis.Cmd) *MockUniversalClient_EvalSha_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_EvalSha_Call) RunAndReturn(run func(context.Context, string, []string, ...interface{}) *redis.Cmd) *MockUniversalClient_EvalSha_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function with given fields: ctx, keys
func (_m *MockUniversalClient) Exists(ctx context.Context, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockUniversalClient_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockUniversalClient_Expecter) Exists(ctx interface{}, keys ...interface{}) *MockUniversalClient_Exists_Call {
	return &MockUniversalClient_Exists_Call{Call: _e.mock.On("Exists",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockUniversalClient_Exists_Call) Run(run func(ctx context.Context, keys ...string)) *MockUniversalClient_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_Exists_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_Exists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Exists_Call) RunAndReturn(run func(context.Context, ...string) *redis.IntCmd) *MockUniversalClient_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Expire provides a mock function with given fields: ctx, key, expiration
func (_m *MockUniversalClient) Expire(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for Expire")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_Expire_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Expire'
type MockUniversalClient_Expire_Call struct {
	*mock.Call
}

// Expire is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockUniversalClient_Expecter) Expire(ctx interface{}, key interface{}, expiration interface{}) *MockUniversalClient_Expire_Call {
	return &MockUniversalClient_Expire_Call{Call: _e.mock.On("Expire", ctx, key, expiration)}
}

func (_c *MockUniversalClient_Expire_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockUniversalClient_Expire_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockUniversalClient_Expire_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_Expire_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Expire_Call) RunAndReturn(run func(context.Context, string, time.Duration) *redis.BoolCmd) *MockUniversalClient_Expire_Call {
	_c.Call.Return(run)
	return _c
}

// ExpireAt provides a mock function with given fields: ctx, key, tm
func (_m *MockUniversalClient) ExpireAt(ctx context.Context, key string, tm time.Time) *redis.BoolCmd {
	ret := _m.Called(ctx, key, tm)

	if len(ret) == 0 {
		panic("no return value specified for ExpireAt")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, tm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_ExpireAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpireAt'
type MockUniversalClient_ExpireAt_Call struct {
	*mock.Call
}

// ExpireAt is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - tm time.Time
func (_e *MockUniversalClient_Expecter) ExpireAt(ctx interface{}, key interface{}, tm interface{}) *MockUniversalClient_ExpireAt_Call {
	return &MockUniversalClient_ExpireAt_Call{Call: _e.mock.On("ExpireAt", ctx, key, tm)}
}

func (_c *MockUniversalClient_ExpireAt_Call) Run(run func(ctx context.Context, key string, tm time.Time)) *MockUniversalClient_ExpireAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Time))
	})
	return _c
}

func (_c *MockUniversalClient_ExpireAt_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_ExpireAt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ExpireAt_Call) RunAndReturn(run func(context.Context, string, time.Time) *redis.BoolCmd) *MockUniversalClient_ExpireAt_Call {
	_c.Call.Return(run)
	return _c
}

// ExpireGT provides a mock function with given fields: ctx, key, expiration
func (_m *MockUniversalClient) ExpireGT(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireGT")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_ExpireGT_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpireGT'
type MockUniversalClient_ExpireGT_Call struct {
	*mock.Call
}

// ExpireGT is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockUniversalClient_Expecter) ExpireGT(ctx interface{}, key interface{}, expiration interface{}) *MockUniversalClient_ExpireGT_Call {
	return &MockUniversalClient_ExpireGT_Call{Call: _e.mock.On("ExpireGT", ctx, key, expiration)}
}

func (_c *MockUniversalClient_ExpireGT_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockUniversalClient_ExpireGT_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockUniversalClient_ExpireGT_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_ExpireGT_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ExpireGT_Call) RunAndReturn(run func(context.Context, string, time.Duration) *redis.BoolCmd) *MockUniversalClient_ExpireGT_Call {
	_c.Call.Return(run)
	return _c
}

// ExpireLT provides a mock function with given fields: ctx, key, expiration
func (_m *MockUniversalClient) ExpireLT(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireLT")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_ExpireLT_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpireLT'
type MockUniversalClient_ExpireLT_Call struct {
	*mock.Call
}

// ExpireLT is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockUniversalClient_Expecter) ExpireLT(ctx interface{}, key interface{}, expiration interface{}) *MockUniversalClient_ExpireLT_Call {
	return &MockUniversalClient_ExpireLT_Call{Call: _e.mock.On("ExpireLT", ctx, key, expiration)}
}

func (_c *MockUniversalClient_ExpireLT_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockUniversalClient_ExpireLT_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockUniversalClient_ExpireLT_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_ExpireLT_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ExpireLT_Call) RunAndReturn(run func(context.Context, string, time.Duration) *redis.BoolCmd) *MockUniversalClient_ExpireLT_Call {
	_c.Call.Return(run)
	return _c
}

// ExpireNX provides a mock function with given fields: ctx, key, expiration
func (_m *MockUniversalClient) ExpireNX(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_ExpireNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpireNX'
type MockUniversalClient_ExpireNX_Call struct {
	*mock.Call
}

// ExpireNX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockUniversalClient_Expecter) ExpireNX(ctx interface{}, key interface{}, expiration interface{}) *MockUniversalClient_ExpireNX_Call {
	return &MockUniversalClient_ExpireNX_Call{Call: _e.mock.On("ExpireNX", ctx, key, expiration)}
}

func (_c *MockUniversalClient_ExpireNX_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockUniversalClient_ExpireNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockUniversalClient_ExpireNX_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_ExpireNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ExpireNX_Call) RunAndReturn(run func(context.Context, string, time.Duration) *redis.BoolCmd) *MockUniversalClient_ExpireNX_Call {
	_c.Call.Return(run)
	return _c
}

// ExpireXX provides a mock function with given fields: ctx, key, expiration
func (_m *MockUniversalClient) ExpireXX(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireXX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_ExpireXX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpireXX'
type MockUniversalClient_ExpireXX_Call struct {
	*mock.Call
}

// ExpireXX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockUniversalClient_Expecter) ExpireXX(ctx interface{}, key interface{}, expiration interface{}) *MockUniversalClient_ExpireXX_Call {
	return &MockUniversalClient_ExpireXX_Call{Call: _e.mock.On("ExpireXX", ctx, key, expiration)}
}

func (_c *MockUniversalClient_ExpireXX_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockUniversalClient_ExpireXX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockUniversalClient_ExpireXX_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_ExpireXX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ExpireXX_Call) RunAndReturn(run func(context.Context, string, time.Duration) *redis.BoolCmd) *MockUniversalClient_ExpireXX_Call {
	_c.Call.Return(run)
	return _c
}

// FlushAll provides a mock function with given fields: ctx
func (_m *MockUniversalClient) FlushAll(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FlushAll")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_FlushAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FlushAll'
type MockUniversalClient_FlushAll_Call struct {
	*mock.Call
}

// FlushAll is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) FlushAll(ctx interface{}) *MockUniversalClient_FlushAll_Call {
	return &MockUniversalClient_FlushAll_Call{Call: _e.mock.On("FlushAll", ctx)}
}

func (_c *MockUniversalClient_FlushAll_Call) Run(run func(ctx context.Context)) *MockUniversalClient_FlushAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_FlushAll_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_FlushAll_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_FlushAll_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_FlushAll_Call {
	_c.Call.Return(run)
	return _c
}

// FlushAllAsync provides a mock function with given fields: ctx
func (_m *MockUniversalClient) FlushAllAsync(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FlushAllAsync")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_FlushAllAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FlushAllAsync'
type MockUniversalClient_FlushAllAsync_Call struct {
	*mock.Call
}

// FlushAllAsync is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) FlushAllAsync(ctx interface{}) *MockUniversalClient_FlushAllAsync_Call {
	return &MockUniversalClient_FlushAllAsync_Call{Call: _e.mock.On("FlushAllAsync", ctx)}
}

func (_c *MockUniversalClient_FlushAllAsync_Call) Run(run func(ctx context.Context)) *MockUniversalClient_FlushAllAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_FlushAllAsync_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_FlushAllAsync_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_FlushAllAsync_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_FlushAllAsync_Call {
	_c.Call.Return(run)
	return _c
}

// FlushDB provides a mock function with given fields: ctx
func (_m *MockUniversalClient) FlushDB(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FlushDB")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_FlushDB_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FlushDB'
type MockUniversalClient_FlushDB_Call struct {
	*mock.Call
}

// FlushDB is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) FlushDB(ctx interface{}) *MockUniversalClient_FlushDB_Call {
	return &MockUniversalClient_FlushDB_Call{Call: _e.mock.On("FlushDB", ctx)}
}

func (_c *MockUniversalClient_FlushDB_Call) Run(run func(ctx context.Context)) *MockUniversalClient_FlushDB_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_FlushDB_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_FlushDB_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_FlushDB_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_FlushDB_Call {
	_c.Call.Return(run)
	return _c
}

// FlushDBAsync provides a mock function with given fields: ctx
func (_m *MockUniversalClient) FlushDBAsync(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FlushDBAsync")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_FlushDBAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FlushDBAsync'
type MockUniversalClient_FlushDBAsync_Call struct {
	*mock.Call
}

// FlushDBAsync is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) FlushDBAsync(ctx interface{}) *MockUniversalClient_FlushDBAsync_Call {
	return &MockUniversalClient_FlushDBAsync_Call{Call: _e.mock.On("FlushDBAsync", ctx)}
}

func (_c *MockUniversalClient_FlushDBAsync_Call) Run(run func(ctx context.Context)) *MockUniversalClient_FlushDBAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_FlushDBAsync_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_FlushDBAsync_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_FlushDBAsync_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_FlushDBAsync_Call {
	_c.Call.Return(run)
	return _c
}

// GeoAdd provides a mock function with given fields: ctx, key, geoLocation
func (_m *MockUniversalClient) GeoAdd(ctx context.Context, key string, geoLocation ...*redis.GeoLocation) *redis.IntCmd {
	_va := make([]interface{}, len(geoLocation))
	for _i := range geoLocation {
		_va[_i] = geoLocation[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GeoAdd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*redis.GeoLocation) *redis.IntCmd); ok {
		r0 = rf(ctx, key, geoLocation...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_GeoAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoAdd'
type MockUniversalClient_GeoAdd_Call struct {
	*mock.Call
}

// GeoAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - geoLocation ...*redis.GeoLocation
func (_e *MockUniversalClient_Expecter) GeoAdd(ctx interface{}, key interface{}, geoLocation ...interface{}) *MockUniversalClient_GeoAdd_Call {
	return &MockUniversalClient_GeoAdd_Call{Call: _e.mock.On("GeoAdd",
		append([]interface{}{ctx, key}, geoLocation...)...)}
}

func (_c *MockUniversalClient_GeoAdd_Call) Run(run func(ctx context.Context, key string, geoLocation ...*redis.GeoLocation)) *MockUniversalClient_GeoAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*redis.GeoLocation, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*redis.GeoLocation)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_GeoAdd_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_GeoAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_GeoAdd_Call) RunAndReturn(run func(context.Context, string, ...*redis.GeoLocation) *redis.IntCmd) *MockUniversalClient_GeoAdd_Call {
	_c.Call.Return(run)
	return _c
}

// GeoDist provides a mock function with given fields: ctx, key, member1, member2, unit
func (_m *MockUniversalClient) GeoDist(ctx context.Context, key string, member1 string, member2 string, unit string) *redis.FloatCmd {
	ret := _m.Called(ctx, key, member1, member2, unit)

	if len(ret) == 0 {
		panic("no return value specified for GeoDist")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, member1, member2, unit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// MockUniversalClient_GeoDist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoDist'
type MockUniversalClient_GeoDist_Call struct {
	*mock.Call
}

// GeoDist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member1 string
//   - member2 string
//   - unit string
func (_e *MockUniversalClient_Expecter) GeoDist(ctx interface{}, key interface{}, member1 interface{}, member2 interface{}, unit interface{}) *MockUniversalClient_GeoDist_Call {
	return &MockUniversalClient_GeoDist_Call{Call: _e.mock.On("GeoDist", ctx, key, member1, member2, unit)}
}

func (_c *MockUniversalClient_GeoDist_Call) Run(run func(ctx context.Context, key string, member1 string, member2 string, unit string)) *MockUniversalClient_GeoDist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string))
	})
	return _c
}

func (_c *MockUniversalClient_GeoDist_Call) Return(_a0 *redis.FloatCmd) *MockUniversalClient_GeoDist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_GeoDist_Call) RunAndReturn(run func(context.Context, string, string, string, string) *redis.FloatCmd) *MockUniversalClient_GeoDist_Call {
	_c.Call.Return(run)
	return _c
}

// GeoHash provides a mock function with given fields: ctx, key, members
func (_m *MockUniversalClient) GeoHash(ctx context.Context, key string, members ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GeoHash")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_GeoHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoHash'
type MockUniversalClient_GeoHash_Call struct {
	*mock.Call
}

// GeoHash is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...string
func (_e *MockUniversalClient_Expecter) GeoHash(ctx interface{}, key interface{}, members ...interface{}) *MockUniversalClient_GeoHash_Call {
	return &MockUniversalClient_GeoHash_Call{Call: _e.mock.On("GeoHash",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockUniversalClient_GeoHash_Call) Run(run func(ctx context.Context, key string, members ...string)) *MockUniversalClient_GeoHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_GeoHash_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_GeoHash_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_GeoHash_Call) RunAndReturn(run func(context.Context, string, ...string) *redis.StringSliceCmd) *MockUniversalClient_GeoHash_Call {
	_c.Call.Return(run)
	return _c
}

// GeoPos provides a mock function with given fields: ctx, key, members
func (_m *MockUniversalClient) GeoPos(ctx context.Context, key string, members ...string) *redis.GeoPosCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GeoPos")
	}

	var r0 *redis.GeoPosCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.GeoPosCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoPosCmd)
		}
	}

	return r0
}

// MockUniversalClient_GeoPos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoPos'
type MockUniversalClient_GeoPos_Call struct {
	*mock.Call
}

// GeoPos is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...string
func (_e *MockUniversalClient_Expecter) GeoPos(ctx interface{}, key interface{}, members ...interface{}) *MockUniversalClient_GeoPos_Call {
	return &MockUniversalClient_GeoPos_Call{Call: _e.mock.On("GeoPos",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockUniversalClient_GeoPos_Call) Run(run func(ctx context.Context, key string, members ...string)) *MockUniversalClient_GeoPos_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_GeoPos_Call) Return(_a0 *redis.GeoPosCmd) *MockUniversalClient_GeoPos_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_GeoPos_Call) RunAndReturn(run func(context.Context, string, ...string) *redis.GeoPosCmd) *MockUniversalClient_GeoPos_Call {
	_c.Call.Return(run)
	return _c
}

// GeoRadius provides a mock function with given fields: ctx, key, longitude, latitude, query
func (_m *MockUniversalClient) GeoRadius(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	ret := _m.Called(ctx, key, longitude, latitude, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadius")
	}

	var r0 *redis.GeoLocationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, float64, *redis.GeoRadiusQuery) *redis.GeoLocationCmd); ok {
		r0 = rf(ctx, key, longitude, latitude, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoLocationCmd)
		}
	}

	return r0
}

// MockUniversalClient_GeoRadius_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoRadius'
type MockUniversalClient_GeoRadius_Call struct {
	*mock.Call
}

// GeoRadius is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - longitude float64
//   - latitude float64
//   - query *redis.GeoRadiusQuery
func (_e *MockUniversalClient_Expecter) GeoRadius(ctx interface{}, key interface{}, longitude interface{}, latitude interface{}, query interface{}) *MockUniversalClient_GeoRadius_Call {
	return &MockUniversalClient_GeoRadius_Call{Call: _e.mock.On("GeoRadius", ctx, key, longitude, latitude, query)}
}

func (_c *MockUniversalClient_GeoRadius_Call) Run(run func(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery)) *MockUniversalClient_GeoRadius_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(float64), args[4].(*redis.GeoRadiusQuery))
	})
	return _c
}

func (_c *MockUniversalClient_GeoRadius_Call) Return(_a0 *redis.GeoLocationCmd) *MockUniversalClient_GeoRadius_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_GeoRadius_Call) RunAndReturn(run func(context.Context, string, float64, float64, *redis.GeoRadiusQuery) *redis.GeoLocationCmd) *MockUniversalClient_GeoRadius_Call {
	_c.Call.Return(run)
	return _c
}

// GeoRadiusByMember provides a mock function with given fields: ctx, key, member, query
func (_m *MockUniversalClient) GeoRadiusByMember(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	ret := _m.Called(ctx, key, member, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadiusByMember")
	}

	var r0 *redis.GeoLocationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *redis.GeoRadiusQuery) *redis.GeoLocationCmd); ok {
		r0 = rf(ctx, key, member, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoLocationCmd)
		}
	}

	return r0
}

// MockUniversalClient_GeoRadiusByMember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoRadiusByMember'
type MockUniversalClient_GeoRadiusByMember_Call struct {
	*mock.Call
}

// GeoRadiusByMember is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member string
//   - query *redis.GeoRadiusQuery
func (_e *MockUniversalClient_Expecter) GeoRadiusByMember(ctx interface{}, key interface{}, member interface{}, query interface{}) *MockUniversalClient_GeoRadiusByMember_Call {
	return &MockUniversalClient_GeoRadiusByMember_Call{Call: _e.mock.On("GeoRadiusByMember", ctx, key, member, query)}
}

func (_c *MockUniversalClient_GeoRadiusByMember_Call) Run(run func(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery)) *MockUniversalClient_GeoRadiusByMember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*redis.GeoRadiusQuery))
	})
	return _c
}

func (_c *MockUniversalClient_GeoRadiusByMember_Call) Return(_a0 *redis.GeoLocationCmd) *MockUniversalClient_GeoRadiusByMember_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_GeoRadiusByMember_Call) RunAndReturn(run func(context.Context, string, string, *redis.GeoRadiusQuery) *redis.GeoLocationCmd) *MockUniversalClient_GeoRadiusByMember_Call {
	_c.Call.Return(run)
	return _c
}

// GeoRadiusByMemberStore provides a mock function with given fields: ctx, key, member, query
func (_m *MockUniversalClient) GeoRadiusByMemberStore(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery) *redis.IntCmd {
	ret := _m.Called(ctx, key, member, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadiusByMemberStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *redis.GeoRadiusQuery) *redis.IntCmd); ok {
		r0 = rf(ctx, key, member, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_GeoRadiusByMemberStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoRadiusByMemberStore'
type MockUniversalClient_GeoRadiusByMemberStore_Call struct {
	*mock.Call
}

// GeoRadiusByMemberStore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member string
//   - query *redis.GeoRadiusQuery
func (_e *MockUniversalClient_Expecter) GeoRadiusByMemberStore(ctx interface{}, key interface{}, member interface{}, query interface{}) *MockUniversalClient_GeoRadiusByMemberStore_Call {
	return &MockUniversalClient_GeoRadiusByMemberStore_Call{Call: _e.mock.On("GeoRadiusByMemberStore", ctx, key, member, query)}
}

func (_c *MockUniversalClient_GeoRadiusByMemberStore_Call) Run(run func(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery)) *MockUniversalClient_GeoRadiusByMemberStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*redis.GeoRadiusQuery))
	})
	return _c
}

func (_c *MockUniversalClient_GeoRadiusByMemberStore_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_GeoRadiusByMemberStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_GeoRadiusByMemberStore_Call) RunAndReturn(run func(context.Context, string, string, *redis.GeoRadiusQuery) *redis.IntCmd) *MockUniversalClient_GeoRadiusByMemberStore_Call {
	_c.Call.Return(run)
	return _c
}

// GeoRadiusStore provides a mock function with given fields: ctx, key, longitude, latitude, query
func (_m *MockUniversalClient) GeoRadiusStore(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.IntCmd {
	ret := _m.Called(ctx, key, longitude, latitude, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadiusStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, float64, *redis.GeoRadiusQuery) *redis.IntCmd); ok {
		r0 = rf(ctx, key, longitude, latitude, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_GeoRadiusStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoRadiusStore'
type MockUniversalClient_GeoRadiusStore_Call struct {
	*mock.Call
}

// GeoRadiusStore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - longitude float64
//   - latitude float64
//   - query *redis.GeoRadiusQuery
func (_e *MockUniversalClient_Expecter) GeoRadiusStore(ctx interface{}, key interface{}, longitude interface{}, latitude interface{}, query interface{}) *MockUniversalClient_GeoRadiusStore_Call {
	return &MockUniversalClient_GeoRadiusStore_Call{Call: _e.mock.On("GeoRadiusStore", ctx, key, longitude, latitude, query)}
}

func (_c *MockUniversalClient_GeoRadiusStore_Call) Run(run func(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery)) *MockUniversalClient_GeoRadiusStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(float64), args[4].(*redis.GeoRadiusQuery))
	})
	return _c
}

func (_c *MockUniversalClient_GeoRadiusStore_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_GeoRadiusStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_GeoRadiusStore_Call) RunAndReturn(run func(context.Context, string, float64, float64, *redis.GeoRadiusQuery) *redis.IntCmd) *MockUniversalClient_GeoRadiusStore_Call {
	_c.Call.Return(run)
	return _c
}

// GeoSearch provides a mock function with given fields: ctx, key, q
func (_m *MockUniversalClient) GeoSearch(ctx context.Context, key string, q *redis.GeoSearchQuery) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, q)

	if len(ret) == 0 {
		panic("no return value specified for GeoSearch")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.GeoSearchQuery) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_GeoSearch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoSearch'
type MockUniversalClient_GeoSearch_Call struct {
	*mock.Call
}

// GeoSearch is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - q *redis.GeoSearchQuery
func (_e *MockUniversalClient_Expecter) GeoSearch(ctx interface{}, key interface{}, q interface{}) *MockUniversalClient_GeoSearch_Call {
	return &MockUniversalClient_GeoSearch_Call{Call: _e.mock.On("GeoSearch", ctx, key, q)}
}

func (_c *MockUniversalClient_GeoSearch_Call) Run(run func(ctx context.Context, key string, q *redis.GeoSearchQuery)) *MockUniversalClient_GeoSearch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*redis.GeoSearchQuery))
	})
	return _c
}

func (_c *MockUniversalClient_GeoSearch_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_GeoSearch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_GeoSearch_Call) RunAndReturn(run func(context.Context, string, *redis.GeoSearchQuery) *redis.StringSliceCmd) *MockUniversalClient_GeoSearch_Call {
	_c.Call.Return(run)
	return _c
}

// GeoSearchLocation provides a mock function with given fields: ctx, key, q
func (_m *MockUniversalClient) GeoSearchLocation(ctx context.Context, key string, q *redis.GeoSearchLocationQuery) *redis.GeoSearchLocationCmd {
	ret := _m.Called(ctx, key, q)

	if len(ret) == 0 {
		panic("no return value specified for GeoSearchLocation")
	}

	var r0 *redis.GeoSearchLocationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.GeoSearchLocationQuery) *redis.GeoSearchLocationCmd); ok {
		r0 = rf(ctx, key, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoSearchLocationCmd)
		}
	}

	return r0
}

// MockUniversalClient_GeoSearchLocation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoSearchLocation'
type MockUniversalClient_GeoSearchLocation_Call struct {
	*mock.Call
}

// GeoSearchLocation is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - q *redis.GeoSearchLocationQuery
func (_e *MockUniversalClient_Expecter) GeoSearchLocation(ctx interface{}, key interface{}, q interface{}) *MockUniversalClient_GeoSearchLocation_Call {
	return &MockUniversalClient_GeoSearchLocation_Call{Call: _e.mock.On("GeoSearchLocation", ctx, key, q)}
}

func (_c *MockUniversalClient_GeoSearchLocation_Call) Run(run func(ctx context.Context, key string, q *redis.GeoSearchLocationQuery)) *MockUniversalClient_GeoSearchLocation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*redis.GeoSearchLocationQuery))
	})
	return _c
}

func (_c *MockUniversalClient_GeoSearchLocation_Call) Return(_a0 *redis.GeoSearchLocationCmd) *MockUniversalClient_GeoSearchLocation_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_GeoSearchLocation_Call) RunAndReturn(run func(context.Context, string, *redis.GeoSearchLocationQuery) *redis.GeoSearchLocationCmd) *MockUniversalClient_GeoSearchLocation_Call {
	_c.Call.Return(run)
	return _c
}

// GeoSearchStore provides a mock function with given fields: ctx, key, store, q
func (_m *MockUniversalClient) GeoSearchStore(ctx context.Context, key string, store string, q *redis.GeoSearchStoreQuery) *redis.IntCmd {
	ret := _m.Called(ctx, key, store, q)

	if len(ret) == 0 {
		panic("no return value specified for GeoSearchStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *redis.GeoSearchStoreQuery) *redis.IntCmd); ok {
		r0 = rf(ctx, key, store, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_GeoSearchStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoSearchStore'
type MockUniversalClient_GeoSearchStore_Call struct {
	*mock.Call
}

// GeoSearchStore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - store string
//   - q *redis.GeoSearchStoreQuery
func (_e *MockUniversalClient_Expecter) GeoSearchStore(ctx interface{}, key interface{}, store interface{}, q interface{}) *MockUniversalClient_GeoSearchStore_Call {
	return &MockUniversalClient_GeoSearchStore_Call{Call: _e.mock.On("GeoSearchStore", ctx, key, store, q)}
}

func (_c *MockUniversalClient_GeoSearchStore_Call) Run(run func(ctx context.Context, key string, store string, q *redis.GeoSearchStoreQuery)) *MockUniversalClient_GeoSearchStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*redis.GeoSearchStoreQuery))
	})
	return _c
}

func (_c *MockUniversalClient_GeoSearchStore_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_GeoSearchStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_GeoSearchStore_Call) RunAndReturn(run func(context.Context, string, string, *redis.GeoSearchStoreQuery) *redis.IntCmd) *MockUniversalClient_GeoSearchStore_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) Get(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockUniversalClient_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) Get(ctx interface{}, key interface{}) *MockUniversalClient_Get_Call {
	return &MockUniversalClient_Get_Call{Call: _e.mock.On("Get", ctx, key)}
}

func (_c *MockUniversalClient_Get_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_Get_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_Get_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Get_Call) RunAndReturn(run func(context.Context, string) *redis.StringCmd) *MockUniversalClient_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetBit provides a mock function with given fields: ctx, key, offset
func (_m *MockUniversalClient) GetBit(ctx context.Context, key string, offset int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, offset)

	if len(ret) == 0 {
		panic("no return value specified for GetBit")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_GetBit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBit'
type MockUniversalClient_GetBit_Call struct {
	*mock.Call
}

// GetBit is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - offset int64
func (_e *MockUniversalClient_Expecter) GetBit(ctx interface{}, key interface{}, offset interface{}) *MockUniversalClient_GetBit_Call {
	return &MockUniversalClient_GetBit_Call{Call: _e.mock.On("GetBit", ctx, key, offset)}
}

func (_c *MockUniversalClient_GetBit_Call) Run(run func(ctx context.Context, key string, offset int64)) *MockUniversalClient_GetBit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_GetBit_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_GetBit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_GetBit_Call) RunAndReturn(run func(context.Context, string, int64) *redis.IntCmd) *MockUniversalClient_GetBit_Call {
	_c.Call.Return(run)
	return _c
}

// GetDel provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) GetDel(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetDel")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_GetDel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDel'
type MockUniversalClient_GetDel_Call struct {
	*mock.Call
}

// GetDel is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) GetDel(ctx interface{}, key interface{}) *MockUniversalClient_GetDel_Call {
	return &MockUniversalClient_GetDel_Call{Call: _e.mock.On("GetDel", ctx, key)}
}

func (_c *MockUniversalClient_GetDel_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_GetDel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_GetDel_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_GetDel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_GetDel_Call) RunAndReturn(run func(context.Context, string) *redis.StringCmd) *MockUniversalClient_GetDel_Call {
	_c.Call.Return(run)
	return _c
}

// GetEx provides a mock function with given fields: ctx, key, expiration
func (_m *MockUniversalClient) GetEx(ctx context.Context, key string, expiration time.Duration) *redis.StringCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for GetEx")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.StringCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_GetEx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEx'
type MockUniversalClient_GetEx_Call struct {
	*mock.Call
}

// GetEx is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockUniversalClient_Expecter) GetEx(ctx interface{}, key interface{}, expiration interface{}) *MockUniversalClient_GetEx_Call {
	return &MockUniversalClient_GetEx_Call{Call: _e.mock.On("GetEx", ctx, key, expiration)}
}

func (_c *MockUniversalClient_GetEx_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockUniversalClient_GetEx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockUniversalClient_GetEx_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_GetEx_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_GetEx_Call) RunAndReturn(run func(context.Context, string, time.Duration) *redis.StringCmd) *MockUniversalClient_GetEx_Call {
	_c.Call.Return(run)
	return _c
}

// GetRange provides a mock function with given fields: ctx, key, start, end
func (_m *MockUniversalClient) GetRange(ctx context.Context, key string, start int64, end int64) *redis.StringCmd {
	ret := _m.Called(ctx, key, start, end)

	if len(ret) == 0 {
		panic("no return value specified for GetRange")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.StringCmd); ok {
		r0 = rf(ctx, key, start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_GetRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRange'
type MockUniversalClient_GetRange_Call struct {
	*mock.Call
}

// GetRange is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - start int64
//   - end int64
func (_e *MockUniversalClient_Expecter) GetRange(ctx interface{}, key interface{}, start interface{}, end interface{}) *MockUniversalClient_GetRange_Call {
	return &MockUniversalClient_GetRange_Call{Call: _e.mock.On("GetRange", ctx, key, start, end)}
}

func (_c *MockUniversalClient_GetRange_Call) Run(run func(ctx context.Context, key string, start int64, end int64)) *MockUniversalClient_GetRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_GetRange_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_GetRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_GetRange_Call) RunAndReturn(run func(context.Context, string, int64, int64) *redis.StringCmd) *MockUniversalClient_GetRange_Call {
	_c.Call.Return(run)
	return _c
}

// GetSet provides a mock function with given fields: ctx, key, value
func (_m *MockUniversalClient) GetSet(ctx context.Context, key string, value interface{}) *redis.StringCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for GetSet")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *redis.StringCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_GetSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSet'
type MockUniversalClient_GetSet_Call struct {
	*mock.Call
}

// GetSet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
func (_e *MockUniversalClient_Expecter) GetSet(ctx interface{}, key interface{}, value interface{}) *MockUniversalClient_GetSet_Call {
	return &MockUniversalClient_GetSet_Call{Call: _e.mock.On("GetSet", ctx, key, value)}
}

func (_c *MockUniversalClient_GetSet_Call) Run(run func(ctx context.Context, key string, value interface{})) *MockUniversalClient_GetSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockUniversalClient_GetSet_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_GetSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_GetSet_Call) RunAndReturn(run func(context.Context, string, interface{}) *redis.StringCmd) *MockUniversalClient_GetSet_Call {
	_c.Call.Return(run)
	return _c
}

// HDel provides a mock function with given fields: ctx, key, fields
func (_m *MockUniversalClient) HDel(ctx context.Context, key string, fields ...string) *redis.IntCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HDel")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_HDel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HDel'
type MockUniversalClient_HDel_Call struct {
	*mock.Call
}

// HDel is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fields ...string
func (_e *MockUniversalClient_Expecter) HDel(ctx interface{}, key interface{}, fields ...interface{}) *MockUniversalClient_HDel_Call {
	return &MockUniversalClient_HDel_Call{Call: _e.mock.On("HDel",
		append([]interface{}{ctx, key}, fields...)...)}
}

func (_c *MockUniversalClient_HDel_Call) Run(run func(ctx context.Context, key string, fields ...string)) *MockUniversalClient_HDel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_HDel_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_HDel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_HDel_Call) RunAndReturn(run func(context.Context, string, ...string) *redis.IntCmd) *MockUniversalClient_HDel_Call {
	_c.Call.Return(run)
	return _c
}

// HExists provides a mock function with given fields: ctx, key, field
func (_m *MockUniversalClient) HExists(ctx context.Context, key string, field string) *redis.BoolCmd {
	ret := _m.Called(ctx, key, field)

	if len(ret) == 0 {
		panic("no return value specified for HExists")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_HExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HExists'
type MockUniversalClient_HExists_Call struct {
	*mock.Call
}

// HExists is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
func (_e *MockUniversalClient_Expecter) HExists(ctx interface{}, key interface{}, field interface{}) *MockUniversalClient_HExists_Call {
	return &MockUniversalClient_HExists_Call{Call: _e.mock.On("HExists", ctx, key, field)}
}

func (_c *MockUniversalClient_HExists_Call) Run(run func(ctx context.Context, key string, field string)) *MockUniversalClient_HExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUniversalClient_HExists_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_HExists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_HExists_Call) RunAndReturn(run func(context.Context, string, string) *redis.BoolCmd) *MockUniversalClient_HExists_Call {
	_c.Call.Return(run)
	return _c
}

// HGet provides a mock function with given fields: ctx, key, field
func (_m *MockUniversalClient) HGet(ctx context.Context, key string, field string) *redis.StringCmd {
	ret := _m.Called(ctx, key, field)

	if len(ret) == 0 {
		panic("no return value specified for HGet")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_HGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HGet'
type MockUniversalClient_HGet_Call struct {
	*mock.Call
}

// HGet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
func (_e *MockUniversalClient_Expecter) HGet(ctx interface{}, key interface{}, field interface{}) *MockUniversalClient_HGet_Call {
	return &MockUniversalClient_HGet_Call{Call: _e.mock.On("HGet", ctx, key, field)}
}

func (_c *MockUniversalClient_HGet_Call) Run(run func(ctx context.Context, key string, field string)) *MockUniversalClient_HGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUniversalClient_HGet_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_HGet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_HGet_Call) RunAndReturn(run func(context.Context, string, string) *redis.StringCmd) *MockUniversalClient_HGet_Call {
	_c.Call.Return(run)
	return _c
}

// HGetAll provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) HGetAll(ctx context.Context, key string) *redis.StringStringMapCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HGetAll")
	}

	var r0 *redis.StringStringMapCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringStringMapCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringStringMapCmd)
		}
	}

	return r0
}

// MockUniversalClient_HGetAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HGetAll'
type MockUniversalClient_HGetAll_Call struct {
	*mock.Call
}

// HGetAll is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) HGetAll(ctx interface{}, key interface{}) *MockUniversalClient_HGetAll_Call {
	return &MockUniversalClient_HGetAll_Call{Call: _e.mock.On("HGetAll", ctx, key)}
}

func (_c *MockUniversalClient_HGetAll_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_HGetAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_HGetAll_Call) Return(_a0 *redis.StringStringMapCmd) *MockUniversalClient_HGetAll_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_HGetAll_Call) RunAndReturn(run func(context.Context, string) *redis.StringStringMapCmd) *MockUniversalClient_HGetAll_Call {
	_c.Call.Return(run)
	return _c
}

// HIncrBy provides a mock function with given fields: ctx, key, field, incr
func (_m *MockUniversalClient) HIncrBy(ctx context.Context, key string, field string, incr int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, field, incr)

	if len(ret) == 0 {
		panic("no return value specified for HIncrBy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, field, incr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_HIncrBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HIncrBy'
type MockUniversalClient_HIncrBy_Call struct {
	*mock.Call
}

// HIncrBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
//   - incr int64
func (_e *MockUniversalClient_Expecter) HIncrBy(ctx interface{}, key interface{}, field interface{}, incr interface{}) *MockUniversalClient_HIncrBy_Call {
	return &MockUniversalClient_HIncrBy_Call{Call: _e.mock.On("HIncrBy", ctx, key, field, incr)}
}

func (_c *MockUniversalClient_HIncrBy_Call) Run(run func(ctx context.Context, key string, field string, incr int64)) *MockUniversalClient_HIncrBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_HIncrBy_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_HIncrBy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_HIncrBy_Call) RunAndReturn(run func(context.Context, string, string, int64) *redis.IntCmd) *MockUniversalClient_HIncrBy_Call {
	_c.Call.Return(run)
	return _c
}

// HIncrByFloat provides a mock function with given fields: ctx, key, field, incr
func (_m *MockUniversalClient) HIncrByFloat(ctx context.Context, key string, field string, incr float64) *redis.FloatCmd {
	ret := _m.Called(ctx, key, field, incr)

	if len(ret) == 0 {
		panic("no return value specified for HIncrByFloat")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, float64) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, field, incr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// MockUniversalClient_HIncrByFloat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HIncrByFloat'
type MockUniversalClient_HIncrByFloat_Call struct {
	*mock.Call
}

// HIncrByFloat is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
//   - incr float64
func (_e *MockUniversalClient_Expecter) HIncrByFloat(ctx interface{}, key interface{}, field interface{}, incr interface{}) *MockUniversalClient_HIncrByFloat_Call {
	return &MockUniversalClient_HIncrByFloat_Call{Call: _e.mock.On("HIncrByFloat", ctx, key, field, incr)}
}

func (_c *MockUniversalClient_HIncrByFloat_Call) Run(run func(ctx context.Context, key string, field string, incr float64)) *MockUniversalClient_HIncrByFloat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(float64))
	})
	return _c
}

func (_c *MockUniversalClient_HIncrByFloat_Call) Return(_a0 *redis.FloatCmd) *MockUniversalClient_HIncrByFloat_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_HIncrByFloat_Call) RunAndReturn(run func(context.Context, string, string, float64) *redis.FloatCmd) *MockUniversalClient_HIncrByFloat_Call {
	_c.Call.Return(run)
	return _c
}

// HKeys provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) HKeys(ctx context.Context, key string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HKeys")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_HKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HKeys'
type MockUniversalClient_HKeys_Call struct {
	*mock.Call
}

// HKeys is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) HKeys(ctx interface{}, key interface{}) *MockUniversalClient_HKeys_Call {
	return &MockUniversalClient_HKeys_Call{Call: _e.mock.On("HKeys", ctx, key)}
}

func (_c *MockUniversalClient_HKeys_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_HKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_HKeys_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_HKeys_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_HKeys_Call) RunAndReturn(run func(context.Context, string) *redis.StringSliceCmd) *MockUniversalClient_HKeys_Call {
	_c.Call.Return(run)
	return _c
}

// HLen provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) HLen(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_HLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HLen'
type MockUniversalClient_HLen_Call struct {
	*mock.Call
}

// HLen is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) HLen(ctx interface{}, key interface{}) *MockUniversalClient_HLen_Call {
	return &MockUniversalClient_HLen_Call{Call: _e.mock.On("HLen", ctx, key)}
}

func (_c *MockUniversalClient_HLen_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_HLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_HLen_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_HLen_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_HLen_Call) RunAndReturn(run func(context.Context, string) *redis.IntCmd) *MockUniversalClient_HLen_Call {
	_c.Call.Return(run)
	return _c
}

// HMGet provides a mock function with given fields: ctx, key, fields
func (_m *MockUniversalClient) HMGet(ctx context.Context, key string, fields ...string) *redis.SliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HMGet")
	}

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.SliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_HMGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HMGet'
type MockUniversalClient_HMGet_Call struct {
	*mock.Call
}

// HMGet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fields ...string
func (_e *MockUniversalClient_Expecter) HMGet(ctx interface{}, key interface{}, fields ...interface{}) *MockUniversalClient_HMGet_Call {
	return &MockUniversalClient_HMGet_Call{Call: _e.mock.On("HMGet",
		append([]interface{}{ctx, key}, fields...)...)}
}

func (_c *MockUniversalClient_HMGet_Call) Run(run func(ctx context.Context, key string, fields ...string)) *MockUniversalClient_HMGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_HMGet_Call) Return(_a0 *redis.SliceCmd) *MockUniversalClient_HMGet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_HMGet_Call) RunAndReturn(run func(context.Context, string, ...string) *redis.SliceCmd) *MockUniversalClient_HMGet_Call {
	_c.Call.Return(run)
	return _c
}

// HMSet provides a mock function with given fields: ctx, key, values
func (_m *MockUniversalClient) HMSet(ctx context.Context, key string, values ...interface{}) *redis.BoolCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HMSet")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_HMSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HMSet'
type MockUniversalClient_HMSet_Call struct {
	*mock.Call
}

// HMSet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockUniversalClient_Expecter) HMSet(ctx interface{}, key interface{}, values ...interface{}) *MockUniversalClient_HMSet_Call {
	return &MockUniversalClient_HMSet_Call{Call: _e.mock.On("HMSet",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockUniversalClient_HMSet_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockUniversalClient_HMSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_HMSet_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_HMSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_HMSet_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *redis.BoolCmd) *MockUniversalClient_HMSet_Call {
	_c.Call.Return(run)
	return _c
}

// HRandField provides a mock function with given fields: ctx, key, count, withValues
func (_m *MockUniversalClient) HRandField(ctx context.Context, key string, count int, withValues bool) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, count, withValues)

	if len(ret) == 0 {
		panic("no return value specified for HRandField")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int, bool) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, count, withValues)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_HRandField_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HRandField'
type MockUniversalClient_HRandField_Call struct {
	*mock.Call
}

// HRandField is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int
//   - withValues bool
func (_e *MockUniversalClient_Expecter) HRandField(ctx interface{}, key interface{}, count interface{}, withValues interface{}) *MockUniversalClient_HRandField_Call {
	return &MockUniversalClient_HRandField_Call{Call: _e.mock.On("HRandField", ctx, key, count, withValues)}
}

func (_c *MockUniversalClient_HRandField_Call) Run(run func(ctx context.Context, key string, count int, withValues bool)) *MockUniversalClient_HRandField_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(bool))
	})
	return _c
}

func (_c *MockUniversalClient_HRandField_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_HRandField_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_HRandField_Call) RunAndReturn(run func(context.Context, string, int, bool) *redis.StringSliceCmd) *MockUniversalClient_HRandField_Call {
	_c.Call.Return(run)
	return _c
}

// HScan provides a mock function with given fields: ctx, key, cursor, match, count
func (_m *MockUniversalClient) HScan(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(ctx, key, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for HScan")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(ctx, key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// MockUniversalClient_HScan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HScan'
type MockUniversalClient_HScan_Call struct {
	*mock.Call
}

// HScan is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - cursor uint64
//   - match string
//   - count int64
func (_e *MockUniversalClient_Expecter) HScan(ctx interface{}, key interface{}, cursor interface{}, match interface{}, count interface{}) *MockUniversalClient_HScan_Call {
	return &MockUniversalClient_HScan_Call{Call: _e.mock.On("HScan", ctx, key, cursor, match, count)}
}

func (_c *MockUniversalClient_HScan_Call) Run(run func(ctx context.Context, key string, cursor uint64, match string, count int64)) *MockUniversalClient_HScan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint64), args[3].(string), args[4].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_HScan_Call) Return(_a0 *redis.ScanCmd) *MockUniversalClient_HScan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_HScan_Call) RunAndReturn(run func(context.Context, string, uint64, string, int64) *redis.ScanCmd) *MockUniversalClient_HScan_Call {
	_c.Call.Return(run)
	return _c
}

// HSet provides a mock function with given fields: ctx, key, values
func (_m *MockUniversalClient) HSet(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HSet")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_HSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HSet'
type MockUniversalClient_HSet_Call struct {
	*mock.Call
}

// HSet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockUniversalClient_Expecter) HSet(ctx interface{}, key interface{}, values ...interface{}) *MockUniversalClient_HSet_Call {
	return &MockUniversalClient_HSet_Call{Call: _e.mock.On("HSet",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockUniversalClient_HSet_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockUniversalClient_HSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_HSet_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_HSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_HSet_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *redis.IntCmd) *MockUniversalClient_HSet_Call {
	_c.Call.Return(run)
	return _c
}

// HSetNX provides a mock function with given fields: ctx, key, field, value
func (_m *MockUniversalClient) HSetNX(ctx context.Context, key string, field string, value interface{}) *redis.BoolCmd {
	ret := _m.Called(ctx, key, field, value)

	if len(ret) == 0 {
		panic("no return value specified for HSetNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, field, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_HSetNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HSetNX'
type MockUniversalClient_HSetNX_Call struct {
	*mock.Call
}

// HSetNX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
//   - value interface{}
func (_e *MockUniversalClient_Expecter) HSetNX(ctx interface{}, key interface{}, field interface{}, value interface{}) *MockUniversalClient_HSetNX_Call {
	return &MockUniversalClient_HSetNX_Call{Call: _e.mock.On("HSetNX", ctx, key, field, value)}
}

func (_c *MockUniversalClient_HSetNX_Call) Run(run func(ctx context.Context, key string, field string, value interface{})) *MockUniversalClient_HSetNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(interface{}))
	})
	return _c
}

func (_c *MockUniversalClient_HSetNX_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_HSetNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_HSetNX_Call) RunAndReturn(run func(context.Context, string, string, interface{}) *redis.BoolCmd) *MockUniversalClient_HSetNX_Call {
	_c.Call.Return(run)
	return _c
}

// HVals provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) HVals(ctx context.Context, key string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HVals")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_HVals_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HVals'
type MockUniversalClient_HVals_Call struct {
	*mock.Call
}

// HVals is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) HVals(ctx interface{}, key interface{}) *MockUniversalClient_HVals_Call {
	return &MockUniversalClient_HVals_Call{Call: _e.mock.On("HVals", ctx, key)}
}

func (_c *MockUniversalClient_HVals_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_HVals_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_HVals_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_HVals_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_HVals_Call) RunAndReturn(run func(context.Context, string) *redis.StringSliceCmd) *MockUniversalClient_HVals_Call {
	_c.Call.Return(run)
	return _c
}

// Incr provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) Incr(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Incr")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_Incr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Incr'
type MockUniversalClient_Incr_Call struct {
	*mock.Call
}

// Incr is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) Incr(ctx interface{}, key interface{}) *MockUniversalClient_Incr_Call {
	return &MockUniversalClient_Incr_Call{Call: _e.mock.On("Incr", ctx, key)}
}

func (_c *MockUniversalClient_Incr_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_Incr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_Incr_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_Incr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Incr_Call) RunAndReturn(run func(context.Context, string) *redis.IntCmd) *MockUniversalClient_Incr_Call {
	_c.Call.Return(run)
	return _c
}

// IncrBy provides a mock function with given fields: ctx, key, value
func (_m *MockUniversalClient) IncrBy(ctx context.Context, key string, value int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for IncrBy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_IncrBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrBy'
type MockUniversalClient_IncrBy_Call struct {
	*mock.Call
}

// IncrBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value int64
func (_e *MockUniversalClient_Expecter) IncrBy(ctx interface{}, key interface{}, value interface{}) *MockUniversalClient_IncrBy_Call {
	return &MockUniversalClient_IncrBy_Call{Call: _e.mock.On("IncrBy", ctx, key, value)}
}

func (_c *MockUniversalClient_IncrBy_Call) Run(run func(ctx context.Context, key string, value int64)) *MockUniversalClient_IncrBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_IncrBy_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_IncrBy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_IncrBy_Call) RunAndReturn(run func(context.Context, string, int64) *redis.IntCmd) *MockUniversalClient_IncrBy_Call {
	_c.Call.Return(run)
	return _c
}

// IncrByFloat provides a mock function with given fields: ctx, key, value
func (_m *MockUniversalClient) IncrByFloat(ctx context.Context, key string, value float64) *redis.FloatCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for IncrByFloat")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// MockUniversalClient_IncrByFloat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrByFloat'
type MockUniversalClient_IncrByFloat_Call struct {
	*mock.Call
}

// IncrByFloat is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value float64
func (_e *MockUniversalClient_Expecter) IncrByFloat(ctx interface{}, key interface{}, value interface{}) *MockUniversalClient_IncrByFloat_Call {
	return &MockUniversalClient_IncrByFloat_Call{Call: _e.mock.On("IncrByFloat", ctx, key, value)}
}

func (_c *MockUniversalClient_IncrByFloat_Call) Run(run func(ctx context.Context, key string, value float64)) *MockUniversalClient_IncrByFloat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64))
	})
	return _c
}

func (_c *MockUniversalClient_IncrByFloat_Call) Return(_a0 *redis.FloatCmd) *MockUniversalClient_IncrByFloat_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_IncrByFloat_Call) RunAndReturn(run func(context.Context, string, float64) *redis.FloatCmd) *MockUniversalClient_IncrByFloat_Call {
	_c.Call.Return(run)
	return _c
}

// Info provides a mock function with given fields: ctx, section
func (_m *MockUniversalClient) Info(ctx context.Context, section ...string) *redis.StringCmd {
	_va := make([]interface{}, len(section))
	for _i := range section {
		_va[_i] = section[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Info")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.StringCmd); ok {
		r0 = rf(ctx, section...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_Info_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Info'
type MockUniversalClient_Info_Call struct {
	*mock.Call
}

// Info is a helper method to define mock.On call
//   - ctx context.Context
//   - section ...string
func (_e *MockUniversalClient_Expecter) Info(ctx interface{}, section ...interface{}) *MockUniversalClient_Info_Call {
	return &MockUniversalClient_Info_Call{Call: _e.mock.On("Info",
		append([]interface{}{ctx}, section...)...)}
}

func (_c *MockUniversalClient_Info_Call) Run(run func(ctx context.Context, section ...string)) *MockUniversalClient_Info_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_Info_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_Info_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Info_Call) RunAndReturn(run func(context.Context, ...string) *redis.StringCmd) *MockUniversalClient_Info_Call {
	_c.Call.Return(run)
	return _c
}

// Keys provides a mock function with given fields: ctx, pattern
func (_m *MockUniversalClient) Keys(ctx context.Context, pattern string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, pattern)

	if len(ret) == 0 {
		panic("no return value specified for Keys")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, pattern)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_Keys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Keys'
type MockUniversalClient_Keys_Call struct {
	*mock.Call
}

// Keys is a helper method to define mock.On call
//   - ctx context.Context
//   - pattern string
func (_e *MockUniversalClient_Expecter) Keys(ctx interface{}, pattern interface{}) *MockUniversalClient_Keys_Call {
	return &MockUniversalClient_Keys_Call{Call: _e.mock.On("Keys", ctx, pattern)}
}

func (_c *MockUniversalClient_Keys_Call) Run(run func(ctx context.Context, pattern string)) *MockUniversalClient_Keys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_Keys_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_Keys_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Keys_Call) RunAndReturn(run func(context.Context, string) *redis.StringSliceCmd) *MockUniversalClient_Keys_Call {
	_c.Call.Return(run)
	return _c
}

// LIndex provides a mock function with given fields: ctx, key, index
func (_m *MockUniversalClient) LIndex(ctx context.Context, key string, index int64) *redis.StringCmd {
	ret := _m.Called(ctx, key, index)

	if len(ret) == 0 {
		panic("no return value specified for LIndex")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.StringCmd); ok {
		r0 = rf(ctx, key, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_LIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LIndex'
type MockUniversalClient_LIndex_Call struct {
	*mock.Call
}

// LIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - index int64
func (_e *MockUniversalClient_Expecter) LIndex(ctx interface{}, key interface{}, index interface{}) *MockUniversalClient_LIndex_Call {
	return &MockUniversalClient_LIndex_Call{Call: _e.mock.On("LIndex", ctx, key, index)}
}

func (_c *MockUniversalClient_LIndex_Call) Run(run func(ctx context.Context, key string, index int64)) *MockUniversalClient_LIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_LIndex_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_LIndex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_LIndex_Call) RunAndReturn(run func(context.Context, string, int64) *redis.StringCmd) *MockUniversalClient_LIndex_Call {
	_c.Call.Return(run)
	return _c
}

// LInsert provides a mock function with given fields: ctx, key, op, pivot, value
func (_m *MockUniversalClient) LInsert(ctx context.Context, key string, op string, pivot interface{}, value interface{}) *redis.IntCmd {
	ret := _m.Called(ctx, key, op, pivot, value)

	if len(ret) == 0 {
		panic("no return value specified for LInsert")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}, interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, op, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_LInsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LInsert'
type MockUniversalClient_LInsert_Call struct {
	*mock.Call
}

// LInsert is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - op string
//   - pivot interface{}
//   - value interface{}
func (_e *MockUniversalClient_Expecter) LInsert(ctx interface{}, key interface{}, op interface{}, pivot interface{}, value interface{}) *MockUniversalClient_LInsert_Call {
	return &MockUniversalClient_LInsert_Call{Call: _e.mock.On("LInsert", ctx, key, op, pivot, value)}
}

func (_c *MockUniversalClient_LInsert_Call) Run(run func(ctx context.Context, key string, op string, pivot interface{}, value interface{})) *MockUniversalClient_LInsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(interface{}), args[4].(interface{}))
	})
	return _c
}

func (_c *MockUniversalClient_LInsert_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_LInsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_LInsert_Call) RunAndReturn(run func(context.Context, string, string, interface{}, interface{}) *redis.IntCmd) *MockUniversalClient_LInsert_Call {
	_c.Call.Return(run)
	return _c
}

// LInsertAfter provides a mock function with given fields: ctx, key, pivot, value
func (_m *MockUniversalClient) LInsertAfter(ctx context.Context, key string, pivot interface{}, value interface{}) *redis.IntCmd {
	ret := _m.Called(ctx, key, pivot, value)

	if len(ret) == 0 {
		panic("no return value specified for LInsertAfter")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_LInsertAfter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LInsertAfter'
type MockUniversalClient_LInsertAfter_Call struct {
	*mock.Call
}

// LInsertAfter is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - pivot interface{}
//   - value interface{}
func (_e *MockUniversalClient_Expecter) LInsertAfter(ctx interface{}, key interface{}, pivot interface{}, value interface{}) *MockUniversalClient_LInsertAfter_Call {
	return &MockUniversalClient_LInsertAfter_Call{Call: _e.mock.On("LInsertAfter", ctx, key, pivot, value)}
}

func (_c *MockUniversalClient_LInsertAfter_Call) Run(run func(ctx context.Context, key string, pivot interface{}, value interface{})) *MockUniversalClient_LInsertAfter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(interface{}))
	})
	return _c
}

func (_c *MockUniversalClient_LInsertAfter_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_LInsertAfter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_LInsertAfter_Call) RunAndReturn(run func(context.Context, string, interface{}, interface{}) *redis.IntCmd) *MockUniversalClient_LInsertAfter_Call {
	_c.Call.Return(run)
	return _c
}

// LInsertBefore provides a mock function with given fields: ctx, key, pivot, value
func (_m *MockUniversalClient) LInsertBefore(ctx context.Context, key string, pivot interface{}, value interface{}) *redis.IntCmd {
	ret := _m.Called(ctx, key, pivot, value)

	if len(ret) == 0 {
		panic("no return value specified for LInsertBefore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_LInsertBefore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LInsertBefore'
type MockUniversalClient_LInsertBefore_Call struct {
	*mock.Call
}

// LInsertBefore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - pivot interface{}
//   - value interface{}
func (_e *MockUniversalClient_Expecter) LInsertBefore(ctx interface{}, key interface{}, pivot interface{}, value interface{}) *MockUniversalClient_LInsertBefore_Call {
	return &MockUniversalClient_LInsertBefore_Call{Call: _e.mock.On("LInsertBefore", ctx, key, pivot, value)}
}

func (_c *MockUniversalClient_LInsertBefore_Call) Run(run func(ctx context.Context, key string, pivot interface{}, value interface{})) *MockUniversalClient_LInsertBefore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(interface{}))
	})
	return _c
}

func (_c *MockUniversalClient_LInsertBefore_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_LInsertBefore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_LInsertBefore_Call) RunAndReturn(run func(context.Context, string, interface{}, interface{}) *redis.IntCmd) *MockUniversalClient_LInsertBefore_Call {
	_c.Call.Return(run)
	return _c
}

// LLen provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) LLen(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for LLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_LLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LLen'
type MockUniversalClient_LLen_Call struct {
	*mock.Call
}

// LLen is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) LLen(ctx interface{}, key interface{}) *MockUniversalClient_LLen_Call {
	return &MockUniversalClient_LLen_Call{Call: _e.mock.On("LLen", ctx, key)}
}

func (_c *MockUniversalClient_LLen_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_LLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_LLen_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_LLen_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_LLen_Call) RunAndReturn(run func(context.Context, string) *redis.IntCmd) *MockUniversalClient_LLen_Call {
	_c.Call.Return(run)
	return _c
}

// LMove provides a mock function with given fields: ctx, source, destination, srcpos, destpos
func (_m *MockUniversalClient) LMove(ctx context.Context, source string, destination string, srcpos string, destpos string) *redis.StringCmd {
	ret := _m.Called(ctx, source, destination, srcpos, destpos)

	if len(ret) == 0 {
		panic("no return value specified for LMove")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *redis.StringCmd); ok {
		r0 = rf(ctx, source, destination, srcpos, destpos)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_LMove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LMove'
type MockUniversalClient_LMove_Call struct {
	*mock.Call
}

// LMove is a helper method to define mock.On call
//   - ctx context.Context
//   - source string
//   - destination string
//   - srcpos string
//   - destpos string
func (_e *MockUniversalClient_Expecter) LMove(ctx interface{}, source interface{}, destination interface{}, srcpos interface{}, destpos interface{}) *MockUniversalClient_LMove_Call {
	return &MockUniversalClient_LMove_Call{Call: _e.mock.On("LMove", ctx, source, destination, srcpos, destpos)}
}

func (_c *MockUniversalClient_LMove_Call) Run(run func(ctx context.Context, source string, destination string, srcpos string, destpos string)) *MockUniversalClient_LMove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string))
	})
	return _c
}

func (_c *MockUniversalClient_LMove_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_LMove_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_LMove_Call) RunAndReturn(run func(context.Context, string, string, string, string) *redis.StringCmd) *MockUniversalClient_LMove_Call {
	_c.Call.Return(run)
	return _c
}

// LPop provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) LPop(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for LPop")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_LPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LPop'
type MockUniversalClient_LPop_Call struct {
	*mock.Call
}

// LPop is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) LPop(ctx interface{}, key interface{}) *MockUniversalClient_LPop_Call {
	return &MockUniversalClient_LPop_Call{Call: _e.mock.On("LPop", ctx, key)}
}

func (_c *MockUniversalClient_LPop_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_LPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_LPop_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_LPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_LPop_Call) RunAndReturn(run func(context.Context, string) *redis.StringCmd) *MockUniversalClient_LPop_Call {
	_c.Call.Return(run)
	return _c
}

// LPopCount provides a mock function with given fields: ctx, key, count
func (_m *MockUniversalClient) LPopCount(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for LPopCount")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_LPopCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LPopCount'
type MockUniversalClient_LPopCount_Call struct {
	*mock.Call
}

// LPopCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int
func (_e *MockUniversalClient_Expecter) LPopCount(ctx interface{}, key interface{}, count interface{}) *MockUniversalClient_LPopCount_Call {
	return &MockUniversalClient_LPopCount_Call{Call: _e.mock.On("LPopCount", ctx, key, count)}
}

func (_c *MockUniversalClient_LPopCount_Call) Run(run func(ctx context.Context, key string, count int)) *MockUniversalClient_LPopCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockUniversalClient_LPopCount_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_LPopCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_LPopCount_Call) RunAndReturn(run func(context.Context, string, int) *redis.StringSliceCmd) *MockUniversalClient_LPopCount_Call {
	_c.Call.Return(run)
	return _c
}

// LPos provides a mock function with given fields: ctx, key, value, args
func (_m *MockUniversalClient) LPos(ctx context.Context, key string, value string, args redis.LPosArgs) *redis.IntCmd {
	ret := _m.Called(ctx, key, value, args)

	if len(ret) == 0 {
		panic("no return value specified for LPos")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, redis.LPosArgs) *redis.IntCmd); ok {
		r0 = rf(ctx, key, value, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_LPos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LPos'
type MockUniversalClient_LPos_Call struct {
	*mock.Call
}

// LPos is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value string
//   - args redis.LPosArgs
func (_e *MockUniversalClient_Expecter) LPos(ctx interface{}, key interface{}, value interface{}, args interface{}) *MockUniversalClient_LPos_Call {
	return &MockUniversalClient_LPos_Call{Call: _e.mock.On("LPos", ctx, key, value, args)}
}

func (_c *MockUniversalClient_LPos_Call) Run(run func(ctx context.Context, key string, value string, args redis.LPosArgs)) *MockUniversalClient_LPos_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(redis.LPosArgs))
	})
	return _c
}

func (_c *MockUniversalClient_LPos_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_LPos_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_LPos_Call) RunAndReturn(run func(context.Context, string, string, redis.LPosArgs) *redis.IntCmd) *MockUniversalClient_LPos_Call {
	_c.Call.Return(run)
	return _c
}

// LPosCount provides a mock function with given fields: ctx, key, value, count, args
func (_m *MockUniversalClient) LPosCount(ctx context.Context, key string, value string, count int64, args redis.LPosArgs) *redis.IntSliceCmd {
	ret := _m.Called(ctx, key, value, count, args)

	if len(ret) == 0 {
		panic("no return value specified for LPosCount")
	}

	var r0 *redis.IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64, redis.LPosArgs) *redis.IntSliceCmd); ok {
		r0 = rf(ctx, key, value, count, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_LPosCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LPosCount'
type MockUniversalClient_LPosCount_Call struct {
	*mock.Call
}

// LPosCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value string
//   - count int64
//   - args redis.LPosArgs
func (_e *MockUniversalClient_Expecter) LPosCount(ctx interface{}, key interface{}, value interface{}, count interface{}, args interface{}) *MockUniversalClient_LPosCount_Call {
	return &MockUniversalClient_LPosCount_Call{Call: _e.mock.On("LPosCount", ctx, key, value, count, args)}
}

func (_c *MockUniversalClient_LPosCount_Call) Run(run func(ctx context.Context, key string, value string, count int64, args redis.LPosArgs)) *MockUniversalClient_LPosCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int64), args[4].(redis.LPosArgs))
	})
	return _c
}

func (_c *MockUniversalClient_LPosCount_Call) Return(_a0 *redis.IntSliceCmd) *MockUniversalClient_LPosCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_LPosCount_Call) RunAndReturn(run func(context.Context, string, string, int64, redis.LPosArgs) *redis.IntSliceCmd) *MockUniversalClient_LPosCount_Call {
	_c.Call.Return(run)
	return _c
}

// LPush provides a mock function with given fields: ctx, key, values
func (_m *MockUniversalClient) LPush(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LPush")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_LPush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LPush'
type MockUniversalClient_LPush_Call struct {
	*mock.Call
}

// LPush is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockUniversalClient_Expecter) LPush(ctx interface{}, key interface{}, values ...interface{}) *MockUniversalClient_LPush_Call {
	return &MockUniversalClient_LPush_Call{Call: _e.mock.On("LPush",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockUniversalClient_LPush_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockUniversalClient_LPush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_LPush_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_LPush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_LPush_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *redis.IntCmd) *MockUniversalClient_LPush_Call {
	_c.Call.Return(run)
	return _c
}

// LPushX provides a mock function with given fields: ctx, key, values
func (_m *MockUniversalClient) LPushX(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LPushX")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_LPushX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LPushX'
type MockUniversalClient_LPushX_Call struct {
	*mock.Call
}

// LPushX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockUniversalClient_Expecter) LPushX(ctx interface{}, key interface{}, values ...interface{}) *MockUniversalClient_LPushX_Call {
	return &MockUniversalClient_LPushX_Call{Call: _e.mock.On("LPushX",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockUniversalClient_LPushX_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockUniversalClient_LPushX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_LPushX_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_LPushX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_LPushX_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *redis.IntCmd) *MockUniversalClient_LPushX_Call {
	_c.Call.Return(run)
	return _c
}

// LRange provides a mock function with given fields: ctx, key, start, stop
func (_m *MockUniversalClient) LRange(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for LRange")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_LRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LRange'
type MockUniversalClient_LRange_Call struct {
	*mock.Call
}

// LRange is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - start int64
//   - stop int64
func (_e *MockUniversalClient_Expecter) LRange(ctx interface{}, key interface{}, start interface{}, stop interface{}) *MockUniversalClient_LRange_Call {
	return &MockUniversalClient_LRange_Call{Call: _e.mock.On("LRange", ctx, key, start, stop)}
}

func (_c *MockUniversalClient_LRange_Call) Run(run func(ctx context.Context, key string, start int64, stop int64)) *MockUniversalClient_LRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_LRange_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_LRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_LRange_Call) RunAndReturn(run func(context.Context, string, int64, int64) *redis.StringSliceCmd) *MockUniversalClient_LRange_Call {
	_c.Call.Return(run)
	return _c
}

// LRem provides a mock function with given fields: ctx, key, count, value
func (_m *MockUniversalClient) LRem(ctx context.Context, key string, count int64, value interface{}) *redis.IntCmd {
	ret := _m.Called(ctx, key, count, value)

	if len(ret) == 0 {
		panic("no return value specified for LRem")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, count, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_LRem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LRem'
type MockUniversalClient_LRem_Call struct {
	*mock.Call
}

// LRem is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int64
//   - value interface{}
func (_e *MockUniversalClient_Expecter) LRem(ctx interface{}, key interface{}, count interface{}, value interface{}) *MockUniversalClient_LRem_Call {
	return &MockUniversalClient_LRem_Call{Call: _e.mock.On("LRem", ctx, key, count, value)}
}

func (_c *MockUniversalClient_LRem_Call) Run(run func(ctx context.Context, key string, count int64, value interface{})) *MockUniversalClient_LRem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(interface{}))
	})
	return _c
}

func (_c *MockUniversalClient_LRem_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_LRem_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_LRem_Call) RunAndReturn(run func(context.Context, string, int64, interface{}) *redis.IntCmd) *MockUniversalClient_LRem_Call {
	_c.Call.Return(run)
	return _c
}

// LSet provides a mock function with given fields: ctx, key, index, value
func (_m *MockUniversalClient) LSet(ctx context.Context, key string, index int64, value interface{}) *redis.StatusCmd {
	ret := _m.Called(ctx, key, index, value)

	if len(ret) == 0 {
		panic("no return value specified for LSet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, interface{}) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, index, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_LSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LSet'
type MockUniversalClient_LSet_Call struct {
	*mock.Call
}

// LSet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - index int64
//   - value interface{}
func (_e *MockUniversalClient_Expecter) LSet(ctx interface{}, key interface{}, index interface{}, value interface{}) *MockUniversalClient_LSet_Call {
	return &MockUniversalClient_LSet_Call{Call: _e.mock.On("LSet", ctx, key, index, value)}
}

func (_c *MockUniversalClient_LSet_Call) Run(run func(ctx context.Context, key string, index int64, value interface{})) *MockUniversalClient_LSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(interface{}))
	})
	return _c
}

func (_c *MockUniversalClient_LSet_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_LSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_LSet_Call) RunAndReturn(run func(context.Context, string, int64, interface{}) *redis.StatusCmd) *MockUniversalClient_LSet_Call {
	_c.Call.Return(run)
	return _c
}

// LTrim provides a mock function with given fields: ctx, key, start, stop
func (_m *MockUniversalClient) LTrim(ctx context.Context, key string, start int64, stop int64) *redis.StatusCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for LTrim")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_LTrim_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LTrim'
type MockUniversalClient_LTrim_Call struct {
	*mock.Call
}

// LTrim is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - start int64
//   - stop int64
func (_e *MockUniversalClient_Expecter) LTrim(ctx interface{}, key interface{}, start interface{}, stop interface{}) *MockUniversalClient_LTrim_Call {
	return &MockUniversalClient_LTrim_Call{Call: _e.mock.On("LTrim", ctx, key, start, stop)}
}

func (_c *MockUniversalClient_LTrim_Call) Run(run func(ctx context.Context, key string, start int64, stop int64)) *MockUniversalClient_LTrim_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_LTrim_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_LTrim_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_LTrim_Call) RunAndReturn(run func(context.Context, string, int64, int64) *redis.StatusCmd) *MockUniversalClient_LTrim_Call {
	_c.Call.Return(run)
	return _c
}

// LastSave provides a mock function with given fields: ctx
func (_m *MockUniversalClient) LastSave(ctx context.Context) *redis.IntCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for LastSave")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.IntCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_LastSave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LastSave'
type MockUniversalClient_LastSave_Call struct {
	*mock.Call
}

// LastSave is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) LastSave(ctx interface{}) *MockUniversalClient_LastSave_Call {
	return &MockUniversalClient_LastSave_Call{Call: _e.mock.On("LastSave", ctx)}
}

func (_c *MockUniversalClient_LastSave_Call) Run(run func(ctx context.Context)) *MockUniversalClient_LastSave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_LastSave_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_LastSave_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_LastSave_Call) RunAndReturn(run func(context.Context) *redis.IntCmd) *MockUniversalClient_LastSave_Call {
	_c.Call.Return(run)
	return _c
}

// MGet provides a mock function with given fields: ctx, keys
func (_m *MockUniversalClient) MGet(ctx context.Context, keys ...string) *redis.SliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MGet")
	}

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.SliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_MGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MGet'
type MockUniversalClient_MGet_Call struct {
	*mock.Call
}

// MGet is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockUniversalClient_Expecter) MGet(ctx interface{}, keys ...interface{}) *MockUniversalClient_MGet_Call {
	return &MockUniversalClient_MGet_Call{Call: _e.mock.On("MGet",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockUniversalClient_MGet_Call) Run(run func(ctx context.Context, keys ...string)) *MockUniversalClient_MGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_MGet_Call) Return(_a0 *redis.SliceCmd) *MockUniversalClient_MGet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_MGet_Call) RunAndReturn(run func(context.Context, ...string) *redis.SliceCmd) *MockUniversalClient_MGet_Call {
	_c.Call.Return(run)
	return _c
}

// MSet provides a mock function with given fields: ctx, values
func (_m *MockUniversalClient) MSet(ctx context.Context, values ...interface{}) *redis.StatusCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MSet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...interface{}) *redis.StatusCmd); ok {
		r0 = rf(ctx, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_MSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MSet'
type MockUniversalClient_MSet_Call struct {
	*mock.Call
}

// MSet is a helper method to define mock.On call
//   - ctx context.Context
//   - values ...interface{}
func (_e *MockUniversalClient_Expecter) MSet(ctx interface{}, values ...interface{}) *MockUniversalClient_MSet_Call {
	return &MockUniversalClient_MSet_Call{Call: _e.mock.On("MSet",
		append([]interface{}{ctx}, values...)...)}
}

func (_c *MockUniversalClient_MSet_Call) Run(run func(ctx context.Context, values ...interface{})) *MockUniversalClient_MSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_MSet_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_MSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_MSet_Call) RunAndReturn(run func(context.Context, ...interface{}) *redis.StatusCmd) *MockUniversalClient_MSet_Call {
	_c.Call.Return(run)
	return _c
}

// MSetNX provides a mock function with given fields: ctx, values
func (_m *MockUniversalClient) MSetNX(ctx context.Context, values ...interface{}) *redis.BoolCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MSetNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_MSetNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MSetNX'
type MockUniversalClient_MSetNX_Call struct {
	*mock.Call
}

// MSetNX is a helper method to define mock.On call
//   - ctx context.Context
//   - values ...interface{}
func (_e *MockUniversalClient_Expecter) MSetNX(ctx interface{}, values ...interface{}) *MockUniversalClient_MSetNX_Call {
	return &MockUniversalClient_MSetNX_Call{Call: _e.mock.On("MSetNX",
		append([]interface{}{ctx}, values...)...)}
}

func (_c *MockUniversalClient_MSetNX_Call) Run(run func(ctx context.Context, values ...interface{})) *MockUniversalClient_MSetNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_MSetNX_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_MSetNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_MSetNX_Call) RunAndReturn(run func(context.Context, ...interface{}) *redis.BoolCmd) *MockUniversalClient_MSetNX_Call {
	_c.Call.Return(run)
	return _c
}

// MemoryUsage provides a mock function with given fields: ctx, key, samples
func (_m *MockUniversalClient) MemoryUsage(ctx context.Context, key string, samples ...int) *redis.IntCmd {
	_va := make([]interface{}, len(samples))
	for _i := range samples {
		_va[_i] = samples[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MemoryUsage")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...int) *redis.IntCmd); ok {
		r0 = rf(ctx, key, samples...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_MemoryUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MemoryUsage'
type MockUniversalClient_MemoryUsage_Call struct {
	*mock.Call
}

// MemoryUsage is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - samples ...int
func (_e *MockUniversalClient_Expecter) MemoryUsage(ctx interface{}, key interface{}, samples ...interface{}) *MockUniversalClient_MemoryUsage_Call {
	return &MockUniversalClient_MemoryUsage_Call{Call: _e.mock.On("MemoryUsage",
		append([]interface{}{ctx, key}, samples...)...)}
}

func (_c *MockUniversalClient_MemoryUsage_Call) Run(run func(ctx context.Context, key string, samples ...int)) *MockUniversalClient_MemoryUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_MemoryUsage_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_MemoryUsage_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_MemoryUsage_Call) RunAndReturn(run func(context.Context, string, ...int) *redis.IntCmd) *MockUniversalClient_MemoryUsage_Call {
	_c.Call.Return(run)
	return _c
}

// Migrate provides a mock function with given fields: ctx, host, port, key, db, timeout
func (_m *MockUniversalClient) Migrate(ctx context.Context, host string, port string, key string, db int, timeout time.Duration) *redis.StatusCmd {
	ret := _m.Called(ctx, host, port, key, db, timeout)

	if len(ret) == 0 {
		panic("no return value specified for Migrate")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int, time.Duration) *redis.StatusCmd); ok {
		r0 = rf(ctx, host, port, key, db, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_Migrate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Migrate'
type MockUniversalClient_Migrate_Call struct {
	*mock.Call
}

// Migrate is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port string
//   - key string
//   - db int
//   - timeout time.Duration
func (_e *MockUniversalClient_Expecter) Migrate(ctx interface{}, host interface{}, port interface{}, key interface{}, db interface{}, timeout interface{}) *MockUniversalClient_Migrate_Call {
	return &MockUniversalClient_Migrate_Call{Call: _e.mock.On("Migrate", ctx, host, port, key, db, timeout)}
}

func (_c *MockUniversalClient_Migrate_Call) Run(run func(ctx context.Context, host string, port string, key string, db int, timeout time.Duration)) *MockUniversalClient_Migrate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int), args[5].(time.Duration))
	})
	return _c
}

func (_c *MockUniversalClient_Migrate_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_Migrate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Migrate_Call) RunAndReturn(run func(context.Context, string, string, string, int, time.Duration) *redis.StatusCmd) *MockUniversalClient_Migrate_Call {
	_c.Call.Return(run)
	return _c
}

// Move provides a mock function with given fields: ctx, key, db
func (_m *MockUniversalClient) Move(ctx context.Context, key string, db int) *redis.BoolCmd {
	ret := _m.Called(ctx, key, db)

	if len(ret) == 0 {
		panic("no return value specified for Move")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, db)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_Move_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Move'
type MockUniversalClient_Move_Call struct {
	*mock.Call
}

// Move is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - db int
func (_e *MockUniversalClient_Expecter) Move(ctx interface{}, key interface{}, db interface{}) *MockUniversalClient_Move_Call {
	return &MockUniversalClient_Move_Call{Call: _e.mock.On("Move", ctx, key, db)}
}

func (_c *MockUniversalClient_Move_Call) Run(run func(ctx context.Context, key string, db int)) *MockUniversalClient_Move_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockUniversalClient_Move_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_Move_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Move_Call) RunAndReturn(run func(context.Context, string, int) *redis.BoolCmd) *MockUniversalClient_Move_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectEncoding provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) ObjectEncoding(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectEncoding")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_ObjectEncoding_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectEncoding'
type MockUniversalClient_ObjectEncoding_Call struct {
	*mock.Call
}

// ObjectEncoding is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) ObjectEncoding(ctx interface{}, key interface{}) *MockUniversalClient_ObjectEncoding_Call {
	return &MockUniversalClient_ObjectEncoding_Call{Call: _e.mock.On("ObjectEncoding", ctx, key)}
}

func (_c *MockUniversalClient_ObjectEncoding_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_ObjectEncoding_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ObjectEncoding_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_ObjectEncoding_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ObjectEncoding_Call) RunAndReturn(run func(context.Context, string) *redis.StringCmd) *MockUniversalClient_ObjectEncoding_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectIdleTime provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) ObjectIdleTime(ctx context.Context, key string) *redis.DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectIdleTime")
	}

	var r0 *redis.DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.DurationCmd)
		}
	}

	return r0
}

// MockUniversalClient_ObjectIdleTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectIdleTime'
type MockUniversalClient_ObjectIdleTime_Call struct {
	*mock.Call
}

// ObjectIdleTime is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) ObjectIdleTime(ctx interface{}, key interface{}) *MockUniversalClient_ObjectIdleTime_Call {
	return &MockUniversalClient_ObjectIdleTime_Call{Call: _e.mock.On("ObjectIdleTime", ctx, key)}
}

func (_c *MockUniversalClient_ObjectIdleTime_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_ObjectIdleTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ObjectIdleTime_Call) Return(_a0 *redis.DurationCmd) *MockUniversalClient_ObjectIdleTime_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ObjectIdleTime_Call) RunAndReturn(run func(context.Context, string) *redis.DurationCmd) *MockUniversalClient_ObjectIdleTime_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectRefCount provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) ObjectRefCount(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectRefCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ObjectRefCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectRefCount'
type MockUniversalClient_ObjectRefCount_Call struct {
	*mock.Call
}

// ObjectRefCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) ObjectRefCount(ctx interface{}, key interface{}) *MockUniversalClient_ObjectRefCount_Call {
	return &MockUniversalClient_ObjectRefCount_Call{Call: _e.mock.On("ObjectRefCount", ctx, key)}
}

func (_c *MockUniversalClient_ObjectRefCount_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_ObjectRefCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ObjectRefCount_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ObjectRefCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ObjectRefCount_Call) RunAndReturn(run func(context.Context, string) *redis.IntCmd) *MockUniversalClient_ObjectRefCount_Call {
	_c.Call.Return(run)
	return _c
}

// PExpire provides a mock function with given fields: ctx, key, expiration
func (_m *MockUniversalClient) PExpire(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for PExpire")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_PExpire_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PExpire'
type MockUniversalClient_PExpire_Call struct {
	*mock.Call
}

// PExpire is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockUniversalClient_Expecter) PExpire(ctx interface{}, key interface{}, expiration interface{}) *MockUniversalClient_PExpire_Call {
	return &MockUniversalClient_PExpire_Call{Call: _e.mock.On("PExpire", ctx, key, expiration)}
}

func (_c *MockUniversalClient_PExpire_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockUniversalClient_PExpire_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockUniversalClient_PExpire_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_PExpire_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_PExpire_Call) RunAndReturn(run func(context.Context, string, time.Duration) *redis.BoolCmd) *MockUniversalClient_PExpire_Call {
	_c.Call.Return(run)
	return _c
}

// PExpireAt provides a mock function with given fields: ctx, key, tm
func (_m *MockUniversalClient) PExpireAt(ctx context.Context, key string, tm time.Time) *redis.BoolCmd {
	ret := _m.Called(ctx, key, tm)

	if len(ret) == 0 {
		panic("no return value specified for PExpireAt")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, tm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_PExpireAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PExpireAt'
type MockUniversalClient_PExpireAt_Call struct {
	*mock.Call
}

// PExpireAt is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - tm time.Time
func (_e *MockUniversalClient_Expecter) PExpireAt(ctx interface{}, key interface{}, tm interface{}) *MockUniversalClient_PExpireAt_Call {
	return &MockUniversalClient_PExpireAt_Call{Call: _e.mock.On("PExpireAt", ctx, key, tm)}
}

func (_c *MockUniversalClient_PExpireAt_Call) Run(run func(ctx context.Context, key string, tm time.Time)) *MockUniversalClient_PExpireAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Time))
	})
	return _c
}

func (_c *MockUniversalClient_PExpireAt_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_PExpireAt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_PExpireAt_Call) RunAndReturn(run func(context.Context, string, time.Time) *redis.BoolCmd) *MockUniversalClient_PExpireAt_Call {
	_c.Call.Return(run)
	return _c
}

// PFAdd provides a mock function with given fields: ctx, key, els
func (_m *MockUniversalClient) PFAdd(ctx context.Context, key string, els ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, els...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PFAdd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, els...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_PFAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PFAdd'
type MockUniversalClient_PFAdd_Call struct {
	*mock.Call
}

// PFAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - els ...interface{}
func (_e *MockUniversalClient_Expecter) PFAdd(ctx interface{}, key interface{}, els ...interface{}) *MockUniversalClient_PFAdd_Call {
	return &MockUniversalClient_PFAdd_Call{Call: _e.mock.On("PFAdd",
		append([]interface{}{ctx, key}, els...)...)}
}

func (_c *MockUniversalClient_PFAdd_Call) Run(run func(ctx context.Context, key string, els ...interface{})) *MockUniversalClient_PFAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_PFAdd_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_PFAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_PFAdd_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *redis.IntCmd) *MockUniversalClient_PFAdd_Call {
	_c.Call.Return(run)
	return _c
}

// PFCount provides a mock function with given fields: ctx, keys
func (_m *MockUniversalClient) PFCount(ctx context.Context, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PFCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_PFCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PFCount'
type MockUniversalClient_PFCount_Call struct {
	*mock.Call
}

// PFCount is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockUniversalClient_Expecter) PFCount(ctx interface{}, keys ...interface{}) *MockUniversalClient_PFCount_Call {
	return &MockUniversalClient_PFCount_Call{Call: _e.mock.On("PFCount",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockUniversalClient_PFCount_Call) Run(run func(ctx context.Context, keys ...string)) *MockUniversalClient_PFCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_PFCount_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_PFCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_PFCount_Call) RunAndReturn(run func(context.Context, ...string) *redis.IntCmd) *MockUniversalClient_PFCount_Call {
	_c.Call.Return(run)
	return _c
}

// PFMerge provides a mock function with given fields: ctx, dest, keys
func (_m *MockUniversalClient) PFMerge(ctx context.Context, dest string, keys ...string) *redis.StatusCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, dest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PFMerge")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.StatusCmd); ok {
		r0 = rf(ctx, dest, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_PFMerge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PFMerge'
type MockUniversalClient_PFMerge_Call struct {
	*mock.Call
}

// PFMerge is a helper method to define mock.On call
//   - ctx context.Context
//   - dest string
//   - keys ...string
func (_e *MockUniversalClient_Expecter) PFMerge(ctx interface{}, dest interface{}, keys ...interface{}) *MockUniversalClient_PFMerge_Call {
	return &MockUniversalClient_PFMerge_Call{Call: _e.mock.On("PFMerge",
		append([]interface{}{ctx, dest}, keys...)...)}
}

func (_c *MockUniversalClient_PFMerge_Call) Run(run func(ctx context.Context, dest string, keys ...string)) *MockUniversalClient_PFMerge_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_PFMerge_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_PFMerge_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_PFMerge_Call) RunAndReturn(run func(context.Context, string, ...string) *redis.StatusCmd) *MockUniversalClient_PFMerge_Call {
	_c.Call.Return(run)
	return _c
}

// PSubscribe provides a mock function with given fields: ctx, channels
func (_m *MockUniversalClient) PSubscribe(ctx context.Context, channels ...string) *redis.PubSub {
	_va := make([]interface{}, len(channels))
	for _i := range channels {
		_va[_i] = channels[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PSubscribe")
	}

	var r0 *redis.PubSub
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.PubSub); ok {
		r0 = rf(ctx, channels...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.PubSub)
		}
	}

	return r0
}

// MockUniversalClient_PSubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PSubscribe'
type MockUniversalClient_PSubscribe_Call struct {
	*mock.Call
}

// PSubscribe is a helper method to define mock.On call
//   - ctx context.Context
//   - channels ...string
func (_e *MockUniversalClient_Expecter) PSubscribe(ctx interface{}, channels ...interface{}) *MockUniversalClient_PSubscribe_Call {
	return &MockUniversalClient_PSubscribe_Call{Call: _e.mock.On("PSubscribe",
		append([]interface{}{ctx}, channels...)...)}
}

func (_c *MockUniversalClient_PSubscribe_Call) Run(run func(ctx context.Context, channels ...string)) *MockUniversalClient_PSubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_PSubscribe_Call) Return(_a0 *redis.PubSub) *MockUniversalClient_PSubscribe_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_PSubscribe_Call) RunAndReturn(run func(context.Context, ...string) *redis.PubSub) *MockUniversalClient_PSubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// PTTL provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) PTTL(ctx context.Context, key string) *redis.DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for PTTL")
	}

	var r0 *redis.DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.DurationCmd)
		}
	}

	return r0
}

// MockUniversalClient_PTTL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PTTL'
type MockUniversalClient_PTTL_Call struct {
	*mock.Call
}

// PTTL is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) PTTL(ctx interface{}, key interface{}) *MockUniversalClient_PTTL_Call {
	return &MockUniversalClient_PTTL_Call{Call: _e.mock.On("PTTL", ctx, key)}
}

func (_c *MockUniversalClient_PTTL_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_PTTL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_PTTL_Call) Return(_a0 *redis.DurationCmd) *MockUniversalClient_PTTL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_PTTL_Call) RunAndReturn(run func(context.Context, string) *redis.DurationCmd) *MockUniversalClient_PTTL_Call {
	_c.Call.Return(run)
	return _c
}

// Persist provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) Persist(ctx context.Context, key string) *redis.BoolCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Persist")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.BoolCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_Persist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Persist'
type MockUniversalClient_Persist_Call struct {
	*mock.Call
}

// Persist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) Persist(ctx interface{}, key interface{}) *MockUniversalClient_Persist_Call {
	return &MockUniversalClient_Persist_Call{Call: _e.mock.On("Persist", ctx, key)}
}

func (_c *MockUniversalClient_Persist_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_Persist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_Persist_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_Persist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Persist_Call) RunAndReturn(run func(context.Context, string) *redis.BoolCmd) *MockUniversalClient_Persist_Call {
	_c.Call.Return(run)
	return _c
}

// Ping provides a mock function with given fields: ctx
func (_m *MockUniversalClient) Ping(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Ping")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_Ping_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ping'
type MockUniversalClient_Ping_Call struct {
	*mock.Call
}

// Ping is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) Ping(ctx interface{}) *MockUniversalClient_Ping_Call {
	return &MockUniversalClient_Ping_Call{Call: _e.mock.On("Ping", ctx)}
}

func (_c *MockUniversalClient_Ping_Call) Run(run func(ctx context.Context)) *MockUniversalClient_Ping_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_Ping_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_Ping_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Ping_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_Ping_Call {
	_c.Call.Return(run)
	return _c
}

// Pipeline provides a mock function with given fields:
func (_m *MockUniversalClient) Pipeline() redis.Pipeliner {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Pipeline")
	}

	var r0 redis.Pipeliner
	if rf, ok := ret.Get(0).(func() redis.Pipeliner); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(redis.Pipeliner)
		}
	}

	return r0
}

// MockUniversalClient_Pipeline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pipeline'
type MockUniversalClient_Pipeline_Call struct {
	*mock.Call
}

// Pipeline is a helper method to define mock.On call
func (_e *MockUniversalClient_Expecter) Pipeline() *MockUniversalClient_Pipeline_Call {
	return &MockUniversalClient_Pipeline_Call{Call: _e.mock.On("Pipeline")}
}

func (_c *MockUniversalClient_Pipeline_Call) Run(run func()) *MockUniversalClient_Pipeline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockUniversalClient_Pipeline_Call) Return(_a0 redis.Pipeliner) *MockUniversalClient_Pipeline_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Pipeline_Call) RunAndReturn(run func() redis.Pipeliner) *MockUniversalClient_Pipeline_Call {
	_c.Call.Return(run)
	return _c
}

// Pipelined provides a mock function with given fields: ctx, fn
func (_m *MockUniversalClient) Pipelined(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
	ret := _m.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for Pipelined")
	}

	var r0 []redis.Cmder
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, func(redis.Pipeliner) error) ([]redis.Cmder, error)); ok {
		return rf(ctx, fn)
	}
	if rf, ok := ret.Get(0).(func(context.Context, func(redis.Pipeliner) error) []redis.Cmder); ok {
		r0 = rf(ctx, fn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.Cmder)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, func(redis.Pipeliner) error) error); ok {
		r1 = rf(ctx, fn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockUniversalClient_Pipelined_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pipelined'
type MockUniversalClient_Pipelined_Call struct {
	*mock.Call
}

// Pipelined is a helper method to define mock.On call
//   - ctx context.Context
//   - fn func(redis.Pipeliner) error
func (_e *MockUniversalClient_Expecter) Pipelined(ctx interface{}, fn interface{}) *MockUniversalClient_Pipelined_Call {
	return &MockUniversalClient_Pipelined_Call{Call: _e.mock.On("Pipelined", ctx, fn)}
}

func (_c *MockUniversalClient_Pipelined_Call) Run(run func(ctx context.Context, fn func(redis.Pipeliner) error)) *MockUniversalClient_Pipelined_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(func(redis.Pipeliner) error))
	})
	return _c
}

func (_c *MockUniversalClient_Pipelined_Call) Return(_a0 []redis.Cmder, _a1 error) *MockUniversalClient_Pipelined_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUniversalClient_Pipelined_Call) RunAndReturn(run func(context.Context, func(redis.Pipeliner) error) ([]redis.Cmder, error)) *MockUniversalClient_Pipelined_Call {
	_c.Call.Return(run)
	return _c
}

// PoolStats provides a mock function with given fields:
func (_m *MockUniversalClient) PoolStats() *redis.PoolStats {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for PoolStats")
	}

	var r0 *redis.PoolStats
	if rf, ok := ret.Get(0).(func() *redis.PoolStats); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.PoolStats)
		}
	}

	return r0
}

// MockUniversalClient_PoolStats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PoolStats'
type MockUniversalClient_PoolStats_Call struct {
	*mock.Call
}

// PoolStats is a helper method to define mock.On call
func (_e *MockUniversalClient_Expecter) PoolStats() *MockUniversalClient_PoolStats_Call {
	return &MockUniversalClient_PoolStats_Call{Call: _e.mock.On("PoolStats")}
}

func (_c *MockUniversalClient_PoolStats_Call) Run(run func()) *MockUniversalClient_PoolStats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockUniversalClient_PoolStats_Call) Return(_a0 *redis.PoolStats) *MockUniversalClient_PoolStats_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_PoolStats_Call) RunAndReturn(run func() *redis.PoolStats) *MockUniversalClient_PoolStats_Call {
	_c.Call.Return(run)
	return _c
}

// Process provides a mock function with given fields: ctx, cmd
func (_m *MockUniversalClient) Process(ctx context.Context, cmd redis.Cmder) error {
	ret := _m.Called(ctx, cmd)

	if len(ret) == 0 {
		panic("no return value specified for Process")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, redis.Cmder) error); ok {
		r0 = rf(ctx, cmd)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockUniversalClient_Process_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Process'
type MockUniversalClient_Process_Call struct {
	*mock.Call
}

// Process is a helper method to define mock.On call
//   - ctx context.Context
//   - cmd redis.Cmder
func (_e *MockUniversalClient_Expecter) Process(ctx interface{}, cmd interface{}) *MockUniversalClient_Process_Call {
	return &MockUniversalClient_Process_Call{Call: _e.mock.On("Process", ctx, cmd)}
}

func (_c *MockUniversalClient_Process_Call) Run(run func(ctx context.Context, cmd redis.Cmder)) *MockUniversalClient_Process_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(redis.Cmder))
	})
	return _c
}

func (_c *MockUniversalClient_Process_Call) Return(_a0 error) *MockUniversalClient_Process_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Process_Call) RunAndReturn(run func(context.Context, redis.Cmder) error) *MockUniversalClient_Process_Call {
	_c.Call.Return(run)
	return _c
}

// PubSubChannels provides a mock function with given fields: ctx, pattern
func (_m *MockUniversalClient) PubSubChannels(ctx context.Context, pattern string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, pattern)

	if len(ret) == 0 {
		panic("no return value specified for PubSubChannels")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, pattern)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_PubSubChannels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PubSubChannels'
type MockUniversalClient_PubSubChannels_Call struct {
	*mock.Call
}

// PubSubChannels is a helper method to define mock.On call
//   - ctx context.Context
//   - pattern string
func (_e *MockUniversalClient_Expecter) PubSubChannels(ctx interface{}, pattern interface{}) *MockUniversalClient_PubSubChannels_Call {
	return &MockUniversalClient_PubSubChannels_Call{Call: _e.mock.On("PubSubChannels", ctx, pattern)}
}

func (_c *MockUniversalClient_PubSubChannels_Call) Run(run func(ctx context.Context, pattern string)) *MockUniversalClient_PubSubChannels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_PubSubChannels_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_PubSubChannels_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_PubSubChannels_Call) RunAndReturn(run func(context.Context, string) *redis.StringSliceCmd) *MockUniversalClient_PubSubChannels_Call {
	_c.Call.Return(run)
	return _c
}

// PubSubNumPat provides a mock function with given fields: ctx
func (_m *MockUniversalClient) PubSubNumPat(ctx context.Context) *redis.IntCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for PubSubNumPat")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.IntCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_PubSubNumPat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PubSubNumPat'
type MockUniversalClient_PubSubNumPat_Call struct {
	*mock.Call
}

// PubSubNumPat is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) PubSubNumPat(ctx interface{}) *MockUniversalClient_PubSubNumPat_Call {
	return &MockUniversalClient_PubSubNumPat_Call{Call: _e.mock.On("PubSubNumPat", ctx)}
}

func (_c *MockUniversalClient_PubSubNumPat_Call) Run(run func(ctx context.Context)) *MockUniversalClient_PubSubNumPat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_PubSubNumPat_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_PubSubNumPat_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_PubSubNumPat_Call) RunAndReturn(run func(context.Context) *redis.IntCmd) *MockUniversalClient_PubSubNumPat_Call {
	_c.Call.Return(run)
	return _c
}

// PubSubNumSub provides a mock function with given fields: ctx, channels
func (_m *MockUniversalClient) PubSubNumSub(ctx context.Context, channels ...string) *redis.StringIntMapCmd {
	_va := make([]interface{}, len(channels))
	for _i := range channels {
		_va[_i] = channels[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PubSubNumSub")
	}

	var r0 *redis.StringIntMapCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.StringIntMapCmd); ok {
		r0 = rf(ctx, channels...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringIntMapCmd)
		}
	}

	return r0
}

// MockUniversalClient_PubSubNumSub_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PubSubNumSub'
type MockUniversalClient_PubSubNumSub_Call struct {
	*mock.Call
}

// PubSubNumSub is a helper method to define mock.On call
//   - ctx context.Context
//   - channels ...string
func (_e *MockUniversalClient_Expecter) PubSubNumSub(ctx interface{}, channels ...interface{}) *MockUniversalClient_PubSubNumSub_Call {
	return &MockUniversalClient_PubSubNumSub_Call{Call: _e.mock.On("PubSubNumSub",
		append([]interface{}{ctx}, channels...)...)}
}

func (_c *MockUniversalClient_PubSubNumSub_Call) Run(run func(ctx context.Context, channels ...string)) *MockUniversalClient_PubSubNumSub_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_PubSubNumSub_Call) Return(_a0 *redis.StringIntMapCmd) *MockUniversalClient_PubSubNumSub_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_PubSubNumSub_Call) RunAndReturn(run func(context.Context, ...string) *redis.StringIntMapCmd) *MockUniversalClient_PubSubNumSub_Call {
	_c.Call.Return(run)
	return _c
}

// Publish provides a mock function with given fields: ctx, channel, message
func (_m *MockUniversalClient) Publish(ctx context.Context, channel string, message interface{}) *redis.IntCmd {
	ret := _m.Called(ctx, channel, message)

	if len(ret) == 0 {
		panic("no return value specified for Publish")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, channel, message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type MockUniversalClient_Publish_Call struct {
	*mock.Call
}

// Publish is a helper method to define mock.On call
//   - ctx context.Context
//   - channel string
//   - message interface{}
func (_e *MockUniversalClient_Expecter) Publish(ctx interface{}, channel interface{}, message interface{}) *MockUniversalClient_Publish_Call {
	return &MockUniversalClient_Publish_Call{Call: _e.mock.On("Publish", ctx, channel, message)}
}

func (_c *MockUniversalClient_Publish_Call) Run(run func(ctx context.Context, channel string, message interface{})) *MockUniversalClient_Publish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockUniversalClient_Publish_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_Publish_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Publish_Call) RunAndReturn(run func(context.Context, string, interface{}) *redis.IntCmd) *MockUniversalClient_Publish_Call {
	_c.Call.Return(run)
	return _c
}

// Quit provides a mock function with given fields: ctx
func (_m *MockUniversalClient) Quit(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Quit")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_Quit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Quit'
type MockUniversalClient_Quit_Call struct {
	*mock.Call
}

// Quit is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) Quit(ctx interface{}) *MockUniversalClient_Quit_Call {
	return &MockUniversalClient_Quit_Call{Call: _e.mock.On("Quit", ctx)}
}

func (_c *MockUniversalClient_Quit_Call) Run(run func(ctx context.Context)) *MockUniversalClient_Quit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_Quit_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_Quit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Quit_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_Quit_Call {
	_c.Call.Return(run)
	return _c
}

// RPop provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) RPop(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for RPop")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_RPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RPop'
type MockUniversalClient_RPop_Call struct {
	*mock.Call
}

// RPop is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) RPop(ctx interface{}, key interface{}) *MockUniversalClient_RPop_Call {
	return &MockUniversalClient_RPop_Call{Call: _e.mock.On("RPop", ctx, key)}
}

func (_c *MockUniversalClient_RPop_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_RPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_RPop_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_RPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_RPop_Call) RunAndReturn(run func(context.Context, string) *redis.StringCmd) *MockUniversalClient_RPop_Call {
	_c.Call.Return(run)
	return _c
}

// RPopCount provides a mock function with given fields: ctx, key, count
func (_m *MockUniversalClient) RPopCount(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for RPopCount")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_RPopCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RPopCount'
type MockUniversalClient_RPopCount_Call struct {
	*mock.Call
}

// RPopCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int
func (_e *MockUniversalClient_Expecter) RPopCount(ctx interface{}, key interface{}, count interface{}) *MockUniversalClient_RPopCount_Call {
	return &MockUniversalClient_RPopCount_Call{Call: _e.mock.On("RPopCount", ctx, key, count)}
}

func (_c *MockUniversalClient_RPopCount_Call) Run(run func(ctx context.Context, key string, count int)) *MockUniversalClient_RPopCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockUniversalClient_RPopCount_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_RPopCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_RPopCount_Call) RunAndReturn(run func(context.Context, string, int) *redis.StringSliceCmd) *MockUniversalClient_RPopCount_Call {
	_c.Call.Return(run)
	return _c
}

// RPopLPush provides a mock function with given fields: ctx, source, destination
func (_m *MockUniversalClient) RPopLPush(ctx context.Context, source string, destination string) *redis.StringCmd {
	ret := _m.Called(ctx, source, destination)

	if len(ret) == 0 {
		panic("no return value specified for RPopLPush")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StringCmd); ok {
		r0 = rf(ctx, source, destination)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_RPopLPush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RPopLPush'
type MockUniversalClient_RPopLPush_Call struct {
	*mock.Call
}

// RPopLPush is a helper method to define mock.On call
//   - ctx context.Context
//   - source string
//   - destination string
func (_e *MockUniversalClient_Expecter) RPopLPush(ctx interface{}, source interface{}, destination interface{}) *MockUniversalClient_RPopLPush_Call {
	return &MockUniversalClient_RPopLPush_Call{Call: _e.mock.On("RPopLPush", ctx, source, destination)}
}

func (_c *MockUniversalClient_RPopLPush_Call) Run(run func(ctx context.Context, source string, destination string)) *MockUniversalClient_RPopLPush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUniversalClient_RPopLPush_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_RPopLPush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_RPopLPush_Call) RunAndReturn(run func(context.Context, string, string) *redis.StringCmd) *MockUniversalClient_RPopLPush_Call {
	_c.Call.Return(run)
	return _c
}

// RPush provides a mock function with given fields: ctx, key, values
func (_m *MockUniversalClient) RPush(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RPush")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_RPush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RPush'
type MockUniversalClient_RPush_Call struct {
	*mock.Call
}

// RPush is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockUniversalClient_Expecter) RPush(ctx interface{}, key interface{}, values ...interface{}) *MockUniversalClient_RPush_Call {
	return &MockUniversalClient_RPush_Call{Call: _e.mock.On("RPush",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockUniversalClient_RPush_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockUniversalClient_RPush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_RPush_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_RPush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_RPush_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *redis.IntCmd) *MockUniversalClient_RPush_Call {
	_c.Call.Return(run)
	return _c
}

// RPushX provides a mock function with given fields: ctx, key, values
func (_m *MockUniversalClient) RPushX(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RPushX")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_RPushX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RPushX'
type MockUniversalClient_RPushX_Call struct {
	*mock.Call
}

// RPushX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockUniversalClient_Expecter) RPushX(ctx interface{}, key interface{}, values ...interface{}) *MockUniversalClient_RPushX_Call {
	return &MockUniversalClient_RPushX_Call{Call: _e.mock.On("RPushX",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockUniversalClient_RPushX_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockUniversalClient_RPushX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_RPushX_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_RPushX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_RPushX_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *redis.IntCmd) *MockUniversalClient_RPushX_Call {
	_c.Call.Return(run)
	return _c
}

// RandomKey provides a mock function with given fields: ctx
func (_m *MockUniversalClient) RandomKey(ctx context.Context) *redis.StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for RandomKey")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_RandomKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RandomKey'
type MockUniversalClient_RandomKey_Call struct {
	*mock.Call
}

// RandomKey is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) RandomKey(ctx interface{}) *MockUniversalClient_RandomKey_Call {
	return &MockUniversalClient_RandomKey_Call{Call: _e.mock.On("RandomKey", ctx)}
}

func (_c *MockUniversalClient_RandomKey_Call) Run(run func(ctx context.Context)) *MockUniversalClient_RandomKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_RandomKey_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_RandomKey_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_RandomKey_Call) RunAndReturn(run func(context.Context) *redis.StringCmd) *MockUniversalClient_RandomKey_Call {
	_c.Call.Return(run)
	return _c
}

// ReadOnly provides a mock function with given fields: ctx
func (_m *MockUniversalClient) ReadOnly(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ReadOnly")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ReadOnly_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadOnly'
type MockUniversalClient_ReadOnly_Call struct {
	*mock.Call
}

// ReadOnly is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) ReadOnly(ctx interface{}) *MockUniversalClient_ReadOnly_Call {
	return &MockUniversalClient_ReadOnly_Call{Call: _e.mock.On("ReadOnly", ctx)}
}

func (_c *MockUniversalClient_ReadOnly_Call) Run(run func(ctx context.Context)) *MockUniversalClient_ReadOnly_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_ReadOnly_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ReadOnly_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ReadOnly_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_ReadOnly_Call {
	_c.Call.Return(run)
	return _c
}

// ReadWrite provides a mock function with given fields: ctx
func (_m *MockUniversalClient) ReadWrite(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ReadWrite")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ReadWrite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadWrite'
type MockUniversalClient_ReadWrite_Call struct {
	*mock.Call
}

// ReadWrite is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) ReadWrite(ctx interface{}) *MockUniversalClient_ReadWrite_Call {
	return &MockUniversalClient_ReadWrite_Call{Call: _e.mock.On("ReadWrite", ctx)}
}

func (_c *MockUniversalClient_ReadWrite_Call) Run(run func(ctx context.Context)) *MockUniversalClient_ReadWrite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_ReadWrite_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ReadWrite_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ReadWrite_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_ReadWrite_Call {
	_c.Call.Return(run)
	return _c
}

// Rename provides a mock function with given fields: ctx, key, newkey
func (_m *MockUniversalClient) Rename(ctx context.Context, key string, newkey string) *redis.StatusCmd {
	ret := _m.Called(ctx, key, newkey)

	if len(ret) == 0 {
		panic("no return value specified for Rename")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, newkey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_Rename_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rename'
type MockUniversalClient_Rename_Call struct {
	*mock.Call
}

// Rename is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - newkey string
func (_e *MockUniversalClient_Expecter) Rename(ctx interface{}, key interface{}, newkey interface{}) *MockUniversalClient_Rename_Call {
	return &MockUniversalClient_Rename_Call{Call: _e.mock.On("Rename", ctx, key, newkey)}
}

func (_c *MockUniversalClient_Rename_Call) Run(run func(ctx context.Context, key string, newkey string)) *MockUniversalClient_Rename_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUniversalClient_Rename_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_Rename_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Rename_Call) RunAndReturn(run func(context.Context, string, string) *redis.StatusCmd) *MockUniversalClient_Rename_Call {
	_c.Call.Return(run)
	return _c
}

// RenameNX provides a mock function with given fields: ctx, key, newkey
func (_m *MockUniversalClient) RenameNX(ctx context.Context, key string, newkey string) *redis.BoolCmd {
	ret := _m.Called(ctx, key, newkey)

	if len(ret) == 0 {
		panic("no return value specified for RenameNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, newkey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_RenameNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RenameNX'
type MockUniversalClient_RenameNX_Call struct {
	*mock.Call
}

// RenameNX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - newkey string
func (_e *MockUniversalClient_Expecter) RenameNX(ctx interface{}, key interface{}, newkey interface{}) *MockUniversalClient_RenameNX_Call {
	return &MockUniversalClient_RenameNX_Call{Call: _e.mock.On("RenameNX", ctx, key, newkey)}
}

func (_c *MockUniversalClient_RenameNX_Call) Run(run func(ctx context.Context, key string, newkey string)) *MockUniversalClient_RenameNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUniversalClient_RenameNX_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_RenameNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_RenameNX_Call) RunAndReturn(run func(context.Context, string, string) *redis.BoolCmd) *MockUniversalClient_RenameNX_Call {
	_c.Call.Return(run)
	return _c
}

// Restore provides a mock function with given fields: ctx, key, ttl, value
func (_m *MockUniversalClient) Restore(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd {
	ret := _m.Called(ctx, key, ttl, value)

	if len(ret) == 0 {
		panic("no return value specified for Restore")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, ttl, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_Restore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Restore'
type MockUniversalClient_Restore_Call struct {
	*mock.Call
}

// Restore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - ttl time.Duration
//   - value string
func (_e *MockUniversalClient_Expecter) Restore(ctx interface{}, key interface{}, ttl interface{}, value interface{}) *MockUniversalClient_Restore_Call {
	return &MockUniversalClient_Restore_Call{Call: _e.mock.On("Restore", ctx, key, ttl, value)}
}

func (_c *MockUniversalClient_Restore_Call) Run(run func(ctx context.Context, key string, ttl time.Duration, value string)) *MockUniversalClient_Restore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration), args[3].(string))
	})
	return _c
}

func (_c *MockUniversalClient_Restore_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_Restore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Restore_Call) RunAndReturn(run func(context.Context, string, time.Duration, string) *redis.StatusCmd) *MockUniversalClient_Restore_Call {
	_c.Call.Return(run)
	return _c
}

// RestoreReplace provides a mock function with given fields: ctx, key, ttl, value
func (_m *MockUniversalClient) RestoreReplace(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd {
	ret := _m.Called(ctx, key, ttl, value)

	if len(ret) == 0 {
		panic("no return value specified for RestoreReplace")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, ttl, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_RestoreReplace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestoreReplace'
type MockUniversalClient_RestoreReplace_Call struct {
	*mock.Call
}

// RestoreReplace is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - ttl time.Duration
//   - value string
func (_e *MockUniversalClient_Expecter) RestoreReplace(ctx interface{}, key interface{}, ttl interface{}, value interface{}) *MockUniversalClient_RestoreReplace_Call {
	return &MockUniversalClient_RestoreReplace_Call{Call: _e.mock.On("RestoreReplace", ctx, key, ttl, value)}
}

func (_c *MockUniversalClient_RestoreReplace_Call) Run(run func(ctx context.Context, key string, ttl time.Duration, value string)) *MockUniversalClient_RestoreReplace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration), args[3].(string))
	})
	return _c
}

func (_c *MockUniversalClient_RestoreReplace_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_RestoreReplace_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_RestoreReplace_Call) RunAndReturn(run func(context.Context, string, time.Duration, string) *redis.StatusCmd) *MockUniversalClient_RestoreReplace_Call {
	_c.Call.Return(run)
	return _c
}

// SAdd provides a mock function with given fields: ctx, key, members
func (_m *MockUniversalClient) SAdd(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SAdd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_SAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SAdd'
type MockUniversalClient_SAdd_Call struct {
	*mock.Call
}

// SAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...interface{}
func (_e *MockUniversalClient_Expecter) SAdd(ctx interface{}, key interface{}, members ...interface{}) *MockUniversalClient_SAdd_Call {
	return &MockUniversalClient_SAdd_Call{Call: _e.mock.On("SAdd",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockUniversalClient_SAdd_Call) Run(run func(ctx context.Context, key string, members ...interface{})) *MockUniversalClient_SAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_SAdd_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_SAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SAdd_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *redis.IntCmd) *MockUniversalClient_SAdd_Call {
	_c.Call.Return(run)
	return _c
}

// SCard provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) SCard(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SCard")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_SCard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SCard'
type MockUniversalClient_SCard_Call struct {
	*mock.Call
}

// SCard is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) SCard(ctx interface{}, key interface{}) *MockUniversalClient_SCard_Call {
	return &MockUniversalClient_SCard_Call{Call: _e.mock.On("SCard", ctx, key)}
}

func (_c *MockUniversalClient_SCard_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_SCard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_SCard_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_SCard_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SCard_Call) RunAndReturn(run func(context.Context, string) *redis.IntCmd) *MockUniversalClient_SCard_Call {
	_c.Call.Return(run)
	return _c
}

// SDiff provides a mock function with given fields: ctx, keys
func (_m *MockUniversalClient) SDiff(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SDiff")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_SDiff_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SDiff'
type MockUniversalClient_SDiff_Call struct {
	*mock.Call
}

// SDiff is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockUniversalClient_Expecter) SDiff(ctx interface{}, keys ...interface{}) *MockUniversalClient_SDiff_Call {
	return &MockUniversalClient_SDiff_Call{Call: _e.mock.On("SDiff",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockUniversalClient_SDiff_Call) Run(run func(ctx context.Context, keys ...string)) *MockUniversalClient_SDiff_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_SDiff_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_SDiff_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SDiff_Call) RunAndReturn(run func(context.Context, ...string) *redis.StringSliceCmd) *MockUniversalClient_SDiff_Call {
	_c.Call.Return(run)
	return _c
}

// SDiffStore provides a mock function with given fields: ctx, destination, keys
func (_m *MockUniversalClient) SDiffStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SDiffStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_SDiffStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SDiffStore'
type MockUniversalClient_SDiffStore_Call struct {
	*mock.Call
}

// SDiffStore is a helper method to define mock.On call
//   - ctx context.Context
//   - destination string
//   - keys ...string
func (_e *MockUniversalClient_Expecter) SDiffStore(ctx interface{}, destination interface{}, keys ...interface{}) *MockUniversalClient_SDiffStore_Call {
	return &MockUniversalClient_SDiffStore_Call{Call: _e.mock.On("SDiffStore",
		append([]interface{}{ctx, destination}, keys...)...)}
}

func (_c *MockUniversalClient_SDiffStore_Call) Run(run func(ctx context.Context, destination string, keys ...string)) *MockUniversalClient_SDiffStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_SDiffStore_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_SDiffStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SDiffStore_Call) RunAndReturn(run func(context.Context, string, ...string) *redis.IntCmd) *MockUniversalClient_SDiffStore_Call {
	_c.Call.Return(run)
	return _c
}

// SInter provides a mock function with given fields: ctx, keys
func (_m *MockUniversalClient) SInter(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SInter")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_SInter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SInter'
type MockUniversalClient_SInter_Call struct {
	*mock.Call
}

// SInter is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockUniversalClient_Expecter) SInter(ctx interface{}, keys ...interface{}) *MockUniversalClient_SInter_Call {
	return &MockUniversalClient_SInter_Call{Call: _e.mock.On("SInter",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockUniversalClient_SInter_Call) Run(run func(ctx context.Context, keys ...string)) *MockUniversalClient_SInter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_SInter_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_SInter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SInter_Call) RunAndReturn(run func(context.Context, ...string) *redis.StringSliceCmd) *MockUniversalClient_SInter_Call {
	_c.Call.Return(run)
	return _c
}

// SInterStore provides a mock function with given fields: ctx, destination, keys
func (_m *MockUniversalClient) SInterStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SInterStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_SInterStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SInterStore'
type MockUniversalClient_SInterStore_Call struct {
	*mock.Call
}

// SInterStore is a helper method to define mock.On call
//   - ctx context.Context
//   - destination string
//   - keys ...string
func (_e *MockUniversalClient_Expecter) SInterStore(ctx interface{}, destination interface{}, keys ...interface{}) *MockUniversalClient_SInterStore_Call {
	return &MockUniversalClient_SInterStore_Call{Call: _e.mock.On("SInterStore",
		append([]interface{}{ctx, destination}, keys...)...)}
}

func (_c *MockUniversalClient_SInterStore_Call) Run(run func(ctx context.Context, destination string, keys ...string)) *MockUniversalClient_SInterStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_SInterStore_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_SInterStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SInterStore_Call) RunAndReturn(run func(context.Context, string, ...string) *redis.IntCmd) *MockUniversalClient_SInterStore_Call {
	_c.Call.Return(run)
	return _c
}

// SIsMember provides a mock function with given fields: ctx, key, member
func (_m *MockUniversalClient) SIsMember(ctx context.Context, key string, member interface{}) *redis.BoolCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for SIsMember")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_SIsMember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SIsMember'
type MockUniversalClient_SIsMember_Call struct {
	*mock.Call
}

// SIsMember is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member interface{}
func (_e *MockUniversalClient_Expecter) SIsMember(ctx interface{}, key interface{}, member interface{}) *MockUniversalClient_SIsMember_Call {
	return &MockUniversalClient_SIsMember_Call{Call: _e.mock.On("SIsMember", ctx, key, member)}
}

func (_c *MockUniversalClient_SIsMember_Call) Run(run func(ctx context.Context, key string, member interface{})) *MockUniversalClient_SIsMember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockUniversalClient_SIsMember_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_SIsMember_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SIsMember_Call) RunAndReturn(run func(context.Context, string, interface{}) *redis.BoolCmd) *MockUniversalClient_SIsMember_Call {
	_c.Call.Return(run)
	return _c
}

// SMIsMember provides a mock function with given fields: ctx, key, members
func (_m *MockUniversalClient) SMIsMember(ctx context.Context, key string, members ...interface{}) *redis.BoolSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SMIsMember")
	}

	var r0 *redis.BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.BoolSliceCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_SMIsMember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SMIsMember'
type MockUniversalClient_SMIsMember_Call struct {
	*mock.Call
}

// SMIsMember is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...interface{}
func (_e *MockUniversalClient_Expecter) SMIsMember(ctx interface{}, key interface{}, members ...interface{}) *MockUniversalClient_SMIsMember_Call {
	return &MockUniversalClient_SMIsMember_Call{Call: _e.mock.On("SMIsMember",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockUniversalClient_SMIsMember_Call) Run(run func(ctx context.Context, key string, members ...interface{})) *MockUniversalClient_SMIsMember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_SMIsMember_Call) Return(_a0 *redis.BoolSliceCmd) *MockUniversalClient_SMIsMember_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SMIsMember_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *redis.BoolSliceCmd) *MockUniversalClient_SMIsMember_Call {
	_c.Call.Return(run)
	return _c
}

// SMembers provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) SMembers(ctx context.Context, key string) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SMembers")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_SMembers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SMembers'
type MockUniversalClient_SMembers_Call struct {
	*mock.Call
}

// SMembers is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) SMembers(ctx interface{}, key interface{}) *MockUniversalClient_SMembers_Call {
	return &MockUniversalClient_SMembers_Call{Call: _e.mock.On("SMembers", ctx, key)}
}

func (_c *MockUniversalClient_SMembers_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_SMembers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_SMembers_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_SMembers_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SMembers_Call) RunAndReturn(run func(context.Context, string) *redis.StringSliceCmd) *MockUniversalClient_SMembers_Call {
	_c.Call.Return(run)
	return _c
}

// SMembersMap provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) SMembersMap(ctx context.Context, key string) *redis.StringStructMapCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SMembersMap")
	}

	var r0 *redis.StringStructMapCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringStructMapCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringStructMapCmd)
		}
	}

	return r0
}

// MockUniversalClient_SMembersMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SMembersMap'
type MockUniversalClient_SMembersMap_Call struct {
	*mock.Call
}

// SMembersMap is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) SMembersMap(ctx interface{}, key interface{}) *MockUniversalClient_SMembersMap_Call {
	return &MockUniversalClient_SMembersMap_Call{Call: _e.mock.On("SMembersMap", ctx, key)}
}

func (_c *MockUniversalClient_SMembersMap_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_SMembersMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_SMembersMap_Call) Return(_a0 *redis.StringStructMapCmd) *MockUniversalClient_SMembersMap_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SMembersMap_Call) RunAndReturn(run func(context.Context, string) *redis.StringStructMapCmd) *MockUniversalClient_SMembersMap_Call {
	_c.Call.Return(run)
	return _c
}

// SMove provides a mock function with given fields: ctx, source, destination, member
func (_m *MockUniversalClient) SMove(ctx context.Context, source string, destination string, member interface{}) *redis.BoolCmd {
	ret := _m.Called(ctx, source, destination, member)

	if len(ret) == 0 {
		panic("no return value specified for SMove")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(ctx, source, destination, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_SMove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SMove'
type MockUniversalClient_SMove_Call struct {
	*mock.Call
}

// SMove is a helper method to define mock.On call
//   - ctx context.Context
//   - source string
//   - destination string
//   - member interface{}
func (_e *MockUniversalClient_Expecter) SMove(ctx interface{}, source interface{}, destination interface{}, member interface{}) *MockUniversalClient_SMove_Call {
	return &MockUniversalClient_SMove_Call{Call: _e.mock.On("SMove", ctx, source, destination, member)}
}

func (_c *MockUniversalClient_SMove_Call) Run(run func(ctx context.Context, source string, destination string, member interface{})) *MockUniversalClient_SMove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(interface{}))
	})
	return _c
}

func (_c *MockUniversalClient_SMove_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_SMove_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SMove_Call) RunAndReturn(run func(context.Context, string, string, interface{}) *redis.BoolCmd) *MockUniversalClient_SMove_Call {
	_c.Call.Return(run)
	return _c
}

// SPop provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) SPop(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SPop")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_SPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SPop'
type MockUniversalClient_SPop_Call struct {
	*mock.Call
}

// SPop is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) SPop(ctx interface{}, key interface{}) *MockUniversalClient_SPop_Call {
	return &MockUniversalClient_SPop_Call{Call: _e.mock.On("SPop", ctx, key)}
}

func (_c *MockUniversalClient_SPop_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_SPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_SPop_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_SPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SPop_Call) RunAndReturn(run func(context.Context, string) *redis.StringCmd) *MockUniversalClient_SPop_Call {
	_c.Call.Return(run)
	return _c
}

// SPopN provides a mock function with given fields: ctx, key, count
func (_m *MockUniversalClient) SPopN(ctx context.Context, key string, count int64) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for SPopN")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_SPopN_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SPopN'
type MockUniversalClient_SPopN_Call struct {
	*mock.Call
}

// SPopN is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int64
func (_e *MockUniversalClient_Expecter) SPopN(ctx interface{}, key interface{}, count interface{}) *MockUniversalClient_SPopN_Call {
	return &MockUniversalClient_SPopN_Call{Call: _e.mock.On("SPopN", ctx, key, count)}
}

func (_c *MockUniversalClient_SPopN_Call) Run(run func(ctx context.Context, key string, count int64)) *MockUniversalClient_SPopN_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_SPopN_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_SPopN_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SPopN_Call) RunAndReturn(run func(context.Context, string, int64) *redis.StringSliceCmd) *MockUniversalClient_SPopN_Call {
	_c.Call.Return(run)
	return _c
}

// SRandMember provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) SRandMember(ctx context.Context, key string) *redis.StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SRandMember")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_SRandMember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SRandMember'
type MockUniversalClient_SRandMember_Call struct {
	*mock.Call
}

// SRandMember is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) SRandMember(ctx interface{}, key interface{}) *MockUniversalClient_SRandMember_Call {
	return &MockUniversalClient_SRandMember_Call{Call: _e.mock.On("SRandMember", ctx, key)}
}

func (_c *MockUniversalClient_SRandMember_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_SRandMember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_SRandMember_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_SRandMember_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SRandMember_Call) RunAndReturn(run func(context.Context, string) *redis.StringCmd) *MockUniversalClient_SRandMember_Call {
	_c.Call.Return(run)
	return _c
}

// SRandMemberN provides a mock function with given fields: ctx, key, count
func (_m *MockUniversalClient) SRandMemberN(ctx context.Context, key string, count int64) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for SRandMemberN")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_SRandMemberN_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SRandMemberN'
type MockUniversalClient_SRandMemberN_Call struct {
	*mock.Call
}

// SRandMemberN is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int64
func (_e *MockUniversalClient_Expecter) SRandMemberN(ctx interface{}, key interface{}, count interface{}) *MockUniversalClient_SRandMemberN_Call {
	return &MockUniversalClient_SRandMemberN_Call{Call: _e.mock.On("SRandMemberN", ctx, key, count)}
}

func (_c *MockUniversalClient_SRandMemberN_Call) Run(run func(ctx context.Context, key string, count int64)) *MockUniversalClient_SRandMemberN_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_SRandMemberN_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_SRandMemberN_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SRandMemberN_Call) RunAndReturn(run func(context.Context, string, int64) *redis.StringSliceCmd) *MockUniversalClient_SRandMemberN_Call {
	_c.Call.Return(run)
	return _c
}

// SRem provides a mock function with given fields: ctx, key, members
func (_m *MockUniversalClient) SRem(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SRem")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_SRem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SRem'
type MockUniversalClient_SRem_Call struct {
	*mock.Call
}

// SRem is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...interface{}
func (_e *MockUniversalClient_Expecter) SRem(ctx interface{}, key interface{}, members ...interface{}) *MockUniversalClient_SRem_Call {
	return &MockUniversalClient_SRem_Call{Call: _e.mock.On("SRem",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockUniversalClient_SRem_Call) Run(run func(ctx context.Context, key string, members ...interface{})) *MockUniversalClient_SRem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_SRem_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_SRem_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SRem_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *redis.IntCmd) *MockUniversalClient_SRem_Call {
	_c.Call.Return(run)
	return _c
}

// SScan provides a mock function with given fields: ctx, key, cursor, match, count
func (_m *MockUniversalClient) SScan(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(ctx, key, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for SScan")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(ctx, key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// MockUniversalClient_SScan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SScan'
type MockUniversalClient_SScan_Call struct {
	*mock.Call
}

// SScan is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - cursor uint64
//   - match string
//   - count int64
func (_e *MockUniversalClient_Expecter) SScan(ctx interface{}, key interface{}, cursor interface{}, match interface{}, count interface{}) *MockUniversalClient_SScan_Call {
	return &MockUniversalClient_SScan_Call{Call: _e.mock.On("SScan", ctx, key, cursor, match, count)}
}

func (_c *MockUniversalClient_SScan_Call) Run(run func(ctx context.Context, key string, cursor uint64, match string, count int64)) *MockUniversalClient_SScan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint64), args[3].(string), args[4].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_SScan_Call) Return(_a0 *redis.ScanCmd) *MockUniversalClient_SScan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SScan_Call) RunAndReturn(run func(context.Context, string, uint64, string, int64) *redis.ScanCmd) *MockUniversalClient_SScan_Call {
	_c.Call.Return(run)
	return _c
}

// SUnion provides a mock function with given fields: ctx, keys
func (_m *MockUniversalClient) SUnion(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SUnion")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_SUnion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SUnion'
type MockUniversalClient_SUnion_Call struct {
	*mock.Call
}

// SUnion is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockUniversalClient_Expecter) SUnion(ctx interface{}, keys ...interface{}) *MockUniversalClient_SUnion_Call {
	return &MockUniversalClient_SUnion_Call{Call: _e.mock.On("SUnion",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockUniversalClient_SUnion_Call) Run(run func(ctx context.Context, keys ...string)) *MockUniversalClient_SUnion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_SUnion_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_SUnion_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SUnion_Call) RunAndReturn(run func(context.Context, ...string) *redis.StringSliceCmd) *MockUniversalClient_SUnion_Call {
	_c.Call.Return(run)
	return _c
}

// SUnionStore provides a mock function with given fields: ctx, destination, keys
func (_m *MockUniversalClient) SUnionStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SUnionStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_SUnionStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SUnionStore'
type MockUniversalClient_SUnionStore_Call struct {
	*mock.Call
}

// SUnionStore is a helper method to define mock.On call
//   - ctx context.Context
//   - destination string
//   - keys ...string
func (_e *MockUniversalClient_Expecter) SUnionStore(ctx interface{}, destination interface{}, keys ...interface{}) *MockUniversalClient_SUnionStore_Call {
	return &MockUniversalClient_SUnionStore_Call{Call: _e.mock.On("SUnionStore",
		append([]interface{}{ctx, destination}, keys...)...)}
}

func (_c *MockUniversalClient_SUnionStore_Call) Run(run func(ctx context.Context, destination string, keys ...string)) *MockUniversalClient_SUnionStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_SUnionStore_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_SUnionStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SUnionStore_Call) RunAndReturn(run func(context.Context, string, ...string) *redis.IntCmd) *MockUniversalClient_SUnionStore_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function with given fields: ctx
func (_m *MockUniversalClient) Save(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockUniversalClient_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) Save(ctx interface{}) *MockUniversalClient_Save_Call {
	return &MockUniversalClient_Save_Call{Call: _e.mock.On("Save", ctx)}
}

func (_c *MockUniversalClient_Save_Call) Run(run func(ctx context.Context)) *MockUniversalClient_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_Save_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_Save_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Save_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_Save_Call {
	_c.Call.Return(run)
	return _c
}

// Scan provides a mock function with given fields: ctx, cursor, match, count
func (_m *MockUniversalClient) Scan(ctx context.Context, cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(ctx, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for Scan")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(ctx, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// MockUniversalClient_Scan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Scan'
type MockUniversalClient_Scan_Call struct {
	*mock.Call
}

// Scan is a helper method to define mock.On call
//   - ctx context.Context
//   - cursor uint64
//   - match string
//   - count int64
func (_e *MockUniversalClient_Expecter) Scan(ctx interface{}, cursor interface{}, match interface{}, count interface{}) *MockUniversalClient_Scan_Call {
	return &MockUniversalClient_Scan_Call{Call: _e.mock.On("Scan", ctx, cursor, match, count)}
}

func (_c *MockUniversalClient_Scan_Call) Run(run func(ctx context.Context, cursor uint64, match string, count int64)) *MockUniversalClient_Scan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(string), args[3].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_Scan_Call) Return(_a0 *redis.ScanCmd) *MockUniversalClient_Scan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Scan_Call) RunAndReturn(run func(context.Context, uint64, string, int64) *redis.ScanCmd) *MockUniversalClient_Scan_Call {
	_c.Call.Return(run)
	return _c
}

// ScanType provides a mock function with given fields: ctx, cursor, match, count, keyType
func (_m *MockUniversalClient) ScanType(ctx context.Context, cursor uint64, match string, count int64, keyType string) *redis.ScanCmd {
	ret := _m.Called(ctx, cursor, match, count, keyType)

	if len(ret) == 0 {
		panic("no return value specified for ScanType")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, uint64, string, int64, string) *redis.ScanCmd); ok {
		r0 = rf(ctx, cursor, match, count, keyType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// MockUniversalClient_ScanType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScanType'
type MockUniversalClient_ScanType_Call struct {
	*mock.Call
}

// ScanType is a helper method to define mock.On call
//   - ctx context.Context
//   - cursor uint64
//   - match string
//   - count int64
//   - keyType string
func (_e *MockUniversalClient_Expecter) ScanType(ctx interface{}, cursor interface{}, match interface{}, count interface{}, keyType interface{}) *MockUniversalClient_ScanType_Call {
	return &MockUniversalClient_ScanType_Call{Call: _e.mock.On("ScanType", ctx, cursor, match, count, keyType)}
}

func (_c *MockUniversalClient_ScanType_Call) Run(run func(ctx context.Context, cursor uint64, match string, count int64, keyType string)) *MockUniversalClient_ScanType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(string), args[3].(int64), args[4].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ScanType_Call) Return(_a0 *redis.ScanCmd) *MockUniversalClient_ScanType_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ScanType_Call) RunAndReturn(run func(context.Context, uint64, string, int64, string) *redis.ScanCmd) *MockUniversalClient_ScanType_Call {
	_c.Call.Return(run)
	return _c
}

// ScriptExists provides a mock function with given fields: ctx, hashes
func (_m *MockUniversalClient) ScriptExists(ctx context.Context, hashes ...string) *redis.BoolSliceCmd {
	_va := make([]interface{}, len(hashes))
	for _i := range hashes {
		_va[_i] = hashes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ScriptExists")
	}

	var r0 *redis.BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.BoolSliceCmd); ok {
		r0 = rf(ctx, hashes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ScriptExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScriptExists'
type MockUniversalClient_ScriptExists_Call struct {
	*mock.Call
}

// ScriptExists is a helper method to define mock.On call
//   - ctx context.Context
//   - hashes ...string
func (_e *MockUniversalClient_Expecter) ScriptExists(ctx interface{}, hashes ...interface{}) *MockUniversalClient_ScriptExists_Call {
	return &MockUniversalClient_ScriptExists_Call{Call: _e.mock.On("ScriptExists",
		append([]interface{}{ctx}, hashes...)...)}
}

func (_c *MockUniversalClient_ScriptExists_Call) Run(run func(ctx context.Context, hashes ...string)) *MockUniversalClient_ScriptExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_ScriptExists_Call) Return(_a0 *redis.BoolSliceCmd) *MockUniversalClient_ScriptExists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ScriptExists_Call) RunAndReturn(run func(context.Context, ...string) *redis.BoolSliceCmd) *MockUniversalClient_ScriptExists_Call {
	_c.Call.Return(run)
	return _c
}

// ScriptFlush provides a mock function with given fields: ctx
func (_m *MockUniversalClient) ScriptFlush(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ScriptFlush")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ScriptFlush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScriptFlush'
type MockUniversalClient_ScriptFlush_Call struct {
	*mock.Call
}

// ScriptFlush is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) ScriptFlush(ctx interface{}) *MockUniversalClient_ScriptFlush_Call {
	return &MockUniversalClient_ScriptFlush_Call{Call: _e.mock.On("ScriptFlush", ctx)}
}

func (_c *MockUniversalClient_ScriptFlush_Call) Run(run func(ctx context.Context)) *MockUniversalClient_ScriptFlush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_ScriptFlush_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ScriptFlush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ScriptFlush_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_ScriptFlush_Call {
	_c.Call.Return(run)
	return _c
}

// ScriptKill provides a mock function with given fields: ctx
func (_m *MockUniversalClient) ScriptKill(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ScriptKill")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ScriptKill_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScriptKill'
type MockUniversalClient_ScriptKill_Call struct {
	*mock.Call
}

// ScriptKill is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) ScriptKill(ctx interface{}) *MockUniversalClient_ScriptKill_Call {
	return &MockUniversalClient_ScriptKill_Call{Call: _e.mock.On("ScriptKill", ctx)}
}

func (_c *MockUniversalClient_ScriptKill_Call) Run(run func(ctx context.Context)) *MockUniversalClient_ScriptKill_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_ScriptKill_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ScriptKill_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ScriptKill_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_ScriptKill_Call {
	_c.Call.Return(run)
	return _c
}

// ScriptLoad provides a mock function with given fields: ctx, script
func (_m *MockUniversalClient) ScriptLoad(ctx context.Context, script string) *redis.StringCmd {
	ret := _m.Called(ctx, script)

	if len(ret) == 0 {
		panic("no return value specified for ScriptLoad")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StringCmd); ok {
		r0 = rf(ctx, script)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_ScriptLoad_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScriptLoad'
type MockUniversalClient_ScriptLoad_Call struct {
	*mock.Call
}

// ScriptLoad is a helper method to define mock.On call
//   - ctx context.Context
//   - script string
func (_e *MockUniversalClient_Expecter) ScriptLoad(ctx interface{}, script interface{}) *MockUniversalClient_ScriptLoad_Call {
	return &MockUniversalClient_ScriptLoad_Call{Call: _e.mock.On("ScriptLoad", ctx, script)}
}

func (_c *MockUniversalClient_ScriptLoad_Call) Run(run func(ctx context.Context, script string)) *MockUniversalClient_ScriptLoad_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ScriptLoad_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_ScriptLoad_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ScriptLoad_Call) RunAndReturn(run func(context.Context, string) *redis.StringCmd) *MockUniversalClient_ScriptLoad_Call {
	_c.Call.Return(run)
	return _c
}

// Set provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockUniversalClient) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for Set")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_Set_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Set'
type MockUniversalClient_Set_Call struct {
	*mock.Call
}

// Set is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
//   - expiration time.Duration
func (_e *MockUniversalClient_Expecter) Set(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockUniversalClient_Set_Call {
	return &MockUniversalClient_Set_Call{Call: _e.mock.On("Set", ctx, key, value, expiration)}
}

func (_c *MockUniversalClient_Set_Call) Run(run func(ctx context.Context, key string, value interface{}, expiration time.Duration)) *MockUniversalClient_Set_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockUniversalClient_Set_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_Set_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Set_Call) RunAndReturn(run func(context.Context, string, interface{}, time.Duration) *redis.StatusCmd) *MockUniversalClient_Set_Call {
	_c.Call.Return(run)
	return _c
}

// SetArgs provides a mock function with given fields: ctx, key, value, a
func (_m *MockUniversalClient) SetArgs(ctx context.Context, key string, value interface{}, a redis.SetArgs) *redis.StatusCmd {
	ret := _m.Called(ctx, key, value, a)

	if len(ret) == 0 {
		panic("no return value specified for SetArgs")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, redis.SetArgs) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, value, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_SetArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetArgs'
type MockUniversalClient_SetArgs_Call struct {
	*mock.Call
}

// SetArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
//   - a redis.SetArgs
func (_e *MockUniversalClient_Expecter) SetArgs(ctx interface{}, key interface{}, value interface{}, a interface{}) *MockUniversalClient_SetArgs_Call {
	return &MockUniversalClient_SetArgs_Call{Call: _e.mock.On("SetArgs", ctx, key, value, a)}
}

func (_c *MockUniversalClient_SetArgs_Call) Run(run func(ctx context.Context, key string, value interface{}, a redis.SetArgs)) *MockUniversalClient_SetArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(redis.SetArgs))
	})
	return _c
}

func (_c *MockUniversalClient_SetArgs_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_SetArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SetArgs_Call) RunAndReturn(run func(context.Context, string, interface{}, redis.SetArgs) *redis.StatusCmd) *MockUniversalClient_SetArgs_Call {
	_c.Call.Return(run)
	return _c
}

// SetBit provides a mock function with given fields: ctx, key, offset, value
func (_m *MockUniversalClient) SetBit(ctx context.Context, key string, offset int64, value int) *redis.IntCmd {
	ret := _m.Called(ctx, key, offset, value)

	if len(ret) == 0 {
		panic("no return value specified for SetBit")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int) *redis.IntCmd); ok {
		r0 = rf(ctx, key, offset, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_SetBit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetBit'
type MockUniversalClient_SetBit_Call struct {
	*mock.Call
}

// SetBit is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - offset int64
//   - value int
func (_e *MockUniversalClient_Expecter) SetBit(ctx interface{}, key interface{}, offset interface{}, value interface{}) *MockUniversalClient_SetBit_Call {
	return &MockUniversalClient_SetBit_Call{Call: _e.mock.On("SetBit", ctx, key, offset, value)}
}

func (_c *MockUniversalClient_SetBit_Call) Run(run func(ctx context.Context, key string, offset int64, value int)) *MockUniversalClient_SetBit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int))
	})
	return _c
}

func (_c *MockUniversalClient_SetBit_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_SetBit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SetBit_Call) RunAndReturn(run func(context.Context, string, int64, int) *redis.IntCmd) *MockUniversalClient_SetBit_Call {
	_c.Call.Return(run)
	return _c
}

// SetEX provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockUniversalClient) SetEX(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetEX")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *redis.StatusCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_SetEX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetEX'
type MockUniversalClient_SetEX_Call struct {
	*mock.Call
}

// SetEX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
//   - expiration time.Duration
func (_e *MockUniversalClient_Expecter) SetEX(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockUniversalClient_SetEX_Call {
	return &MockUniversalClient_SetEX_Call{Call: _e.mock.On("SetEX", ctx, key, value, expiration)}
}

func (_c *MockUniversalClient_SetEX_Call) Run(run func(ctx context.Context, key string, value interface{}, expiration time.Duration)) *MockUniversalClient_SetEX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockUniversalClient_SetEX_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_SetEX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SetEX_Call) RunAndReturn(run func(context.Context, string, interface{}, time.Duration) *redis.StatusCmd) *MockUniversalClient_SetEX_Call {
	_c.Call.Return(run)
	return _c
}

// SetNX provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockUniversalClient) SetNX(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_SetNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetNX'
type MockUniversalClient_SetNX_Call struct {
	*mock.Call
}

// SetNX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
//   - expiration time.Duration
func (_e *MockUniversalClient_Expecter) SetNX(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockUniversalClient_SetNX_Call {
	return &MockUniversalClient_SetNX_Call{Call: _e.mock.On("SetNX", ctx, key, value, expiration)}
}

func (_c *MockUniversalClient_SetNX_Call) Run(run func(ctx context.Context, key string, value interface{}, expiration time.Duration)) *MockUniversalClient_SetNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockUniversalClient_SetNX_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_SetNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SetNX_Call) RunAndReturn(run func(context.Context, string, interface{}, time.Duration) *redis.BoolCmd) *MockUniversalClient_SetNX_Call {
	_c.Call.Return(run)
	return _c
}

// SetRange provides a mock function with given fields: ctx, key, offset, value
func (_m *MockUniversalClient) SetRange(ctx context.Context, key string, offset int64, value string) *redis.IntCmd {
	ret := _m.Called(ctx, key, offset, value)

	if len(ret) == 0 {
		panic("no return value specified for SetRange")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, offset, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_SetRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRange'
type MockUniversalClient_SetRange_Call struct {
	*mock.Call
}

// SetRange is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - offset int64
//   - value string
func (_e *MockUniversalClient_Expecter) SetRange(ctx interface{}, key interface{}, offset interface{}, value interface{}) *MockUniversalClient_SetRange_Call {
	return &MockUniversalClient_SetRange_Call{Call: _e.mock.On("SetRange", ctx, key, offset, value)}
}

func (_c *MockUniversalClient_SetRange_Call) Run(run func(ctx context.Context, key string, offset int64, value string)) *MockUniversalClient_SetRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(string))
	})
	return _c
}

func (_c *MockUniversalClient_SetRange_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_SetRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SetRange_Call) RunAndReturn(run func(context.Context, string, int64, string) *redis.IntCmd) *MockUniversalClient_SetRange_Call {
	_c.Call.Return(run)
	return _c
}

// SetXX provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockUniversalClient) SetXX(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetXX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MockUniversalClient_SetXX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetXX'
type MockUniversalClient_SetXX_Call struct {
	*mock.Call
}

// SetXX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
//   - expiration time.Duration
func (_e *MockUniversalClient_Expecter) SetXX(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockUniversalClient_SetXX_Call {
	return &MockUniversalClient_SetXX_Call{Call: _e.mock.On("SetXX", ctx, key, value, expiration)}
}

func (_c *MockUniversalClient_SetXX_Call) Run(run func(ctx context.Context, key string, value interface{}, expiration time.Duration)) *MockUniversalClient_SetXX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockUniversalClient_SetXX_Call) Return(_a0 *redis.BoolCmd) *MockUniversalClient_SetXX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SetXX_Call) RunAndReturn(run func(context.Context, string, interface{}, time.Duration) *redis.BoolCmd) *MockUniversalClient_SetXX_Call {
	_c.Call.Return(run)
	return _c
}

// Shutdown provides a mock function with given fields: ctx
func (_m *MockUniversalClient) Shutdown(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Shutdown")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_Shutdown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Shutdown'
type MockUniversalClient_Shutdown_Call struct {
	*mock.Call
}

// Shutdown is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) Shutdown(ctx interface{}) *MockUniversalClient_Shutdown_Call {
	return &MockUniversalClient_Shutdown_Call{Call: _e.mock.On("Shutdown", ctx)}
}

func (_c *MockUniversalClient_Shutdown_Call) Run(run func(ctx context.Context)) *MockUniversalClient_Shutdown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_Shutdown_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_Shutdown_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Shutdown_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_Shutdown_Call {
	_c.Call.Return(run)
	return _c
}

// ShutdownNoSave provides a mock function with given fields: ctx
func (_m *MockUniversalClient) ShutdownNoSave(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ShutdownNoSave")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ShutdownNoSave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ShutdownNoSave'
type MockUniversalClient_ShutdownNoSave_Call struct {
	*mock.Call
}

// ShutdownNoSave is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) ShutdownNoSave(ctx interface{}) *MockUniversalClient_ShutdownNoSave_Call {
	return &MockUniversalClient_ShutdownNoSave_Call{Call: _e.mock.On("ShutdownNoSave", ctx)}
}

func (_c *MockUniversalClient_ShutdownNoSave_Call) Run(run func(ctx context.Context)) *MockUniversalClient_ShutdownNoSave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_ShutdownNoSave_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ShutdownNoSave_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ShutdownNoSave_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_ShutdownNoSave_Call {
	_c.Call.Return(run)
	return _c
}

// ShutdownSave provides a mock function with given fields: ctx
func (_m *MockUniversalClient) ShutdownSave(ctx context.Context) *redis.StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ShutdownSave")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_ShutdownSave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ShutdownSave'
type MockUniversalClient_ShutdownSave_Call struct {
	*mock.Call
}

// ShutdownSave is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) ShutdownSave(ctx interface{}) *MockUniversalClient_ShutdownSave_Call {
	return &MockUniversalClient_ShutdownSave_Call{Call: _e.mock.On("ShutdownSave", ctx)}
}

func (_c *MockUniversalClient_ShutdownSave_Call) Run(run func(ctx context.Context)) *MockUniversalClient_ShutdownSave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_ShutdownSave_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_ShutdownSave_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ShutdownSave_Call) RunAndReturn(run func(context.Context) *redis.StatusCmd) *MockUniversalClient_ShutdownSave_Call {
	_c.Call.Return(run)
	return _c
}

// SlaveOf provides a mock function with given fields: ctx, host, port
func (_m *MockUniversalClient) SlaveOf(ctx context.Context, host string, port string) *redis.StatusCmd {
	ret := _m.Called(ctx, host, port)

	if len(ret) == 0 {
		panic("no return value specified for SlaveOf")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, host, port)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_SlaveOf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SlaveOf'
type MockUniversalClient_SlaveOf_Call struct {
	*mock.Call
}

// SlaveOf is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port string
func (_e *MockUniversalClient_Expecter) SlaveOf(ctx interface{}, host interface{}, port interface{}) *MockUniversalClient_SlaveOf_Call {
	return &MockUniversalClient_SlaveOf_Call{Call: _e.mock.On("SlaveOf", ctx, host, port)}
}

func (_c *MockUniversalClient_SlaveOf_Call) Run(run func(ctx context.Context, host string, port string)) *MockUniversalClient_SlaveOf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUniversalClient_SlaveOf_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_SlaveOf_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SlaveOf_Call) RunAndReturn(run func(context.Context, string, string) *redis.StatusCmd) *MockUniversalClient_SlaveOf_Call {
	_c.Call.Return(run)
	return _c
}

// Sort provides a mock function with given fields: ctx, key, sort
func (_m *MockUniversalClient) Sort(ctx context.Context, key string, sort *redis.Sort) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, sort)

	if len(ret) == 0 {
		panic("no return value specified for Sort")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.Sort) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_Sort_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Sort'
type MockUniversalClient_Sort_Call struct {
	*mock.Call
}

// Sort is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - sort *redis.Sort
func (_e *MockUniversalClient_Expecter) Sort(ctx interface{}, key interface{}, sort interface{}) *MockUniversalClient_Sort_Call {
	return &MockUniversalClient_Sort_Call{Call: _e.mock.On("Sort", ctx, key, sort)}
}

func (_c *MockUniversalClient_Sort_Call) Run(run func(ctx context.Context, key string, sort *redis.Sort)) *MockUniversalClient_Sort_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*redis.Sort))
	})
	return _c
}

func (_c *MockUniversalClient_Sort_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_Sort_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Sort_Call) RunAndReturn(run func(context.Context, string, *redis.Sort) *redis.StringSliceCmd) *MockUniversalClient_Sort_Call {
	_c.Call.Return(run)
	return _c
}

// SortInterfaces provides a mock function with given fields: ctx, key, sort
func (_m *MockUniversalClient) SortInterfaces(ctx context.Context, key string, sort *redis.Sort) *redis.SliceCmd {
	ret := _m.Called(ctx, key, sort)

	if len(ret) == 0 {
		panic("no return value specified for SortInterfaces")
	}

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.Sort) *redis.SliceCmd); ok {
		r0 = rf(ctx, key, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_SortInterfaces_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SortInterfaces'
type MockUniversalClient_SortInterfaces_Call struct {
	*mock.Call
}

// SortInterfaces is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - sort *redis.Sort
func (_e *MockUniversalClient_Expecter) SortInterfaces(ctx interface{}, key interface{}, sort interface{}) *MockUniversalClient_SortInterfaces_Call {
	return &MockUniversalClient_SortInterfaces_Call{Call: _e.mock.On("SortInterfaces", ctx, key, sort)}
}

func (_c *MockUniversalClient_SortInterfaces_Call) Run(run func(ctx context.Context, key string, sort *redis.Sort)) *MockUniversalClient_SortInterfaces_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*redis.Sort))
	})
	return _c
}

func (_c *MockUniversalClient_SortInterfaces_Call) Return(_a0 *redis.SliceCmd) *MockUniversalClient_SortInterfaces_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SortInterfaces_Call) RunAndReturn(run func(context.Context, string, *redis.Sort) *redis.SliceCmd) *MockUniversalClient_SortInterfaces_Call {
	_c.Call.Return(run)
	return _c
}

// SortStore provides a mock function with given fields: ctx, key, store, sort
func (_m *MockUniversalClient) SortStore(ctx context.Context, key string, store string, sort *redis.Sort) *redis.IntCmd {
	ret := _m.Called(ctx, key, store, sort)

	if len(ret) == 0 {
		panic("no return value specified for SortStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *redis.Sort) *redis.IntCmd); ok {
		r0 = rf(ctx, key, store, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_SortStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SortStore'
type MockUniversalClient_SortStore_Call struct {
	*mock.Call
}

// SortStore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - store string
//   - sort *redis.Sort
func (_e *MockUniversalClient_Expecter) SortStore(ctx interface{}, key interface{}, store interface{}, sort interface{}) *MockUniversalClient_SortStore_Call {
	return &MockUniversalClient_SortStore_Call{Call: _e.mock.On("SortStore", ctx, key, store, sort)}
}

func (_c *MockUniversalClient_SortStore_Call) Run(run func(ctx context.Context, key string, store string, sort *redis.Sort)) *MockUniversalClient_SortStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*redis.Sort))
	})
	return _c
}

func (_c *MockUniversalClient_SortStore_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_SortStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_SortStore_Call) RunAndReturn(run func(context.Context, string, string, *redis.Sort) *redis.IntCmd) *MockUniversalClient_SortStore_Call {
	_c.Call.Return(run)
	return _c
}

// StrLen provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) StrLen(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for StrLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_StrLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StrLen'
type MockUniversalClient_StrLen_Call struct {
	*mock.Call
}

// StrLen is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) StrLen(ctx interface{}, key interface{}) *MockUniversalClient_StrLen_Call {
	return &MockUniversalClient_StrLen_Call{Call: _e.mock.On("StrLen", ctx, key)}
}

func (_c *MockUniversalClient_StrLen_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_StrLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_StrLen_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_StrLen_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_StrLen_Call) RunAndReturn(run func(context.Context, string) *redis.IntCmd) *MockUniversalClient_StrLen_Call {
	_c.Call.Return(run)
	return _c
}

// Subscribe provides a mock function with given fields: ctx, channels
func (_m *MockUniversalClient) Subscribe(ctx context.Context, channels ...string) *redis.PubSub {
	_va := make([]interface{}, len(channels))
	for _i := range channels {
		_va[_i] = channels[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Subscribe")
	}

	var r0 *redis.PubSub
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.PubSub); ok {
		r0 = rf(ctx, channels...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.PubSub)
		}
	}

	return r0
}

// MockUniversalClient_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type MockUniversalClient_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
//   - ctx context.Context
//   - channels ...string
func (_e *MockUniversalClient_Expecter) Subscribe(ctx interface{}, channels ...interface{}) *MockUniversalClient_Subscribe_Call {
	return &MockUniversalClient_Subscribe_Call{Call: _e.mock.On("Subscribe",
		append([]interface{}{ctx}, channels...)...)}
}

func (_c *MockUniversalClient_Subscribe_Call) Run(run func(ctx context.Context, channels ...string)) *MockUniversalClient_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_Subscribe_Call) Return(_a0 *redis.PubSub) *MockUniversalClient_Subscribe_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Subscribe_Call) RunAndReturn(run func(context.Context, ...string) *redis.PubSub) *MockUniversalClient_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}

// TTL provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) TTL(ctx context.Context, key string) *redis.DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TTL")
	}

	var r0 *redis.DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.DurationCmd)
		}
	}

	return r0
}

// MockUniversalClient_TTL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TTL'
type MockUniversalClient_TTL_Call struct {
	*mock.Call
}

// TTL is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) TTL(ctx interface{}, key interface{}) *MockUniversalClient_TTL_Call {
	return &MockUniversalClient_TTL_Call{Call: _e.mock.On("TTL", ctx, key)}
}

func (_c *MockUniversalClient_TTL_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_TTL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_TTL_Call) Return(_a0 *redis.DurationCmd) *MockUniversalClient_TTL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_TTL_Call) RunAndReturn(run func(context.Context, string) *redis.DurationCmd) *MockUniversalClient_TTL_Call {
	_c.Call.Return(run)
	return _c
}

// Time provides a mock function with given fields: ctx
func (_m *MockUniversalClient) Time(ctx context.Context) *redis.TimeCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Time")
	}

	var r0 *redis.TimeCmd
	if rf, ok := ret.Get(0).(func(context.Context) *redis.TimeCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.TimeCmd)
		}
	}

	return r0
}

// MockUniversalClient_Time_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Time'
type MockUniversalClient_Time_Call struct {
	*mock.Call
}

// Time is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUniversalClient_Expecter) Time(ctx interface{}) *MockUniversalClient_Time_Call {
	return &MockUniversalClient_Time_Call{Call: _e.mock.On("Time", ctx)}
}

func (_c *MockUniversalClient_Time_Call) Run(run func(ctx context.Context)) *MockUniversalClient_Time_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUniversalClient_Time_Call) Return(_a0 *redis.TimeCmd) *MockUniversalClient_Time_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Time_Call) RunAndReturn(run func(context.Context) *redis.TimeCmd) *MockUniversalClient_Time_Call {
	_c.Call.Return(run)
	return _c
}

// Touch provides a mock function with given fields: ctx, keys
func (_m *MockUniversalClient) Touch(ctx context.Context, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Touch")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_Touch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Touch'
type MockUniversalClient_Touch_Call struct {
	*mock.Call
}

// Touch is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockUniversalClient_Expecter) Touch(ctx interface{}, keys ...interface{}) *MockUniversalClient_Touch_Call {
	return &MockUniversalClient_Touch_Call{Call: _e.mock.On("Touch",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockUniversalClient_Touch_Call) Run(run func(ctx context.Context, keys ...string)) *MockUniversalClient_Touch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_Touch_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_Touch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Touch_Call) RunAndReturn(run func(context.Context, ...string) *redis.IntCmd) *MockUniversalClient_Touch_Call {
	_c.Call.Return(run)
	return _c
}

// TxPipeline provides a mock function with given fields:
func (_m *MockUniversalClient) TxPipeline() redis.Pipeliner {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TxPipeline")
	}

	var r0 redis.Pipeliner
	if rf, ok := ret.Get(0).(func() redis.Pipeliner); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(redis.Pipeliner)
		}
	}

	return r0
}

// MockUniversalClient_TxPipeline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TxPipeline'
type MockUniversalClient_TxPipeline_Call struct {
	*mock.Call
}

// TxPipeline is a helper method to define mock.On call
func (_e *MockUniversalClient_Expecter) TxPipeline() *MockUniversalClient_TxPipeline_Call {
	return &MockUniversalClient_TxPipeline_Call{Call: _e.mock.On("TxPipeline")}
}

func (_c *MockUniversalClient_TxPipeline_Call) Run(run func()) *MockUniversalClient_TxPipeline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockUniversalClient_TxPipeline_Call) Return(_a0 redis.Pipeliner) *MockUniversalClient_TxPipeline_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_TxPipeline_Call) RunAndReturn(run func() redis.Pipeliner) *MockUniversalClient_TxPipeline_Call {
	_c.Call.Return(run)
	return _c
}

// TxPipelined provides a mock function with given fields: ctx, fn
func (_m *MockUniversalClient) TxPipelined(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
	ret := _m.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for TxPipelined")
	}

	var r0 []redis.Cmder
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, func(redis.Pipeliner) error) ([]redis.Cmder, error)); ok {
		return rf(ctx, fn)
	}
	if rf, ok := ret.Get(0).(func(context.Context, func(redis.Pipeliner) error) []redis.Cmder); ok {
		r0 = rf(ctx, fn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.Cmder)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, func(redis.Pipeliner) error) error); ok {
		r1 = rf(ctx, fn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockUniversalClient_TxPipelined_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TxPipelined'
type MockUniversalClient_TxPipelined_Call struct {
	*mock.Call
}

// TxPipelined is a helper method to define mock.On call
//   - ctx context.Context
//   - fn func(redis.Pipeliner) error
func (_e *MockUniversalClient_Expecter) TxPipelined(ctx interface{}, fn interface{}) *MockUniversalClient_TxPipelined_Call {
	return &MockUniversalClient_TxPipelined_Call{Call: _e.mock.On("TxPipelined", ctx, fn)}
}

func (_c *MockUniversalClient_TxPipelined_Call) Run(run func(ctx context.Context, fn func(redis.Pipeliner) error)) *MockUniversalClient_TxPipelined_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(func(redis.Pipeliner) error))
	})
	return _c
}

func (_c *MockUniversalClient_TxPipelined_Call) Return(_a0 []redis.Cmder, _a1 error) *MockUniversalClient_TxPipelined_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUniversalClient_TxPipelined_Call) RunAndReturn(run func(context.Context, func(redis.Pipeliner) error) ([]redis.Cmder, error)) *MockUniversalClient_TxPipelined_Call {
	_c.Call.Return(run)
	return _c
}

// Type provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) Type(ctx context.Context, key string) *redis.StatusCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Type")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_Type_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Type'
type MockUniversalClient_Type_Call struct {
	*mock.Call
}

// Type is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) Type(ctx interface{}, key interface{}) *MockUniversalClient_Type_Call {
	return &MockUniversalClient_Type_Call{Call: _e.mock.On("Type", ctx, key)}
}

func (_c *MockUniversalClient_Type_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_Type_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_Type_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_Type_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Type_Call) RunAndReturn(run func(context.Context, string) *redis.StatusCmd) *MockUniversalClient_Type_Call {
	_c.Call.Return(run)
	return _c
}

// Unlink provides a mock function with given fields: ctx, keys
func (_m *MockUniversalClient) Unlink(ctx context.Context, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Unlink")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_Unlink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unlink'
type MockUniversalClient_Unlink_Call struct {
	*mock.Call
}

// Unlink is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockUniversalClient_Expecter) Unlink(ctx interface{}, keys ...interface{}) *MockUniversalClient_Unlink_Call {
	return &MockUniversalClient_Unlink_Call{Call: _e.mock.On("Unlink",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockUniversalClient_Unlink_Call) Run(run func(ctx context.Context, keys ...string)) *MockUniversalClient_Unlink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_Unlink_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_Unlink_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Unlink_Call) RunAndReturn(run func(context.Context, ...string) *redis.IntCmd) *MockUniversalClient_Unlink_Call {
	_c.Call.Return(run)
	return _c
}

// Watch provides a mock function with given fields: ctx, fn, keys
func (_m *MockUniversalClient) Watch(ctx context.Context, fn func(*redis.Tx) error, keys ...string) error {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, fn)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Watch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, func(*redis.Tx) error, ...string) error); ok {
		r0 = rf(ctx, fn, keys...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockUniversalClient_Watch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Watch'
type MockUniversalClient_Watch_Call struct {
	*mock.Call
}

// Watch is a helper method to define mock.On call
//   - ctx context.Context
//   - fn func(*redis.Tx) error
//   - keys ...string
func (_e *MockUniversalClient_Expecter) Watch(ctx interface{}, fn interface{}, keys ...interface{}) *MockUniversalClient_Watch_Call {
	return &MockUniversalClient_Watch_Call{Call: _e.mock.On("Watch",
		append([]interface{}{ctx, fn}, keys...)...)}
}

func (_c *MockUniversalClient_Watch_Call) Run(run func(ctx context.Context, fn func(*redis.Tx) error, keys ...string)) *MockUniversalClient_Watch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(func(*redis.Tx) error), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_Watch_Call) Return(_a0 error) *MockUniversalClient_Watch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_Watch_Call) RunAndReturn(run func(context.Context, func(*redis.Tx) error, ...string) error) *MockUniversalClient_Watch_Call {
	_c.Call.Return(run)
	return _c
}

// XAck provides a mock function with given fields: ctx, stream, group, ids
func (_m *MockUniversalClient) XAck(ctx context.Context, stream string, group string, ids ...string) *redis.IntCmd {
	_va := make([]interface{}, len(ids))
	for _i := range ids {
		_va[_i] = ids[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stream, group)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for XAck")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, stream, group, ids...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_XAck_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XAck'
type MockUniversalClient_XAck_Call struct {
	*mock.Call
}

// XAck is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - group string
//   - ids ...string
func (_e *MockUniversalClient_Expecter) XAck(ctx interface{}, stream interface{}, group interface{}, ids ...interface{}) *MockUniversalClient_XAck_Call {
	return &MockUniversalClient_XAck_Call{Call: _e.mock.On("XAck",
		append([]interface{}{ctx, stream, group}, ids...)...)}
}

func (_c *MockUniversalClient_XAck_Call) Run(run func(ctx context.Context, stream string, group string, ids ...string)) *MockUniversalClient_XAck_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_XAck_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_XAck_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XAck_Call) RunAndReturn(run func(context.Context, string, string, ...string) *redis.IntCmd) *MockUniversalClient_XAck_Call {
	_c.Call.Return(run)
	return _c
}

// XAdd provides a mock function with given fields: ctx, a
func (_m *MockUniversalClient) XAdd(ctx context.Context, a *redis.XAddArgs) *redis.StringCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XAdd")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XAddArgs) *redis.StringCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// MockUniversalClient_XAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XAdd'
type MockUniversalClient_XAdd_Call struct {
	*mock.Call
}

// XAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - a *redis.XAddArgs
func (_e *MockUniversalClient_Expecter) XAdd(ctx interface{}, a interface{}) *MockUniversalClient_XAdd_Call {
	return &MockUniversalClient_XAdd_Call{Call: _e.mock.On("XAdd", ctx, a)}
}

func (_c *MockUniversalClient_XAdd_Call) Run(run func(ctx context.Context, a *redis.XAddArgs)) *MockUniversalClient_XAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*redis.XAddArgs))
	})
	return _c
}

func (_c *MockUniversalClient_XAdd_Call) Return(_a0 *redis.StringCmd) *MockUniversalClient_XAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XAdd_Call) RunAndReturn(run func(context.Context, *redis.XAddArgs) *redis.StringCmd) *MockUniversalClient_XAdd_Call {
	_c.Call.Return(run)
	return _c
}

// XAutoClaim provides a mock function with given fields: ctx, a
func (_m *MockUniversalClient) XAutoClaim(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XAutoClaim")
	}

	var r0 *redis.XAutoClaimCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XAutoClaimArgs) *redis.XAutoClaimCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XAutoClaimCmd)
		}
	}

	return r0
}

// MockUniversalClient_XAutoClaim_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XAutoClaim'
type MockUniversalClient_XAutoClaim_Call struct {
	*mock.Call
}

// XAutoClaim is a helper method to define mock.On call
//   - ctx context.Context
//   - a *redis.XAutoClaimArgs
func (_e *MockUniversalClient_Expecter) XAutoClaim(ctx interface{}, a interface{}) *MockUniversalClient_XAutoClaim_Call {
	return &MockUniversalClient_XAutoClaim_Call{Call: _e.mock.On("XAutoClaim", ctx, a)}
}

func (_c *MockUniversalClient_XAutoClaim_Call) Run(run func(ctx context.Context, a *redis.XAutoClaimArgs)) *MockUniversalClient_XAutoClaim_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*redis.XAutoClaimArgs))
	})
	return _c
}

func (_c *MockUniversalClient_XAutoClaim_Call) Return(_a0 *redis.XAutoClaimCmd) *MockUniversalClient_XAutoClaim_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XAutoClaim_Call) RunAndReturn(run func(context.Context, *redis.XAutoClaimArgs) *redis.XAutoClaimCmd) *MockUniversalClient_XAutoClaim_Call {
	_c.Call.Return(run)
	return _c
}

// XAutoClaimJustID provides a mock function with given fields: ctx, a
func (_m *MockUniversalClient) XAutoClaimJustID(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimJustIDCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XAutoClaimJustID")
	}

	var r0 *redis.XAutoClaimJustIDCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XAutoClaimArgs) *redis.XAutoClaimJustIDCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XAutoClaimJustIDCmd)
		}
	}

	return r0
}

// MockUniversalClient_XAutoClaimJustID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XAutoClaimJustID'
type MockUniversalClient_XAutoClaimJustID_Call struct {
	*mock.Call
}

// XAutoClaimJustID is a helper method to define mock.On call
//   - ctx context.Context
//   - a *redis.XAutoClaimArgs
func (_e *MockUniversalClient_Expecter) XAutoClaimJustID(ctx interface{}, a interface{}) *MockUniversalClient_XAutoClaimJustID_Call {
	return &MockUniversalClient_XAutoClaimJustID_Call{Call: _e.mock.On("XAutoClaimJustID", ctx, a)}
}

func (_c *MockUniversalClient_XAutoClaimJustID_Call) Run(run func(ctx context.Context, a *redis.XAutoClaimArgs)) *MockUniversalClient_XAutoClaimJustID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*redis.XAutoClaimArgs))
	})
	return _c
}

func (_c *MockUniversalClient_XAutoClaimJustID_Call) Return(_a0 *redis.XAutoClaimJustIDCmd) *MockUniversalClient_XAutoClaimJustID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XAutoClaimJustID_Call) RunAndReturn(run func(context.Context, *redis.XAutoClaimArgs) *redis.XAutoClaimJustIDCmd) *MockUniversalClient_XAutoClaimJustID_Call {
	_c.Call.Return(run)
	return _c
}

// XClaim provides a mock function with given fields: ctx, a
func (_m *MockUniversalClient) XClaim(ctx context.Context, a *redis.XClaimArgs) *redis.XMessageSliceCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XClaim")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XClaimArgs) *redis.XMessageSliceCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_XClaim_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XClaim'
type MockUniversalClient_XClaim_Call struct {
	*mock.Call
}

// XClaim is a helper method to define mock.On call
//   - ctx context.Context
//   - a *redis.XClaimArgs
func (_e *MockUniversalClient_Expecter) XClaim(ctx interface{}, a interface{}) *MockUniversalClient_XClaim_Call {
	return &MockUniversalClient_XClaim_Call{Call: _e.mock.On("XClaim", ctx, a)}
}

func (_c *MockUniversalClient_XClaim_Call) Run(run func(ctx context.Context, a *redis.XClaimArgs)) *MockUniversalClient_XClaim_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*redis.XClaimArgs))
	})
	return _c
}

func (_c *MockUniversalClient_XClaim_Call) Return(_a0 *redis.XMessageSliceCmd) *MockUniversalClient_XClaim_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XClaim_Call) RunAndReturn(run func(context.Context, *redis.XClaimArgs) *redis.XMessageSliceCmd) *MockUniversalClient_XClaim_Call {
	_c.Call.Return(run)
	return _c
}

// XClaimJustID provides a mock function with given fields: ctx, a
func (_m *MockUniversalClient) XClaimJustID(ctx context.Context, a *redis.XClaimArgs) *redis.StringSliceCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XClaimJustID")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XClaimArgs) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_XClaimJustID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XClaimJustID'
type MockUniversalClient_XClaimJustID_Call struct {
	*mock.Call
}

// XClaimJustID is a helper method to define mock.On call
//   - ctx context.Context
//   - a *redis.XClaimArgs
func (_e *MockUniversalClient_Expecter) XClaimJustID(ctx interface{}, a interface{}) *MockUniversalClient_XClaimJustID_Call {
	return &MockUniversalClient_XClaimJustID_Call{Call: _e.mock.On("XClaimJustID", ctx, a)}
}

func (_c *MockUniversalClient_XClaimJustID_Call) Run(run func(ctx context.Context, a *redis.XClaimArgs)) *MockUniversalClient_XClaimJustID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*redis.XClaimArgs))
	})
	return _c
}

func (_c *MockUniversalClient_XClaimJustID_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_XClaimJustID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XClaimJustID_Call) RunAndReturn(run func(context.Context, *redis.XClaimArgs) *redis.StringSliceCmd) *MockUniversalClient_XClaimJustID_Call {
	_c.Call.Return(run)
	return _c
}

// XDel provides a mock function with given fields: ctx, stream, ids
func (_m *MockUniversalClient) XDel(ctx context.Context, stream string, ids ...string) *redis.IntCmd {
	_va := make([]interface{}, len(ids))
	for _i := range ids {
		_va[_i] = ids[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stream)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for XDel")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, stream, ids...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_XDel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XDel'
type MockUniversalClient_XDel_Call struct {
	*mock.Call
}

// XDel is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - ids ...string
func (_e *MockUniversalClient_Expecter) XDel(ctx interface{}, stream interface{}, ids ...interface{}) *MockUniversalClient_XDel_Call {
	return &MockUniversalClient_XDel_Call{Call: _e.mock.On("XDel",
		append([]interface{}{ctx, stream}, ids...)...)}
}

func (_c *MockUniversalClient_XDel_Call) Run(run func(ctx context.Context, stream string, ids ...string)) *MockUniversalClient_XDel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_XDel_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_XDel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XDel_Call) RunAndReturn(run func(context.Context, string, ...string) *redis.IntCmd) *MockUniversalClient_XDel_Call {
	_c.Call.Return(run)
	return _c
}

// XGroupCreate provides a mock function with given fields: ctx, stream, group, start
func (_m *MockUniversalClient) XGroupCreate(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
	ret := _m.Called(ctx, stream, group, start)

	if len(ret) == 0 {
		panic("no return value specified for XGroupCreate")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, stream, group, start)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_XGroupCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XGroupCreate'
type MockUniversalClient_XGroupCreate_Call struct {
	*mock.Call
}

// XGroupCreate is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - group string
//   - start string
func (_e *MockUniversalClient_Expecter) XGroupCreate(ctx interface{}, stream interface{}, group interface{}, start interface{}) *MockUniversalClient_XGroupCreate_Call {
	return &MockUniversalClient_XGroupCreate_Call{Call: _e.mock.On("XGroupCreate", ctx, stream, group, start)}
}

func (_c *MockUniversalClient_XGroupCreate_Call) Run(run func(ctx context.Context, stream string, group string, start string)) *MockUniversalClient_XGroupCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockUniversalClient_XGroupCreate_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_XGroupCreate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XGroupCreate_Call) RunAndReturn(run func(context.Context, string, string, string) *redis.StatusCmd) *MockUniversalClient_XGroupCreate_Call {
	_c.Call.Return(run)
	return _c
}

// XGroupCreateConsumer provides a mock function with given fields: ctx, stream, group, consumer
func (_m *MockUniversalClient) XGroupCreateConsumer(ctx context.Context, stream string, group string, consumer string) *redis.IntCmd {
	ret := _m.Called(ctx, stream, group, consumer)

	if len(ret) == 0 {
		panic("no return value specified for XGroupCreateConsumer")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, stream, group, consumer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_XGroupCreateConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XGroupCreateConsumer'
type MockUniversalClient_XGroupCreateConsumer_Call struct {
	*mock.Call
}

// XGroupCreateConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - group string
//   - consumer string
func (_e *MockUniversalClient_Expecter) XGroupCreateConsumer(ctx interface{}, stream interface{}, group interface{}, consumer interface{}) *MockUniversalClient_XGroupCreateConsumer_Call {
	return &MockUniversalClient_XGroupCreateConsumer_Call{Call: _e.mock.On("XGroupCreateConsumer", ctx, stream, group, consumer)}
}

func (_c *MockUniversalClient_XGroupCreateConsumer_Call) Run(run func(ctx context.Context, stream string, group string, consumer string)) *MockUniversalClient_XGroupCreateConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockUniversalClient_XGroupCreateConsumer_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_XGroupCreateConsumer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XGroupCreateConsumer_Call) RunAndReturn(run func(context.Context, string, string, string) *redis.IntCmd) *MockUniversalClient_XGroupCreateConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// XGroupCreateMkStream provides a mock function with given fields: ctx, stream, group, start
func (_m *MockUniversalClient) XGroupCreateMkStream(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
	ret := _m.Called(ctx, stream, group, start)

	if len(ret) == 0 {
		panic("no return value specified for XGroupCreateMkStream")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, stream, group, start)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_XGroupCreateMkStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XGroupCreateMkStream'
type MockUniversalClient_XGroupCreateMkStream_Call struct {
	*mock.Call
}

// XGroupCreateMkStream is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - group string
//   - start string
func (_e *MockUniversalClient_Expecter) XGroupCreateMkStream(ctx interface{}, stream interface{}, group interface{}, start interface{}) *MockUniversalClient_XGroupCreateMkStream_Call {
	return &MockUniversalClient_XGroupCreateMkStream_Call{Call: _e.mock.On("XGroupCreateMkStream", ctx, stream, group, start)}
}

func (_c *MockUniversalClient_XGroupCreateMkStream_Call) Run(run func(ctx context.Context, stream string, group string, start string)) *MockUniversalClient_XGroupCreateMkStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockUniversalClient_XGroupCreateMkStream_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_XGroupCreateMkStream_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XGroupCreateMkStream_Call) RunAndReturn(run func(context.Context, string, string, string) *redis.StatusCmd) *MockUniversalClient_XGroupCreateMkStream_Call {
	_c.Call.Return(run)
	return _c
}

// XGroupDelConsumer provides a mock function with given fields: ctx, stream, group, consumer
func (_m *MockUniversalClient) XGroupDelConsumer(ctx context.Context, stream string, group string, consumer string) *redis.IntCmd {
	ret := _m.Called(ctx, stream, group, consumer)

	if len(ret) == 0 {
		panic("no return value specified for XGroupDelConsumer")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, stream, group, consumer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_XGroupDelConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XGroupDelConsumer'
type MockUniversalClient_XGroupDelConsumer_Call struct {
	*mock.Call
}

// XGroupDelConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - group string
//   - consumer string
func (_e *MockUniversalClient_Expecter) XGroupDelConsumer(ctx interface{}, stream interface{}, group interface{}, consumer interface{}) *MockUniversalClient_XGroupDelConsumer_Call {
	return &MockUniversalClient_XGroupDelConsumer_Call{Call: _e.mock.On("XGroupDelConsumer", ctx, stream, group, consumer)}
}

func (_c *MockUniversalClient_XGroupDelConsumer_Call) Run(run func(ctx context.Context, stream string, group string, consumer string)) *MockUniversalClient_XGroupDelConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockUniversalClient_XGroupDelConsumer_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_XGroupDelConsumer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XGroupDelConsumer_Call) RunAndReturn(run func(context.Context, string, string, string) *redis.IntCmd) *MockUniversalClient_XGroupDelConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// XGroupDestroy provides a mock function with given fields: ctx, stream, group
func (_m *MockUniversalClient) XGroupDestroy(ctx context.Context, stream string, group string) *redis.IntCmd {
	ret := _m.Called(ctx, stream, group)

	if len(ret) == 0 {
		panic("no return value specified for XGroupDestroy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, stream, group)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_XGroupDestroy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XGroupDestroy'
type MockUniversalClient_XGroupDestroy_Call struct {
	*mock.Call
}

// XGroupDestroy is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - group string
func (_e *MockUniversalClient_Expecter) XGroupDestroy(ctx interface{}, stream interface{}, group interface{}) *MockUniversalClient_XGroupDestroy_Call {
	return &MockUniversalClient_XGroupDestroy_Call{Call: _e.mock.On("XGroupDestroy", ctx, stream, group)}
}

func (_c *MockUniversalClient_XGroupDestroy_Call) Run(run func(ctx context.Context, stream string, group string)) *MockUniversalClient_XGroupDestroy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUniversalClient_XGroupDestroy_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_XGroupDestroy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XGroupDestroy_Call) RunAndReturn(run func(context.Context, string, string) *redis.IntCmd) *MockUniversalClient_XGroupDestroy_Call {
	_c.Call.Return(run)
	return _c
}

// XGroupSetID provides a mock function with given fields: ctx, stream, group, start
func (_m *MockUniversalClient) XGroupSetID(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
	ret := _m.Called(ctx, stream, group, start)

	if len(ret) == 0 {
		panic("no return value specified for XGroupSetID")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.StatusCmd); ok {
		r0 = rf(ctx, stream, group, start)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MockUniversalClient_XGroupSetID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XGroupSetID'
type MockUniversalClient_XGroupSetID_Call struct {
	*mock.Call
}

// XGroupSetID is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - group string
//   - start string
func (_e *MockUniversalClient_Expecter) XGroupSetID(ctx interface{}, stream interface{}, group interface{}, start interface{}) *MockUniversalClient_XGroupSetID_Call {
	return &MockUniversalClient_XGroupSetID_Call{Call: _e.mock.On("XGroupSetID", ctx, stream, group, start)}
}

func (_c *MockUniversalClient_XGroupSetID_Call) Run(run func(ctx context.Context, stream string, group string, start string)) *MockUniversalClient_XGroupSetID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockUniversalClient_XGroupSetID_Call) Return(_a0 *redis.StatusCmd) *MockUniversalClient_XGroupSetID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XGroupSetID_Call) RunAndReturn(run func(context.Context, string, string, string) *redis.StatusCmd) *MockUniversalClient_XGroupSetID_Call {
	_c.Call.Return(run)
	return _c
}

// XInfoConsumers provides a mock function with given fields: ctx, key, group
func (_m *MockUniversalClient) XInfoConsumers(ctx context.Context, key string, group string) *redis.XInfoConsumersCmd {
	ret := _m.Called(ctx, key, group)

	if len(ret) == 0 {
		panic("no return value specified for XInfoConsumers")
	}

	var r0 *redis.XInfoConsumersCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.XInfoConsumersCmd); ok {
		r0 = rf(ctx, key, group)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XInfoConsumersCmd)
		}
	}

	return r0
}

// MockUniversalClient_XInfoConsumers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XInfoConsumers'
type MockUniversalClient_XInfoConsumers_Call struct {
	*mock.Call
}

// XInfoConsumers is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - group string
func (_e *MockUniversalClient_Expecter) XInfoConsumers(ctx interface{}, key interface{}, group interface{}) *MockUniversalClient_XInfoConsumers_Call {
	return &MockUniversalClient_XInfoConsumers_Call{Call: _e.mock.On("XInfoConsumers", ctx, key, group)}
}

func (_c *MockUniversalClient_XInfoConsumers_Call) Run(run func(ctx context.Context, key string, group string)) *MockUniversalClient_XInfoConsumers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUniversalClient_XInfoConsumers_Call) Return(_a0 *redis.XInfoConsumersCmd) *MockUniversalClient_XInfoConsumers_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XInfoConsumers_Call) RunAndReturn(run func(context.Context, string, string) *redis.XInfoConsumersCmd) *MockUniversalClient_XInfoConsumers_Call {
	_c.Call.Return(run)
	return _c
}

// XInfoGroups provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) XInfoGroups(ctx context.Context, key string) *redis.XInfoGroupsCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for XInfoGroups")
	}

	var r0 *redis.XInfoGroupsCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.XInfoGroupsCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XInfoGroupsCmd)
		}
	}

	return r0
}

// MockUniversalClient_XInfoGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XInfoGroups'
type MockUniversalClient_XInfoGroups_Call struct {
	*mock.Call
}

// XInfoGroups is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) XInfoGroups(ctx interface{}, key interface{}) *MockUniversalClient_XInfoGroups_Call {
	return &MockUniversalClient_XInfoGroups_Call{Call: _e.mock.On("XInfoGroups", ctx, key)}
}

func (_c *MockUniversalClient_XInfoGroups_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_XInfoGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_XInfoGroups_Call) Return(_a0 *redis.XInfoGroupsCmd) *MockUniversalClient_XInfoGroups_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XInfoGroups_Call) RunAndReturn(run func(context.Context, string) *redis.XInfoGroupsCmd) *MockUniversalClient_XInfoGroups_Call {
	_c.Call.Return(run)
	return _c
}

// XInfoStream provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) XInfoStream(ctx context.Context, key string) *redis.XInfoStreamCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for XInfoStream")
	}

	var r0 *redis.XInfoStreamCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.XInfoStreamCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XInfoStreamCmd)
		}
	}

	return r0
}

// MockUniversalClient_XInfoStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XInfoStream'
type MockUniversalClient_XInfoStream_Call struct {
	*mock.Call
}

// XInfoStream is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) XInfoStream(ctx interface{}, key interface{}) *MockUniversalClient_XInfoStream_Call {
	return &MockUniversalClient_XInfoStream_Call{Call: _e.mock.On("XInfoStream", ctx, key)}
}

func (_c *MockUniversalClient_XInfoStream_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_XInfoStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_XInfoStream_Call) Return(_a0 *redis.XInfoStreamCmd) *MockUniversalClient_XInfoStream_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XInfoStream_Call) RunAndReturn(run func(context.Context, string) *redis.XInfoStreamCmd) *MockUniversalClient_XInfoStream_Call {
	_c.Call.Return(run)
	return _c
}

// XInfoStreamFull provides a mock function with given fields: ctx, key, count
func (_m *MockUniversalClient) XInfoStreamFull(ctx context.Context, key string, count int) *redis.XInfoStreamFullCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for XInfoStreamFull")
	}

	var r0 *redis.XInfoStreamFullCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *redis.XInfoStreamFullCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XInfoStreamFullCmd)
		}
	}

	return r0
}

// MockUniversalClient_XInfoStreamFull_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XInfoStreamFull'
type MockUniversalClient_XInfoStreamFull_Call struct {
	*mock.Call
}

// XInfoStreamFull is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int
func (_e *MockUniversalClient_Expecter) XInfoStreamFull(ctx interface{}, key interface{}, count interface{}) *MockUniversalClient_XInfoStreamFull_Call {
	return &MockUniversalClient_XInfoStreamFull_Call{Call: _e.mock.On("XInfoStreamFull", ctx, key, count)}
}

func (_c *MockUniversalClient_XInfoStreamFull_Call) Run(run func(ctx context.Context, key string, count int)) *MockUniversalClient_XInfoStreamFull_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockUniversalClient_XInfoStreamFull_Call) Return(_a0 *redis.XInfoStreamFullCmd) *MockUniversalClient_XInfoStreamFull_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XInfoStreamFull_Call) RunAndReturn(run func(context.Context, string, int) *redis.XInfoStreamFullCmd) *MockUniversalClient_XInfoStreamFull_Call {
	_c.Call.Return(run)
	return _c
}

// XLen provides a mock function with given fields: ctx, stream
func (_m *MockUniversalClient) XLen(ctx context.Context, stream string) *redis.IntCmd {
	ret := _m.Called(ctx, stream)

	if len(ret) == 0 {
		panic("no return value specified for XLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, stream)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_XLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XLen'
type MockUniversalClient_XLen_Call struct {
	*mock.Call
}

// XLen is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
func (_e *MockUniversalClient_Expecter) XLen(ctx interface{}, stream interface{}) *MockUniversalClient_XLen_Call {
	return &MockUniversalClient_XLen_Call{Call: _e.mock.On("XLen", ctx, stream)}
}

func (_c *MockUniversalClient_XLen_Call) Run(run func(ctx context.Context, stream string)) *MockUniversalClient_XLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_XLen_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_XLen_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XLen_Call) RunAndReturn(run func(context.Context, string) *redis.IntCmd) *MockUniversalClient_XLen_Call {
	_c.Call.Return(run)
	return _c
}

// XPending provides a mock function with given fields: ctx, stream, group
func (_m *MockUniversalClient) XPending(ctx context.Context, stream string, group string) *redis.XPendingCmd {
	ret := _m.Called(ctx, stream, group)

	if len(ret) == 0 {
		panic("no return value specified for XPending")
	}

	var r0 *redis.XPendingCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.XPendingCmd); ok {
		r0 = rf(ctx, stream, group)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XPendingCmd)
		}
	}

	return r0
}

// MockUniversalClient_XPending_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XPending'
type MockUniversalClient_XPending_Call struct {
	*mock.Call
}

// XPending is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - group string
func (_e *MockUniversalClient_Expecter) XPending(ctx interface{}, stream interface{}, group interface{}) *MockUniversalClient_XPending_Call {
	return &MockUniversalClient_XPending_Call{Call: _e.mock.On("XPending", ctx, stream, group)}
}

func (_c *MockUniversalClient_XPending_Call) Run(run func(ctx context.Context, stream string, group string)) *MockUniversalClient_XPending_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUniversalClient_XPending_Call) Return(_a0 *redis.XPendingCmd) *MockUniversalClient_XPending_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XPending_Call) RunAndReturn(run func(context.Context, string, string) *redis.XPendingCmd) *MockUniversalClient_XPending_Call {
	_c.Call.Return(run)
	return _c
}

// XPendingExt provides a mock function with given fields: ctx, a
func (_m *MockUniversalClient) XPendingExt(ctx context.Context, a *redis.XPendingExtArgs) *redis.XPendingExtCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XPendingExt")
	}

	var r0 *redis.XPendingExtCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XPendingExtArgs) *redis.XPendingExtCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XPendingExtCmd)
		}
	}

	return r0
}

// MockUniversalClient_XPendingExt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XPendingExt'
type MockUniversalClient_XPendingExt_Call struct {
	*mock.Call
}

// XPendingExt is a helper method to define mock.On call
//   - ctx context.Context
//   - a *redis.XPendingExtArgs
func (_e *MockUniversalClient_Expecter) XPendingExt(ctx interface{}, a interface{}) *MockUniversalClient_XPendingExt_Call {
	return &MockUniversalClient_XPendingExt_Call{Call: _e.mock.On("XPendingExt", ctx, a)}
}

func (_c *MockUniversalClient_XPendingExt_Call) Run(run func(ctx context.Context, a *redis.XPendingExtArgs)) *MockUniversalClient_XPendingExt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*redis.XPendingExtArgs))
	})
	return _c
}

func (_c *MockUniversalClient_XPendingExt_Call) Return(_a0 *redis.XPendingExtCmd) *MockUniversalClient_XPendingExt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XPendingExt_Call) RunAndReturn(run func(context.Context, *redis.XPendingExtArgs) *redis.XPendingExtCmd) *MockUniversalClient_XPendingExt_Call {
	_c.Call.Return(run)
	return _c
}

// XRange provides a mock function with given fields: ctx, stream, start, stop
func (_m *MockUniversalClient) XRange(ctx context.Context, stream string, start string, stop string) *redis.XMessageSliceCmd {
	ret := _m.Called(ctx, stream, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for XRange")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.XMessageSliceCmd); ok {
		r0 = rf(ctx, stream, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_XRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XRange'
type MockUniversalClient_XRange_Call struct {
	*mock.Call
}

// XRange is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - start string
//   - stop string
func (_e *MockUniversalClient_Expecter) XRange(ctx interface{}, stream interface{}, start interface{}, stop interface{}) *MockUniversalClient_XRange_Call {
	return &MockUniversalClient_XRange_Call{Call: _e.mock.On("XRange", ctx, stream, start, stop)}
}

func (_c *MockUniversalClient_XRange_Call) Run(run func(ctx context.Context, stream string, start string, stop string)) *MockUniversalClient_XRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockUniversalClient_XRange_Call) Return(_a0 *redis.XMessageSliceCmd) *MockUniversalClient_XRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XRange_Call) RunAndReturn(run func(context.Context, string, string, string) *redis.XMessageSliceCmd) *MockUniversalClient_XRange_Call {
	_c.Call.Return(run)
	return _c
}

// XRangeN provides a mock function with given fields: ctx, stream, start, stop, count
func (_m *MockUniversalClient) XRangeN(ctx context.Context, stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
	ret := _m.Called(ctx, stream, start, stop, count)

	if len(ret) == 0 {
		panic("no return value specified for XRangeN")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64) *redis.XMessageSliceCmd); ok {
		r0 = rf(ctx, stream, start, stop, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_XRangeN_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XRangeN'
type MockUniversalClient_XRangeN_Call struct {
	*mock.Call
}

// XRangeN is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - start string
//   - stop string
//   - count int64
func (_e *MockUniversalClient_Expecter) XRangeN(ctx interface{}, stream interface{}, start interface{}, stop interface{}, count interface{}) *MockUniversalClient_XRangeN_Call {
	return &MockUniversalClient_XRangeN_Call{Call: _e.mock.On("XRangeN", ctx, stream, start, stop, count)}
}

func (_c *MockUniversalClient_XRangeN_Call) Run(run func(ctx context.Context, stream string, start string, stop string, count int64)) *MockUniversalClient_XRangeN_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_XRangeN_Call) Return(_a0 *redis.XMessageSliceCmd) *MockUniversalClient_XRangeN_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XRangeN_Call) RunAndReturn(run func(context.Context, string, string, string, int64) *redis.XMessageSliceCmd) *MockUniversalClient_XRangeN_Call {
	_c.Call.Return(run)
	return _c
}

// XRead provides a mock function with given fields: ctx, a
func (_m *MockUniversalClient) XRead(ctx context.Context, a *redis.XReadArgs) *redis.XStreamSliceCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XRead")
	}

	var r0 *redis.XStreamSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XReadArgs) *redis.XStreamSliceCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XStreamSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_XRead_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XRead'
type MockUniversalClient_XRead_Call struct {
	*mock.Call
}

// XRead is a helper method to define mock.On call
//   - ctx context.Context
//   - a *redis.XReadArgs
func (_e *MockUniversalClient_Expecter) XRead(ctx interface{}, a interface{}) *MockUniversalClient_XRead_Call {
	return &MockUniversalClient_XRead_Call{Call: _e.mock.On("XRead", ctx, a)}
}

func (_c *MockUniversalClient_XRead_Call) Run(run func(ctx context.Context, a *redis.XReadArgs)) *MockUniversalClient_XRead_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*redis.XReadArgs))
	})
	return _c
}

func (_c *MockUniversalClient_XRead_Call) Return(_a0 *redis.XStreamSliceCmd) *MockUniversalClient_XRead_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XRead_Call) RunAndReturn(run func(context.Context, *redis.XReadArgs) *redis.XStreamSliceCmd) *MockUniversalClient_XRead_Call {
	_c.Call.Return(run)
	return _c
}

// XReadGroup provides a mock function with given fields: ctx, a
func (_m *MockUniversalClient) XReadGroup(ctx context.Context, a *redis.XReadGroupArgs) *redis.XStreamSliceCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XReadGroup")
	}

	var r0 *redis.XStreamSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.XReadGroupArgs) *redis.XStreamSliceCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XStreamSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_XReadGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XReadGroup'
type MockUniversalClient_XReadGroup_Call struct {
	*mock.Call
}

// XReadGroup is a helper method to define mock.On call
//   - ctx context.Context
//   - a *redis.XReadGroupArgs
func (_e *MockUniversalClient_Expecter) XReadGroup(ctx interface{}, a interface{}) *MockUniversalClient_XReadGroup_Call {
	return &MockUniversalClient_XReadGroup_Call{Call: _e.mock.On("XReadGroup", ctx, a)}
}

func (_c *MockUniversalClient_XReadGroup_Call) Run(run func(ctx context.Context, a *redis.XReadGroupArgs)) *MockUniversalClient_XReadGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*redis.XReadGroupArgs))
	})
	return _c
}

func (_c *MockUniversalClient_XReadGroup_Call) Return(_a0 *redis.XStreamSliceCmd) *MockUniversalClient_XReadGroup_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XReadGroup_Call) RunAndReturn(run func(context.Context, *redis.XReadGroupArgs) *redis.XStreamSliceCmd) *MockUniversalClient_XReadGroup_Call {
	_c.Call.Return(run)
	return _c
}

// XReadStreams provides a mock function with given fields: ctx, streams
func (_m *MockUniversalClient) XReadStreams(ctx context.Context, streams ...string) *redis.XStreamSliceCmd {
	_va := make([]interface{}, len(streams))
	for _i := range streams {
		_va[_i] = streams[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for XReadStreams")
	}

	var r0 *redis.XStreamSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.XStreamSliceCmd); ok {
		r0 = rf(ctx, streams...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XStreamSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_XReadStreams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XReadStreams'
type MockUniversalClient_XReadStreams_Call struct {
	*mock.Call
}

// XReadStreams is a helper method to define mock.On call
//   - ctx context.Context
//   - streams ...string
func (_e *MockUniversalClient_Expecter) XReadStreams(ctx interface{}, streams ...interface{}) *MockUniversalClient_XReadStreams_Call {
	return &MockUniversalClient_XReadStreams_Call{Call: _e.mock.On("XReadStreams",
		append([]interface{}{ctx}, streams...)...)}
}

func (_c *MockUniversalClient_XReadStreams_Call) Run(run func(ctx context.Context, streams ...string)) *MockUniversalClient_XReadStreams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_XReadStreams_Call) Return(_a0 *redis.XStreamSliceCmd) *MockUniversalClient_XReadStreams_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XReadStreams_Call) RunAndReturn(run func(context.Context, ...string) *redis.XStreamSliceCmd) *MockUniversalClient_XReadStreams_Call {
	_c.Call.Return(run)
	return _c
}

// XRevRange provides a mock function with given fields: ctx, stream, start, stop
func (_m *MockUniversalClient) XRevRange(ctx context.Context, stream string, start string, stop string) *redis.XMessageSliceCmd {
	ret := _m.Called(ctx, stream, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for XRevRange")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.XMessageSliceCmd); ok {
		r0 = rf(ctx, stream, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_XRevRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XRevRange'
type MockUniversalClient_XRevRange_Call struct {
	*mock.Call
}

// XRevRange is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - start string
//   - stop string
func (_e *MockUniversalClient_Expecter) XRevRange(ctx interface{}, stream interface{}, start interface{}, stop interface{}) *MockUniversalClient_XRevRange_Call {
	return &MockUniversalClient_XRevRange_Call{Call: _e.mock.On("XRevRange", ctx, stream, start, stop)}
}

func (_c *MockUniversalClient_XRevRange_Call) Run(run func(ctx context.Context, stream string, start string, stop string)) *MockUniversalClient_XRevRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockUniversalClient_XRevRange_Call) Return(_a0 *redis.XMessageSliceCmd) *MockUniversalClient_XRevRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XRevRange_Call) RunAndReturn(run func(context.Context, string, string, string) *redis.XMessageSliceCmd) *MockUniversalClient_XRevRange_Call {
	_c.Call.Return(run)
	return _c
}

// XRevRangeN provides a mock function with given fields: ctx, stream, start, stop, count
func (_m *MockUniversalClient) XRevRangeN(ctx context.Context, stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
	ret := _m.Called(ctx, stream, start, stop, count)

	if len(ret) == 0 {
		panic("no return value specified for XRevRangeN")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64) *redis.XMessageSliceCmd); ok {
		r0 = rf(ctx, stream, start, stop, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_XRevRangeN_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XRevRangeN'
type MockUniversalClient_XRevRangeN_Call struct {
	*mock.Call
}

// XRevRangeN is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - start string
//   - stop string
//   - count int64
func (_e *MockUniversalClient_Expecter) XRevRangeN(ctx interface{}, stream interface{}, start interface{}, stop interface{}, count interface{}) *MockUniversalClient_XRevRangeN_Call {
	return &MockUniversalClient_XRevRangeN_Call{Call: _e.mock.On("XRevRangeN", ctx, stream, start, stop, count)}
}

func (_c *MockUniversalClient_XRevRangeN_Call) Run(run func(ctx context.Context, stream string, start string, stop string, count int64)) *MockUniversalClient_XRevRangeN_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_XRevRangeN_Call) Return(_a0 *redis.XMessageSliceCmd) *MockUniversalClient_XRevRangeN_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XRevRangeN_Call) RunAndReturn(run func(context.Context, string, string, string, int64) *redis.XMessageSliceCmd) *MockUniversalClient_XRevRangeN_Call {
	_c.Call.Return(run)
	return _c
}

// XTrim provides a mock function with given fields: ctx, key, maxLen
func (_m *MockUniversalClient) XTrim(ctx context.Context, key string, maxLen int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, maxLen)

	if len(ret) == 0 {
		panic("no return value specified for XTrim")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, maxLen)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_XTrim_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XTrim'
type MockUniversalClient_XTrim_Call struct {
	*mock.Call
}

// XTrim is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - maxLen int64
func (_e *MockUniversalClient_Expecter) XTrim(ctx interface{}, key interface{}, maxLen interface{}) *MockUniversalClient_XTrim_Call {
	return &MockUniversalClient_XTrim_Call{Call: _e.mock.On("XTrim", ctx, key, maxLen)}
}

func (_c *MockUniversalClient_XTrim_Call) Run(run func(ctx context.Context, key string, maxLen int64)) *MockUniversalClient_XTrim_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_XTrim_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_XTrim_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XTrim_Call) RunAndReturn(run func(context.Context, string, int64) *redis.IntCmd) *MockUniversalClient_XTrim_Call {
	_c.Call.Return(run)
	return _c
}

// XTrimApprox provides a mock function with given fields: ctx, key, maxLen
func (_m *MockUniversalClient) XTrimApprox(ctx context.Context, key string, maxLen int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, maxLen)

	if len(ret) == 0 {
		panic("no return value specified for XTrimApprox")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, maxLen)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_XTrimApprox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XTrimApprox'
type MockUniversalClient_XTrimApprox_Call struct {
	*mock.Call
}

// XTrimApprox is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - maxLen int64
func (_e *MockUniversalClient_Expecter) XTrimApprox(ctx interface{}, key interface{}, maxLen interface{}) *MockUniversalClient_XTrimApprox_Call {
	return &MockUniversalClient_XTrimApprox_Call{Call: _e.mock.On("XTrimApprox", ctx, key, maxLen)}
}

func (_c *MockUniversalClient_XTrimApprox_Call) Run(run func(ctx context.Context, key string, maxLen int64)) *MockUniversalClient_XTrimApprox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_XTrimApprox_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_XTrimApprox_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XTrimApprox_Call) RunAndReturn(run func(context.Context, string, int64) *redis.IntCmd) *MockUniversalClient_XTrimApprox_Call {
	_c.Call.Return(run)
	return _c
}

// XTrimMaxLen provides a mock function with given fields: ctx, key, maxLen
func (_m *MockUniversalClient) XTrimMaxLen(ctx context.Context, key string, maxLen int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, maxLen)

	if len(ret) == 0 {
		panic("no return value specified for XTrimMaxLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, maxLen)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_XTrimMaxLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XTrimMaxLen'
type MockUniversalClient_XTrimMaxLen_Call struct {
	*mock.Call
}

// XTrimMaxLen is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - maxLen int64
func (_e *MockUniversalClient_Expecter) XTrimMaxLen(ctx interface{}, key interface{}, maxLen interface{}) *MockUniversalClient_XTrimMaxLen_Call {
	return &MockUniversalClient_XTrimMaxLen_Call{Call: _e.mock.On("XTrimMaxLen", ctx, key, maxLen)}
}

func (_c *MockUniversalClient_XTrimMaxLen_Call) Run(run func(ctx context.Context, key string, maxLen int64)) *MockUniversalClient_XTrimMaxLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_XTrimMaxLen_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_XTrimMaxLen_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XTrimMaxLen_Call) RunAndReturn(run func(context.Context, string, int64) *redis.IntCmd) *MockUniversalClient_XTrimMaxLen_Call {
	_c.Call.Return(run)
	return _c
}

// XTrimMaxLenApprox provides a mock function with given fields: ctx, key, maxLen, limit
func (_m *MockUniversalClient) XTrimMaxLenApprox(ctx context.Context, key string, maxLen int64, limit int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, maxLen, limit)

	if len(ret) == 0 {
		panic("no return value specified for XTrimMaxLenApprox")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, maxLen, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_XTrimMaxLenApprox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XTrimMaxLenApprox'
type MockUniversalClient_XTrimMaxLenApprox_Call struct {
	*mock.Call
}

// XTrimMaxLenApprox is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - maxLen int64
//   - limit int64
func (_e *MockUniversalClient_Expecter) XTrimMaxLenApprox(ctx interface{}, key interface{}, maxLen interface{}, limit interface{}) *MockUniversalClient_XTrimMaxLenApprox_Call {
	return &MockUniversalClient_XTrimMaxLenApprox_Call{Call: _e.mock.On("XTrimMaxLenApprox", ctx, key, maxLen, limit)}
}

func (_c *MockUniversalClient_XTrimMaxLenApprox_Call) Run(run func(ctx context.Context, key string, maxLen int64, limit int64)) *MockUniversalClient_XTrimMaxLenApprox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_XTrimMaxLenApprox_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_XTrimMaxLenApprox_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XTrimMaxLenApprox_Call) RunAndReturn(run func(context.Context, string, int64, int64) *redis.IntCmd) *MockUniversalClient_XTrimMaxLenApprox_Call {
	_c.Call.Return(run)
	return _c
}

// XTrimMinID provides a mock function with given fields: ctx, key, minID
func (_m *MockUniversalClient) XTrimMinID(ctx context.Context, key string, minID string) *redis.IntCmd {
	ret := _m.Called(ctx, key, minID)

	if len(ret) == 0 {
		panic("no return value specified for XTrimMinID")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, minID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_XTrimMinID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XTrimMinID'
type MockUniversalClient_XTrimMinID_Call struct {
	*mock.Call
}

// XTrimMinID is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - minID string
func (_e *MockUniversalClient_Expecter) XTrimMinID(ctx interface{}, key interface{}, minID interface{}) *MockUniversalClient_XTrimMinID_Call {
	return &MockUniversalClient_XTrimMinID_Call{Call: _e.mock.On("XTrimMinID", ctx, key, minID)}
}

func (_c *MockUniversalClient_XTrimMinID_Call) Run(run func(ctx context.Context, key string, minID string)) *MockUniversalClient_XTrimMinID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUniversalClient_XTrimMinID_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_XTrimMinID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XTrimMinID_Call) RunAndReturn(run func(context.Context, string, string) *redis.IntCmd) *MockUniversalClient_XTrimMinID_Call {
	_c.Call.Return(run)
	return _c
}

// XTrimMinIDApprox provides a mock function with given fields: ctx, key, minID, limit
func (_m *MockUniversalClient) XTrimMinIDApprox(ctx context.Context, key string, minID string, limit int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, minID, limit)

	if len(ret) == 0 {
		panic("no return value specified for XTrimMinIDApprox")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, minID, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_XTrimMinIDApprox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XTrimMinIDApprox'
type MockUniversalClient_XTrimMinIDApprox_Call struct {
	*mock.Call
}

// XTrimMinIDApprox is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - minID string
//   - limit int64
func (_e *MockUniversalClient_Expecter) XTrimMinIDApprox(ctx interface{}, key interface{}, minID interface{}, limit interface{}) *MockUniversalClient_XTrimMinIDApprox_Call {
	return &MockUniversalClient_XTrimMinIDApprox_Call{Call: _e.mock.On("XTrimMinIDApprox", ctx, key, minID, limit)}
}

func (_c *MockUniversalClient_XTrimMinIDApprox_Call) Run(run func(ctx context.Context, key string, minID string, limit int64)) *MockUniversalClient_XTrimMinIDApprox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_XTrimMinIDApprox_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_XTrimMinIDApprox_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_XTrimMinIDApprox_Call) RunAndReturn(run func(context.Context, string, string, int64) *redis.IntCmd) *MockUniversalClient_XTrimMinIDApprox_Call {
	_c.Call.Return(run)
	return _c
}

// ZAdd provides a mock function with given fields: ctx, key, members
func (_m *MockUniversalClient) ZAdd(ctx context.Context, key string, members ...*redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAdd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*redis.Z) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZAdd'
type MockUniversalClient_ZAdd_Call struct {
	*mock.Call
}

// ZAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...*redis.Z
func (_e *MockUniversalClient_Expecter) ZAdd(ctx interface{}, key interface{}, members ...interface{}) *MockUniversalClient_ZAdd_Call {
	return &MockUniversalClient_ZAdd_Call{Call: _e.mock.On("ZAdd",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockUniversalClient_ZAdd_Call) Run(run func(ctx context.Context, key string, members ...*redis.Z)) *MockUniversalClient_ZAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*redis.Z, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*redis.Z)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_ZAdd_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZAdd_Call) RunAndReturn(run func(context.Context, string, ...*redis.Z) *redis.IntCmd) *MockUniversalClient_ZAdd_Call {
	_c.Call.Return(run)
	return _c
}

// ZAddArgs provides a mock function with given fields: ctx, key, args
func (_m *MockUniversalClient) ZAddArgs(ctx context.Context, key string, args redis.ZAddArgs) *redis.IntCmd {
	ret := _m.Called(ctx, key, args)

	if len(ret) == 0 {
		panic("no return value specified for ZAddArgs")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, redis.ZAddArgs) *redis.IntCmd); ok {
		r0 = rf(ctx, key, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZAddArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZAddArgs'
type MockUniversalClient_ZAddArgs_Call struct {
	*mock.Call
}

// ZAddArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - args redis.ZAddArgs
func (_e *MockUniversalClient_Expecter) ZAddArgs(ctx interface{}, key interface{}, args interface{}) *MockUniversalClient_ZAddArgs_Call {
	return &MockUniversalClient_ZAddArgs_Call{Call: _e.mock.On("ZAddArgs", ctx, key, args)}
}

func (_c *MockUniversalClient_ZAddArgs_Call) Run(run func(ctx context.Context, key string, args redis.ZAddArgs)) *MockUniversalClient_ZAddArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(redis.ZAddArgs))
	})
	return _c
}

func (_c *MockUniversalClient_ZAddArgs_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZAddArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZAddArgs_Call) RunAndReturn(run func(context.Context, string, redis.ZAddArgs) *redis.IntCmd) *MockUniversalClient_ZAddArgs_Call {
	_c.Call.Return(run)
	return _c
}

// ZAddArgsIncr provides a mock function with given fields: ctx, key, args
func (_m *MockUniversalClient) ZAddArgsIncr(ctx context.Context, key string, args redis.ZAddArgs) *redis.FloatCmd {
	ret := _m.Called(ctx, key, args)

	if len(ret) == 0 {
		panic("no return value specified for ZAddArgsIncr")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, redis.ZAddArgs) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZAddArgsIncr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZAddArgsIncr'
type MockUniversalClient_ZAddArgsIncr_Call struct {
	*mock.Call
}

// ZAddArgsIncr is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - args redis.ZAddArgs
func (_e *MockUniversalClient_Expecter) ZAddArgsIncr(ctx interface{}, key interface{}, args interface{}) *MockUniversalClient_ZAddArgsIncr_Call {
	return &MockUniversalClient_ZAddArgsIncr_Call{Call: _e.mock.On("ZAddArgsIncr", ctx, key, args)}
}

func (_c *MockUniversalClient_ZAddArgsIncr_Call) Run(run func(ctx context.Context, key string, args redis.ZAddArgs)) *MockUniversalClient_ZAddArgsIncr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(redis.ZAddArgs))
	})
	return _c
}

func (_c *MockUniversalClient_ZAddArgsIncr_Call) Return(_a0 *redis.FloatCmd) *MockUniversalClient_ZAddArgsIncr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZAddArgsIncr_Call) RunAndReturn(run func(context.Context, string, redis.ZAddArgs) *redis.FloatCmd) *MockUniversalClient_ZAddArgsIncr_Call {
	_c.Call.Return(run)
	return _c
}

// ZAddCh provides a mock function with given fields: ctx, key, members
func (_m *MockUniversalClient) ZAddCh(ctx context.Context, key string, members ...*redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddCh")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*redis.Z) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZAddCh_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZAddCh'
type MockUniversalClient_ZAddCh_Call struct {
	*mock.Call
}

// ZAddCh is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...*redis.Z
func (_e *MockUniversalClient_Expecter) ZAddCh(ctx interface{}, key interface{}, members ...interface{}) *MockUniversalClient_ZAddCh_Call {
	return &MockUniversalClient_ZAddCh_Call{Call: _e.mock.On("ZAddCh",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockUniversalClient_ZAddCh_Call) Run(run func(ctx context.Context, key string, members ...*redis.Z)) *MockUniversalClient_ZAddCh_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*redis.Z, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*redis.Z)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_ZAddCh_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZAddCh_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZAddCh_Call) RunAndReturn(run func(context.Context, string, ...*redis.Z) *redis.IntCmd) *MockUniversalClient_ZAddCh_Call {
	_c.Call.Return(run)
	return _c
}

// ZAddNX provides a mock function with given fields: ctx, key, members
func (_m *MockUniversalClient) ZAddNX(ctx context.Context, key string, members ...*redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddNX")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*redis.Z) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZAddNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZAddNX'
type MockUniversalClient_ZAddNX_Call struct {
	*mock.Call
}

// ZAddNX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...*redis.Z
func (_e *MockUniversalClient_Expecter) ZAddNX(ctx interface{}, key interface{}, members ...interface{}) *MockUniversalClient_ZAddNX_Call {
	return &MockUniversalClient_ZAddNX_Call{Call: _e.mock.On("ZAddNX",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockUniversalClient_ZAddNX_Call) Run(run func(ctx context.Context, key string, members ...*redis.Z)) *MockUniversalClient_ZAddNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*redis.Z, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*redis.Z)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_ZAddNX_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZAddNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZAddNX_Call) RunAndReturn(run func(context.Context, string, ...*redis.Z) *redis.IntCmd) *MockUniversalClient_ZAddNX_Call {
	_c.Call.Return(run)
	return _c
}

// ZAddNXCh provides a mock function with given fields: ctx, key, members
func (_m *MockUniversalClient) ZAddNXCh(ctx context.Context, key string, members ...*redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddNXCh")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*redis.Z) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZAddNXCh_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZAddNXCh'
type MockUniversalClient_ZAddNXCh_Call struct {
	*mock.Call
}

// ZAddNXCh is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...*redis.Z
func (_e *MockUniversalClient_Expecter) ZAddNXCh(ctx interface{}, key interface{}, members ...interface{}) *MockUniversalClient_ZAddNXCh_Call {
	return &MockUniversalClient_ZAddNXCh_Call{Call: _e.mock.On("ZAddNXCh",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockUniversalClient_ZAddNXCh_Call) Run(run func(ctx context.Context, key string, members ...*redis.Z)) *MockUniversalClient_ZAddNXCh_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*redis.Z, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*redis.Z)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_ZAddNXCh_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZAddNXCh_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZAddNXCh_Call) RunAndReturn(run func(context.Context, string, ...*redis.Z) *redis.IntCmd) *MockUniversalClient_ZAddNXCh_Call {
	_c.Call.Return(run)
	return _c
}

// ZAddXX provides a mock function with given fields: ctx, key, members
func (_m *MockUniversalClient) ZAddXX(ctx context.Context, key string, members ...*redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddXX")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*redis.Z) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZAddXX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZAddXX'
type MockUniversalClient_ZAddXX_Call struct {
	*mock.Call
}

// ZAddXX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...*redis.Z
func (_e *MockUniversalClient_Expecter) ZAddXX(ctx interface{}, key interface{}, members ...interface{}) *MockUniversalClient_ZAddXX_Call {
	return &MockUniversalClient_ZAddXX_Call{Call: _e.mock.On("ZAddXX",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockUniversalClient_ZAddXX_Call) Run(run func(ctx context.Context, key string, members ...*redis.Z)) *MockUniversalClient_ZAddXX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*redis.Z, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*redis.Z)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_ZAddXX_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZAddXX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZAddXX_Call) RunAndReturn(run func(context.Context, string, ...*redis.Z) *redis.IntCmd) *MockUniversalClient_ZAddXX_Call {
	_c.Call.Return(run)
	return _c
}

// ZAddXXCh provides a mock function with given fields: ctx, key, members
func (_m *MockUniversalClient) ZAddXXCh(ctx context.Context, key string, members ...*redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddXXCh")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*redis.Z) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZAddXXCh_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZAddXXCh'
type MockUniversalClient_ZAddXXCh_Call struct {
	*mock.Call
}

// ZAddXXCh is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...*redis.Z
func (_e *MockUniversalClient_Expecter) ZAddXXCh(ctx interface{}, key interface{}, members ...interface{}) *MockUniversalClient_ZAddXXCh_Call {
	return &MockUniversalClient_ZAddXXCh_Call{Call: _e.mock.On("ZAddXXCh",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockUniversalClient_ZAddXXCh_Call) Run(run func(ctx context.Context, key string, members ...*redis.Z)) *MockUniversalClient_ZAddXXCh_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*redis.Z, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*redis.Z)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_ZAddXXCh_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZAddXXCh_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZAddXXCh_Call) RunAndReturn(run func(context.Context, string, ...*redis.Z) *redis.IntCmd) *MockUniversalClient_ZAddXXCh_Call {
	_c.Call.Return(run)
	return _c
}

// ZCard provides a mock function with given fields: ctx, key
func (_m *MockUniversalClient) ZCard(ctx context.Context, key string) *redis.IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ZCard")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZCard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZCard'
type MockUniversalClient_ZCard_Call struct {
	*mock.Call
}

// ZCard is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockUniversalClient_Expecter) ZCard(ctx interface{}, key interface{}) *MockUniversalClient_ZCard_Call {
	return &MockUniversalClient_ZCard_Call{Call: _e.mock.On("ZCard", ctx, key)}
}

func (_c *MockUniversalClient_ZCard_Call) Run(run func(ctx context.Context, key string)) *MockUniversalClient_ZCard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ZCard_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZCard_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZCard_Call) RunAndReturn(run func(context.Context, string) *redis.IntCmd) *MockUniversalClient_ZCard_Call {
	_c.Call.Return(run)
	return _c
}

// ZCount provides a mock function with given fields: ctx, key, min, max
func (_m *MockUniversalClient) ZCount(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(ctx, key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZCount'
type MockUniversalClient_ZCount_Call struct {
	*mock.Call
}

// ZCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - min string
//   - max string
func (_e *MockUniversalClient_Expecter) ZCount(ctx interface{}, key interface{}, min interface{}, max interface{}) *MockUniversalClient_ZCount_Call {
	return &MockUniversalClient_ZCount_Call{Call: _e.mock.On("ZCount", ctx, key, min, max)}
}

func (_c *MockUniversalClient_ZCount_Call) Run(run func(ctx context.Context, key string, min string, max string)) *MockUniversalClient_ZCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ZCount_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZCount_Call) RunAndReturn(run func(context.Context, string, string, string) *redis.IntCmd) *MockUniversalClient_ZCount_Call {
	_c.Call.Return(run)
	return _c
}

// ZDiff provides a mock function with given fields: ctx, keys
func (_m *MockUniversalClient) ZDiff(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZDiff")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZDiff_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZDiff'
type MockUniversalClient_ZDiff_Call struct {
	*mock.Call
}

// ZDiff is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockUniversalClient_Expecter) ZDiff(ctx interface{}, keys ...interface{}) *MockUniversalClient_ZDiff_Call {
	return &MockUniversalClient_ZDiff_Call{Call: _e.mock.On("ZDiff",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockUniversalClient_ZDiff_Call) Run(run func(ctx context.Context, keys ...string)) *MockUniversalClient_ZDiff_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_ZDiff_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_ZDiff_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZDiff_Call) RunAndReturn(run func(context.Context, ...string) *redis.StringSliceCmd) *MockUniversalClient_ZDiff_Call {
	_c.Call.Return(run)
	return _c
}

// ZDiffStore provides a mock function with given fields: ctx, destination, keys
func (_m *MockUniversalClient) ZDiffStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZDiffStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.IntCmd); ok {
		r0 = rf(ctx, destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZDiffStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZDiffStore'
type MockUniversalClient_ZDiffStore_Call struct {
	*mock.Call
}

// ZDiffStore is a helper method to define mock.On call
//   - ctx context.Context
//   - destination string
//   - keys ...string
func (_e *MockUniversalClient_Expecter) ZDiffStore(ctx interface{}, destination interface{}, keys ...interface{}) *MockUniversalClient_ZDiffStore_Call {
	return &MockUniversalClient_ZDiffStore_Call{Call: _e.mock.On("ZDiffStore",
		append([]interface{}{ctx, destination}, keys...)...)}
}

func (_c *MockUniversalClient_ZDiffStore_Call) Run(run func(ctx context.Context, destination string, keys ...string)) *MockUniversalClient_ZDiffStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_ZDiffStore_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZDiffStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZDiffStore_Call) RunAndReturn(run func(context.Context, string, ...string) *redis.IntCmd) *MockUniversalClient_ZDiffStore_Call {
	_c.Call.Return(run)
	return _c
}

// ZDiffWithScores provides a mock function with given fields: ctx, keys
func (_m *MockUniversalClient) ZDiffWithScores(ctx context.Context, keys ...string) *redis.ZSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZDiffWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZDiffWithScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZDiffWithScores'
type MockUniversalClient_ZDiffWithScores_Call struct {
	*mock.Call
}

// ZDiffWithScores is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockUniversalClient_Expecter) ZDiffWithScores(ctx interface{}, keys ...interface{}) *MockUniversalClient_ZDiffWithScores_Call {
	return &MockUniversalClient_ZDiffWithScores_Call{Call: _e.mock.On("ZDiffWithScores",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockUniversalClient_ZDiffWithScores_Call) Run(run func(ctx context.Context, keys ...string)) *MockUniversalClient_ZDiffWithScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_ZDiffWithScores_Call) Return(_a0 *redis.ZSliceCmd) *MockUniversalClient_ZDiffWithScores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZDiffWithScores_Call) RunAndReturn(run func(context.Context, ...string) *redis.ZSliceCmd) *MockUniversalClient_ZDiffWithScores_Call {
	_c.Call.Return(run)
	return _c
}

// ZIncr provides a mock function with given fields: ctx, key, member
func (_m *MockUniversalClient) ZIncr(ctx context.Context, key string, member *redis.Z) *redis.FloatCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZIncr")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.Z) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZIncr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZIncr'
type MockUniversalClient_ZIncr_Call struct {
	*mock.Call
}

// ZIncr is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member *redis.Z
func (_e *MockUniversalClient_Expecter) ZIncr(ctx interface{}, key interface{}, member interface{}) *MockUniversalClient_ZIncr_Call {
	return &MockUniversalClient_ZIncr_Call{Call: _e.mock.On("ZIncr", ctx, key, member)}
}

func (_c *MockUniversalClient_ZIncr_Call) Run(run func(ctx context.Context, key string, member *redis.Z)) *MockUniversalClient_ZIncr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*redis.Z))
	})
	return _c
}

func (_c *MockUniversalClient_ZIncr_Call) Return(_a0 *redis.FloatCmd) *MockUniversalClient_ZIncr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZIncr_Call) RunAndReturn(run func(context.Context, string, *redis.Z) *redis.FloatCmd) *MockUniversalClient_ZIncr_Call {
	_c.Call.Return(run)
	return _c
}

// ZIncrBy provides a mock function with given fields: ctx, key, increment, member
func (_m *MockUniversalClient) ZIncrBy(ctx context.Context, key string, increment float64, member string) *redis.FloatCmd {
	ret := _m.Called(ctx, key, increment, member)

	if len(ret) == 0 {
		panic("no return value specified for ZIncrBy")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, string) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, increment, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZIncrBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZIncrBy'
type MockUniversalClient_ZIncrBy_Call struct {
	*mock.Call
}

// ZIncrBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - increment float64
//   - member string
func (_e *MockUniversalClient_Expecter) ZIncrBy(ctx interface{}, key interface{}, increment interface{}, member interface{}) *MockUniversalClient_ZIncrBy_Call {
	return &MockUniversalClient_ZIncrBy_Call{Call: _e.mock.On("ZIncrBy", ctx, key, increment, member)}
}

func (_c *MockUniversalClient_ZIncrBy_Call) Run(run func(ctx context.Context, key string, increment float64, member string)) *MockUniversalClient_ZIncrBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ZIncrBy_Call) Return(_a0 *redis.FloatCmd) *MockUniversalClient_ZIncrBy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZIncrBy_Call) RunAndReturn(run func(context.Context, string, float64, string) *redis.FloatCmd) *MockUniversalClient_ZIncrBy_Call {
	_c.Call.Return(run)
	return _c
}

// ZIncrNX provides a mock function with given fields: ctx, key, member
func (_m *MockUniversalClient) ZIncrNX(ctx context.Context, key string, member *redis.Z) *redis.FloatCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZIncrNX")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.Z) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZIncrNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZIncrNX'
type MockUniversalClient_ZIncrNX_Call struct {
	*mock.Call
}

// ZIncrNX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member *redis.Z
func (_e *MockUniversalClient_Expecter) ZIncrNX(ctx interface{}, key interface{}, member interface{}) *MockUniversalClient_ZIncrNX_Call {
	return &MockUniversalClient_ZIncrNX_Call{Call: _e.mock.On("ZIncrNX", ctx, key, member)}
}

func (_c *MockUniversalClient_ZIncrNX_Call) Run(run func(ctx context.Context, key string, member *redis.Z)) *MockUniversalClient_ZIncrNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*redis.Z))
	})
	return _c
}

func (_c *MockUniversalClient_ZIncrNX_Call) Return(_a0 *redis.FloatCmd) *MockUniversalClient_ZIncrNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZIncrNX_Call) RunAndReturn(run func(context.Context, string, *redis.Z) *redis.FloatCmd) *MockUniversalClient_ZIncrNX_Call {
	_c.Call.Return(run)
	return _c
}

// ZIncrXX provides a mock function with given fields: ctx, key, member
func (_m *MockUniversalClient) ZIncrXX(ctx context.Context, key string, member *redis.Z) *redis.FloatCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZIncrXX")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.Z) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZIncrXX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZIncrXX'
type MockUniversalClient_ZIncrXX_Call struct {
	*mock.Call
}

// ZIncrXX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member *redis.Z
func (_e *MockUniversalClient_Expecter) ZIncrXX(ctx interface{}, key interface{}, member interface{}) *MockUniversalClient_ZIncrXX_Call {
	return &MockUniversalClient_ZIncrXX_Call{Call: _e.mock.On("ZIncrXX", ctx, key, member)}
}

func (_c *MockUniversalClient_ZIncrXX_Call) Run(run func(ctx context.Context, key string, member *redis.Z)) *MockUniversalClient_ZIncrXX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*redis.Z))
	})
	return _c
}

func (_c *MockUniversalClient_ZIncrXX_Call) Return(_a0 *redis.FloatCmd) *MockUniversalClient_ZIncrXX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZIncrXX_Call) RunAndReturn(run func(context.Context, string, *redis.Z) *redis.FloatCmd) *MockUniversalClient_ZIncrXX_Call {
	_c.Call.Return(run)
	return _c
}

// ZInter provides a mock function with given fields: ctx, store
func (_m *MockUniversalClient) ZInter(ctx context.Context, store *redis.ZStore) *redis.StringSliceCmd {
	ret := _m.Called(ctx, store)

	if len(ret) == 0 {
		panic("no return value specified for ZInter")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.ZStore) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZInter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZInter'
type MockUniversalClient_ZInter_Call struct {
	*mock.Call
}

// ZInter is a helper method to define mock.On call
//   - ctx context.Context
//   - store *redis.ZStore
func (_e *MockUniversalClient_Expecter) ZInter(ctx interface{}, store interface{}) *MockUniversalClient_ZInter_Call {
	return &MockUniversalClient_ZInter_Call{Call: _e.mock.On("ZInter", ctx, store)}
}

func (_c *MockUniversalClient_ZInter_Call) Run(run func(ctx context.Context, store *redis.ZStore)) *MockUniversalClient_ZInter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*redis.ZStore))
	})
	return _c
}

func (_c *MockUniversalClient_ZInter_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_ZInter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZInter_Call) RunAndReturn(run func(context.Context, *redis.ZStore) *redis.StringSliceCmd) *MockUniversalClient_ZInter_Call {
	_c.Call.Return(run)
	return _c
}

// ZInterStore provides a mock function with given fields: ctx, destination, store
func (_m *MockUniversalClient) ZInterStore(ctx context.Context, destination string, store *redis.ZStore) *redis.IntCmd {
	ret := _m.Called(ctx, destination, store)

	if len(ret) == 0 {
		panic("no return value specified for ZInterStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZStore) *redis.IntCmd); ok {
		r0 = rf(ctx, destination, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZInterStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZInterStore'
type MockUniversalClient_ZInterStore_Call struct {
	*mock.Call
}

// ZInterStore is a helper method to define mock.On call
//   - ctx context.Context
//   - destination string
//   - store *redis.ZStore
func (_e *MockUniversalClient_Expecter) ZInterStore(ctx interface{}, destination interface{}, store interface{}) *MockUniversalClient_ZInterStore_Call {
	return &MockUniversalClient_ZInterStore_Call{Call: _e.mock.On("ZInterStore", ctx, destination, store)}
}

func (_c *MockUniversalClient_ZInterStore_Call) Run(run func(ctx context.Context, destination string, store *redis.ZStore)) *MockUniversalClient_ZInterStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*redis.ZStore))
	})
	return _c
}

func (_c *MockUniversalClient_ZInterStore_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZInterStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZInterStore_Call) RunAndReturn(run func(context.Context, string, *redis.ZStore) *redis.IntCmd) *MockUniversalClient_ZInterStore_Call {
	_c.Call.Return(run)
	return _c
}

// ZInterWithScores provides a mock function with given fields: ctx, store
func (_m *MockUniversalClient) ZInterWithScores(ctx context.Context, store *redis.ZStore) *redis.ZSliceCmd {
	ret := _m.Called(ctx, store)

	if len(ret) == 0 {
		panic("no return value specified for ZInterWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *redis.ZStore) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZInterWithScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZInterWithScores'
type MockUniversalClient_ZInterWithScores_Call struct {
	*mock.Call
}

// ZInterWithScores is a helper method to define mock.On call
//   - ctx context.Context
//   - store *redis.ZStore
func (_e *MockUniversalClient_Expecter) ZInterWithScores(ctx interface{}, store interface{}) *MockUniversalClient_ZInterWithScores_Call {
	return &MockUniversalClient_ZInterWithScores_Call{Call: _e.mock.On("ZInterWithScores", ctx, store)}
}

func (_c *MockUniversalClient_ZInterWithScores_Call) Run(run func(ctx context.Context, store *redis.ZStore)) *MockUniversalClient_ZInterWithScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*redis.ZStore))
	})
	return _c
}

func (_c *MockUniversalClient_ZInterWithScores_Call) Return(_a0 *redis.ZSliceCmd) *MockUniversalClient_ZInterWithScores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZInterWithScores_Call) RunAndReturn(run func(context.Context, *redis.ZStore) *redis.ZSliceCmd) *MockUniversalClient_ZInterWithScores_Call {
	_c.Call.Return(run)
	return _c
}

// ZLexCount provides a mock function with given fields: ctx, key, min, max
func (_m *MockUniversalClient) ZLexCount(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(ctx, key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZLexCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZLexCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZLexCount'
type MockUniversalClient_ZLexCount_Call struct {
	*mock.Call
}

// ZLexCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - min string
//   - max string
func (_e *MockUniversalClient_Expecter) ZLexCount(ctx interface{}, key interface{}, min interface{}, max interface{}) *MockUniversalClient_ZLexCount_Call {
	return &MockUniversalClient_ZLexCount_Call{Call: _e.mock.On("ZLexCount", ctx, key, min, max)}
}

func (_c *MockUniversalClient_ZLexCount_Call) Run(run func(ctx context.Context, key string, min string, max string)) *MockUniversalClient_ZLexCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ZLexCount_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZLexCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZLexCount_Call) RunAndReturn(run func(context.Context, string, string, string) *redis.IntCmd) *MockUniversalClient_ZLexCount_Call {
	_c.Call.Return(run)
	return _c
}

// ZMScore provides a mock function with given fields: ctx, key, members
func (_m *MockUniversalClient) ZMScore(ctx context.Context, key string, members ...string) *redis.FloatSliceCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZMScore")
	}

	var r0 *redis.FloatSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *redis.FloatSliceCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZMScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZMScore'
type MockUniversalClient_ZMScore_Call struct {
	*mock.Call
}

// ZMScore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...string
func (_e *MockUniversalClient_Expecter) ZMScore(ctx interface{}, key interface{}, members ...interface{}) *MockUniversalClient_ZMScore_Call {
	return &MockUniversalClient_ZMScore_Call{Call: _e.mock.On("ZMScore",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockUniversalClient_ZMScore_Call) Run(run func(ctx context.Context, key string, members ...string)) *MockUniversalClient_ZMScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_ZMScore_Call) Return(_a0 *redis.FloatSliceCmd) *MockUniversalClient_ZMScore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZMScore_Call) RunAndReturn(run func(context.Context, string, ...string) *redis.FloatSliceCmd) *MockUniversalClient_ZMScore_Call {
	_c.Call.Return(run)
	return _c
}

// ZPopMax provides a mock function with given fields: ctx, key, count
func (_m *MockUniversalClient) ZPopMax(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd {
	_va := make([]interface{}, len(count))
	for _i := range count {
		_va[_i] = count[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZPopMax")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...int64) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, key, count...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZPopMax_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZPopMax'
type MockUniversalClient_ZPopMax_Call struct {
	*mock.Call
}

// ZPopMax is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count ...int64
func (_e *MockUniversalClient_Expecter) ZPopMax(ctx interface{}, key interface{}, count ...interface{}) *MockUniversalClient_ZPopMax_Call {
	return &MockUniversalClient_ZPopMax_Call{Call: _e.mock.On("ZPopMax",
		append([]interface{}{ctx, key}, count...)...)}
}

func (_c *MockUniversalClient_ZPopMax_Call) Run(run func(ctx context.Context, key string, count ...int64)) *MockUniversalClient_ZPopMax_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int64, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(int64)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_ZPopMax_Call) Return(_a0 *redis.ZSliceCmd) *MockUniversalClient_ZPopMax_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZPopMax_Call) RunAndReturn(run func(context.Context, string, ...int64) *redis.ZSliceCmd) *MockUniversalClient_ZPopMax_Call {
	_c.Call.Return(run)
	return _c
}

// ZPopMin provides a mock function with given fields: ctx, key, count
func (_m *MockUniversalClient) ZPopMin(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd {
	_va := make([]interface{}, len(count))
	for _i := range count {
		_va[_i] = count[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZPopMin")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...int64) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, key, count...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZPopMin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZPopMin'
type MockUniversalClient_ZPopMin_Call struct {
	*mock.Call
}

// ZPopMin is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count ...int64
func (_e *MockUniversalClient_Expecter) ZPopMin(ctx interface{}, key interface{}, count ...interface{}) *MockUniversalClient_ZPopMin_Call {
	return &MockUniversalClient_ZPopMin_Call{Call: _e.mock.On("ZPopMin",
		append([]interface{}{ctx, key}, count...)...)}
}

func (_c *MockUniversalClient_ZPopMin_Call) Run(run func(ctx context.Context, key string, count ...int64)) *MockUniversalClient_ZPopMin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int64, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(int64)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_ZPopMin_Call) Return(_a0 *redis.ZSliceCmd) *MockUniversalClient_ZPopMin_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZPopMin_Call) RunAndReturn(run func(context.Context, string, ...int64) *redis.ZSliceCmd) *MockUniversalClient_ZPopMin_Call {
	_c.Call.Return(run)
	return _c
}

// ZRandMember provides a mock function with given fields: ctx, key, count, withScores
func (_m *MockUniversalClient) ZRandMember(ctx context.Context, key string, count int, withScores bool) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, count, withScores)

	if len(ret) == 0 {
		panic("no return value specified for ZRandMember")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int, bool) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, count, withScores)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRandMember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRandMember'
type MockUniversalClient_ZRandMember_Call struct {
	*mock.Call
}

// ZRandMember is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int
//   - withScores bool
func (_e *MockUniversalClient_Expecter) ZRandMember(ctx interface{}, key interface{}, count interface{}, withScores interface{}) *MockUniversalClient_ZRandMember_Call {
	return &MockUniversalClient_ZRandMember_Call{Call: _e.mock.On("ZRandMember", ctx, key, count, withScores)}
}

func (_c *MockUniversalClient_ZRandMember_Call) Run(run func(ctx context.Context, key string, count int, withScores bool)) *MockUniversalClient_ZRandMember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(bool))
	})
	return _c
}

func (_c *MockUniversalClient_ZRandMember_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_ZRandMember_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRandMember_Call) RunAndReturn(run func(context.Context, string, int, bool) *redis.StringSliceCmd) *MockUniversalClient_ZRandMember_Call {
	_c.Call.Return(run)
	return _c
}

// ZRange provides a mock function with given fields: ctx, key, start, stop
func (_m *MockUniversalClient) ZRange(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRange")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRange'
type MockUniversalClient_ZRange_Call struct {
	*mock.Call
}

// ZRange is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - start int64
//   - stop int64
func (_e *MockUniversalClient_Expecter) ZRange(ctx interface{}, key interface{}, start interface{}, stop interface{}) *MockUniversalClient_ZRange_Call {
	return &MockUniversalClient_ZRange_Call{Call: _e.mock.On("ZRange", ctx, key, start, stop)}
}

func (_c *MockUniversalClient_ZRange_Call) Run(run func(ctx context.Context, key string, start int64, stop int64)) *MockUniversalClient_ZRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_ZRange_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_ZRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRange_Call) RunAndReturn(run func(context.Context, string, int64, int64) *redis.StringSliceCmd) *MockUniversalClient_ZRange_Call {
	_c.Call.Return(run)
	return _c
}

// ZRangeArgs provides a mock function with given fields: ctx, z
func (_m *MockUniversalClient) ZRangeArgs(ctx context.Context, z redis.ZRangeArgs) *redis.StringSliceCmd {
	ret := _m.Called(ctx, z)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeArgs")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, redis.ZRangeArgs) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, z)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRangeArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRangeArgs'
type MockUniversalClient_ZRangeArgs_Call struct {
	*mock.Call
}

// ZRangeArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - z redis.ZRangeArgs
func (_e *MockUniversalClient_Expecter) ZRangeArgs(ctx interface{}, z interface{}) *MockUniversalClient_ZRangeArgs_Call {
	return &MockUniversalClient_ZRangeArgs_Call{Call: _e.mock.On("ZRangeArgs", ctx, z)}
}

func (_c *MockUniversalClient_ZRangeArgs_Call) Run(run func(ctx context.Context, z redis.ZRangeArgs)) *MockUniversalClient_ZRangeArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(redis.ZRangeArgs))
	})
	return _c
}

func (_c *MockUniversalClient_ZRangeArgs_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_ZRangeArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRangeArgs_Call) RunAndReturn(run func(context.Context, redis.ZRangeArgs) *redis.StringSliceCmd) *MockUniversalClient_ZRangeArgs_Call {
	_c.Call.Return(run)
	return _c
}

// ZRangeArgsWithScores provides a mock function with given fields: ctx, z
func (_m *MockUniversalClient) ZRangeArgsWithScores(ctx context.Context, z redis.ZRangeArgs) *redis.ZSliceCmd {
	ret := _m.Called(ctx, z)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeArgsWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, redis.ZRangeArgs) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, z)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRangeArgsWithScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRangeArgsWithScores'
type MockUniversalClient_ZRangeArgsWithScores_Call struct {
	*mock.Call
}

// ZRangeArgsWithScores is a helper method to define mock.On call
//   - ctx context.Context
//   - z redis.ZRangeArgs
func (_e *MockUniversalClient_Expecter) ZRangeArgsWithScores(ctx interface{}, z interface{}) *MockUniversalClient_ZRangeArgsWithScores_Call {
	return &MockUniversalClient_ZRangeArgsWithScores_Call{Call: _e.mock.On("ZRangeArgsWithScores", ctx, z)}
}

func (_c *MockUniversalClient_ZRangeArgsWithScores_Call) Run(run func(ctx context.Context, z redis.ZRangeArgs)) *MockUniversalClient_ZRangeArgsWithScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(redis.ZRangeArgs))
	})
	return _c
}

func (_c *MockUniversalClient_ZRangeArgsWithScores_Call) Return(_a0 *redis.ZSliceCmd) *MockUniversalClient_ZRangeArgsWithScores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRangeArgsWithScores_Call) RunAndReturn(run func(context.Context, redis.ZRangeArgs) *redis.ZSliceCmd) *MockUniversalClient_ZRangeArgsWithScores_Call {
	_c.Call.Return(run)
	return _c
}

// ZRangeByLex provides a mock function with given fields: ctx, key, opt
func (_m *MockUniversalClient) ZRangeByLex(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeByLex")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRangeByLex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRangeByLex'
type MockUniversalClient_ZRangeByLex_Call struct {
	*mock.Call
}

// ZRangeByLex is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - opt *redis.ZRangeBy
func (_e *MockUniversalClient_Expecter) ZRangeByLex(ctx interface{}, key interface{}, opt interface{}) *MockUniversalClient_ZRangeByLex_Call {
	return &MockUniversalClient_ZRangeByLex_Call{Call: _e.mock.On("ZRangeByLex", ctx, key, opt)}
}

func (_c *MockUniversalClient_ZRangeByLex_Call) Run(run func(ctx context.Context, key string, opt *redis.ZRangeBy)) *MockUniversalClient_ZRangeByLex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*redis.ZRangeBy))
	})
	return _c
}

func (_c *MockUniversalClient_ZRangeByLex_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_ZRangeByLex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRangeByLex_Call) RunAndReturn(run func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd) *MockUniversalClient_ZRangeByLex_Call {
	_c.Call.Return(run)
	return _c
}

// ZRangeByScore provides a mock function with given fields: ctx, key, opt
func (_m *MockUniversalClient) ZRangeByScore(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeByScore")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRangeByScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRangeByScore'
type MockUniversalClient_ZRangeByScore_Call struct {
	*mock.Call
}

// ZRangeByScore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - opt *redis.ZRangeBy
func (_e *MockUniversalClient_Expecter) ZRangeByScore(ctx interface{}, key interface{}, opt interface{}) *MockUniversalClient_ZRangeByScore_Call {
	return &MockUniversalClient_ZRangeByScore_Call{Call: _e.mock.On("ZRangeByScore", ctx, key, opt)}
}

func (_c *MockUniversalClient_ZRangeByScore_Call) Run(run func(ctx context.Context, key string, opt *redis.ZRangeBy)) *MockUniversalClient_ZRangeByScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*redis.ZRangeBy))
	})
	return _c
}

func (_c *MockUniversalClient_ZRangeByScore_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_ZRangeByScore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRangeByScore_Call) RunAndReturn(run func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd) *MockUniversalClient_ZRangeByScore_Call {
	_c.Call.Return(run)
	return _c
}

// ZRangeByScoreWithScores provides a mock function with given fields: ctx, key, opt
func (_m *MockUniversalClient) ZRangeByScoreWithScores(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeByScoreWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZRangeBy) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRangeByScoreWithScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRangeByScoreWithScores'
type MockUniversalClient_ZRangeByScoreWithScores_Call struct {
	*mock.Call
}

// ZRangeByScoreWithScores is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - opt *redis.ZRangeBy
func (_e *MockUniversalClient_Expecter) ZRangeByScoreWithScores(ctx interface{}, key interface{}, opt interface{}) *MockUniversalClient_ZRangeByScoreWithScores_Call {
	return &MockUniversalClient_ZRangeByScoreWithScores_Call{Call: _e.mock.On("ZRangeByScoreWithScores", ctx, key, opt)}
}

func (_c *MockUniversalClient_ZRangeByScoreWithScores_Call) Run(run func(ctx context.Context, key string, opt *redis.ZRangeBy)) *MockUniversalClient_ZRangeByScoreWithScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*redis.ZRangeBy))
	})
	return _c
}

func (_c *MockUniversalClient_ZRangeByScoreWithScores_Call) Return(_a0 *redis.ZSliceCmd) *MockUniversalClient_ZRangeByScoreWithScores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRangeByScoreWithScores_Call) RunAndReturn(run func(context.Context, string, *redis.ZRangeBy) *redis.ZSliceCmd) *MockUniversalClient_ZRangeByScoreWithScores_Call {
	_c.Call.Return(run)
	return _c
}

// ZRangeStore provides a mock function with given fields: ctx, dst, z
func (_m *MockUniversalClient) ZRangeStore(ctx context.Context, dst string, z redis.ZRangeArgs) *redis.IntCmd {
	ret := _m.Called(ctx, dst, z)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, redis.ZRangeArgs) *redis.IntCmd); ok {
		r0 = rf(ctx, dst, z)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRangeStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRangeStore'
type MockUniversalClient_ZRangeStore_Call struct {
	*mock.Call
}

// ZRangeStore is a helper method to define mock.On call
//   - ctx context.Context
//   - dst string
//   - z redis.ZRangeArgs
func (_e *MockUniversalClient_Expecter) ZRangeStore(ctx interface{}, dst interface{}, z interface{}) *MockUniversalClient_ZRangeStore_Call {
	return &MockUniversalClient_ZRangeStore_Call{Call: _e.mock.On("ZRangeStore", ctx, dst, z)}
}

func (_c *MockUniversalClient_ZRangeStore_Call) Run(run func(ctx context.Context, dst string, z redis.ZRangeArgs)) *MockUniversalClient_ZRangeStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(redis.ZRangeArgs))
	})
	return _c
}

func (_c *MockUniversalClient_ZRangeStore_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZRangeStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRangeStore_Call) RunAndReturn(run func(context.Context, string, redis.ZRangeArgs) *redis.IntCmd) *MockUniversalClient_ZRangeStore_Call {
	_c.Call.Return(run)
	return _c
}

// ZRangeWithScores provides a mock function with given fields: ctx, key, start, stop
func (_m *MockUniversalClient) ZRangeWithScores(ctx context.Context, key string, start int64, stop int64) *redis.ZSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRangeWithScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRangeWithScores'
type MockUniversalClient_ZRangeWithScores_Call struct {
	*mock.Call
}

// ZRangeWithScores is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - start int64
//   - stop int64
func (_e *MockUniversalClient_Expecter) ZRangeWithScores(ctx interface{}, key interface{}, start interface{}, stop interface{}) *MockUniversalClient_ZRangeWithScores_Call {
	return &MockUniversalClient_ZRangeWithScores_Call{Call: _e.mock.On("ZRangeWithScores", ctx, key, start, stop)}
}

func (_c *MockUniversalClient_ZRangeWithScores_Call) Run(run func(ctx context.Context, key string, start int64, stop int64)) *MockUniversalClient_ZRangeWithScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_ZRangeWithScores_Call) Return(_a0 *redis.ZSliceCmd) *MockUniversalClient_ZRangeWithScores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRangeWithScores_Call) RunAndReturn(run func(context.Context, string, int64, int64) *redis.ZSliceCmd) *MockUniversalClient_ZRangeWithScores_Call {
	_c.Call.Return(run)
	return _c
}

// ZRank provides a mock function with given fields: ctx, key, member
func (_m *MockUniversalClient) ZRank(ctx context.Context, key string, member string) *redis.IntCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZRank")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRank_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRank'
type MockUniversalClient_ZRank_Call struct {
	*mock.Call
}

// ZRank is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member string
func (_e *MockUniversalClient_Expecter) ZRank(ctx interface{}, key interface{}, member interface{}) *MockUniversalClient_ZRank_Call {
	return &MockUniversalClient_ZRank_Call{Call: _e.mock.On("ZRank", ctx, key, member)}
}

func (_c *MockUniversalClient_ZRank_Call) Run(run func(ctx context.Context, key string, member string)) *MockUniversalClient_ZRank_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ZRank_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZRank_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRank_Call) RunAndReturn(run func(context.Context, string, string) *redis.IntCmd) *MockUniversalClient_ZRank_Call {
	_c.Call.Return(run)
	return _c
}

// ZRem provides a mock function with given fields: ctx, key, members
func (_m *MockUniversalClient) ZRem(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZRem")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRem'
type MockUniversalClient_ZRem_Call struct {
	*mock.Call
}

// ZRem is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...interface{}
func (_e *MockUniversalClient_Expecter) ZRem(ctx interface{}, key interface{}, members ...interface{}) *MockUniversalClient_ZRem_Call {
	return &MockUniversalClient_ZRem_Call{Call: _e.mock.On("ZRem",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockUniversalClient_ZRem_Call) Run(run func(ctx context.Context, key string, members ...interface{})) *MockUniversalClient_ZRem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockUniversalClient_ZRem_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZRem_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRem_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *redis.IntCmd) *MockUniversalClient_ZRem_Call {
	_c.Call.Return(run)
	return _c
}

// ZRemRangeByLex provides a mock function with given fields: ctx, key, min, max
func (_m *MockUniversalClient) ZRemRangeByLex(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(ctx, key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZRemRangeByLex")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRemRangeByLex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRemRangeByLex'
type MockUniversalClient_ZRemRangeByLex_Call struct {
	*mock.Call
}

// ZRemRangeByLex is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - min string
//   - max string
func (_e *MockUniversalClient_Expecter) ZRemRangeByLex(ctx interface{}, key interface{}, min interface{}, max interface{}) *MockUniversalClient_ZRemRangeByLex_Call {
	return &MockUniversalClient_ZRemRangeByLex_Call{Call: _e.mock.On("ZRemRangeByLex", ctx, key, min, max)}
}

func (_c *MockUniversalClient_ZRemRangeByLex_Call) Run(run func(ctx context.Context, key string, min string, max string)) *MockUniversalClient_ZRemRangeByLex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ZRemRangeByLex_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZRemRangeByLex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRemRangeByLex_Call) RunAndReturn(run func(context.Context, string, string, string) *redis.IntCmd) *MockUniversalClient_ZRemRangeByLex_Call {
	_c.Call.Return(run)
	return _c
}

// ZRemRangeByRank provides a mock function with given fields: ctx, key, start, stop
func (_m *MockUniversalClient) ZRemRangeByRank(ctx context.Context, key string, start int64, stop int64) *redis.IntCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRemRangeByRank")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.IntCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRemRangeByRank_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRemRangeByRank'
type MockUniversalClient_ZRemRangeByRank_Call struct {
	*mock.Call
}

// ZRemRangeByRank is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - start int64
//   - stop int64
func (_e *MockUniversalClient_Expecter) ZRemRangeByRank(ctx interface{}, key interface{}, start interface{}, stop interface{}) *MockUniversalClient_ZRemRangeByRank_Call {
	return &MockUniversalClient_ZRemRangeByRank_Call{Call: _e.mock.On("ZRemRangeByRank", ctx, key, start, stop)}
}

func (_c *MockUniversalClient_ZRemRangeByRank_Call) Run(run func(ctx context.Context, key string, start int64, stop int64)) *MockUniversalClient_ZRemRangeByRank_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_ZRemRangeByRank_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZRemRangeByRank_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRemRangeByRank_Call) RunAndReturn(run func(context.Context, string, int64, int64) *redis.IntCmd) *MockUniversalClient_ZRemRangeByRank_Call {
	_c.Call.Return(run)
	return _c
}

// ZRemRangeByScore provides a mock function with given fields: ctx, key, min, max
func (_m *MockUniversalClient) ZRemRangeByScore(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(ctx, key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZRemRangeByScore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRemRangeByScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRemRangeByScore'
type MockUniversalClient_ZRemRangeByScore_Call struct {
	*mock.Call
}

// ZRemRangeByScore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - min string
//   - max string
func (_e *MockUniversalClient_Expecter) ZRemRangeByScore(ctx interface{}, key interface{}, min interface{}, max interface{}) *MockUniversalClient_ZRemRangeByScore_Call {
	return &MockUniversalClient_ZRemRangeByScore_Call{Call: _e.mock.On("ZRemRangeByScore", ctx, key, min, max)}
}

func (_c *MockUniversalClient_ZRemRangeByScore_Call) Run(run func(ctx context.Context, key string, min string, max string)) *MockUniversalClient_ZRemRangeByScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ZRemRangeByScore_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZRemRangeByScore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRemRangeByScore_Call) RunAndReturn(run func(context.Context, string, string, string) *redis.IntCmd) *MockUniversalClient_ZRemRangeByScore_Call {
	_c.Call.Return(run)
	return _c
}

// ZRevRange provides a mock function with given fields: ctx, key, start, stop
func (_m *MockUniversalClient) ZRevRange(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRange")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRevRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRevRange'
type MockUniversalClient_ZRevRange_Call struct {
	*mock.Call
}

// ZRevRange is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - start int64
//   - stop int64
func (_e *MockUniversalClient_Expecter) ZRevRange(ctx interface{}, key interface{}, start interface{}, stop interface{}) *MockUniversalClient_ZRevRange_Call {
	return &MockUniversalClient_ZRevRange_Call{Call: _e.mock.On("ZRevRange", ctx, key, start, stop)}
}

func (_c *MockUniversalClient_ZRevRange_Call) Run(run func(ctx context.Context, key string, start int64, stop int64)) *MockUniversalClient_ZRevRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_ZRevRange_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_ZRevRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRevRange_Call) RunAndReturn(run func(context.Context, string, int64, int64) *redis.StringSliceCmd) *MockUniversalClient_ZRevRange_Call {
	_c.Call.Return(run)
	return _c
}

// ZRevRangeByLex provides a mock function with given fields: ctx, key, opt
func (_m *MockUniversalClient) ZRevRangeByLex(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeByLex")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRevRangeByLex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRevRangeByLex'
type MockUniversalClient_ZRevRangeByLex_Call struct {
	*mock.Call
}

// ZRevRangeByLex is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - opt *redis.ZRangeBy
func (_e *MockUniversalClient_Expecter) ZRevRangeByLex(ctx interface{}, key interface{}, opt interface{}) *MockUniversalClient_ZRevRangeByLex_Call {
	return &MockUniversalClient_ZRevRangeByLex_Call{Call: _e.mock.On("ZRevRangeByLex", ctx, key, opt)}
}

func (_c *MockUniversalClient_ZRevRangeByLex_Call) Run(run func(ctx context.Context, key string, opt *redis.ZRangeBy)) *MockUniversalClient_ZRevRangeByLex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*redis.ZRangeBy))
	})
	return _c
}

func (_c *MockUniversalClient_ZRevRangeByLex_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_ZRevRangeByLex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRevRangeByLex_Call) RunAndReturn(run func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd) *MockUniversalClient_ZRevRangeByLex_Call {
	_c.Call.Return(run)
	return _c
}

// ZRevRangeByScore provides a mock function with given fields: ctx, key, opt
func (_m *MockUniversalClient) ZRevRangeByScore(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeByScore")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRevRangeByScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRevRangeByScore'
type MockUniversalClient_ZRevRangeByScore_Call struct {
	*mock.Call
}

// ZRevRangeByScore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - opt *redis.ZRangeBy
func (_e *MockUniversalClient_Expecter) ZRevRangeByScore(ctx interface{}, key interface{}, opt interface{}) *MockUniversalClient_ZRevRangeByScore_Call {
	return &MockUniversalClient_ZRevRangeByScore_Call{Call: _e.mock.On("ZRevRangeByScore", ctx, key, opt)}
}

func (_c *MockUniversalClient_ZRevRangeByScore_Call) Run(run func(ctx context.Context, key string, opt *redis.ZRangeBy)) *MockUniversalClient_ZRevRangeByScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*redis.ZRangeBy))
	})
	return _c
}

func (_c *MockUniversalClient_ZRevRangeByScore_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_ZRevRangeByScore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRevRangeByScore_Call) RunAndReturn(run func(context.Context, string, *redis.ZRangeBy) *redis.StringSliceCmd) *MockUniversalClient_ZRevRangeByScore_Call {
	_c.Call.Return(run)
	return _c
}

// ZRevRangeByScoreWithScores provides a mock function with given fields: ctx, key, opt
func (_m *MockUniversalClient) ZRevRangeByScoreWithScores(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeByScoreWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZRangeBy) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRevRangeByScoreWithScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRevRangeByScoreWithScores'
type MockUniversalClient_ZRevRangeByScoreWithScores_Call struct {
	*mock.Call
}

// ZRevRangeByScoreWithScores is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - opt *redis.ZRangeBy
func (_e *MockUniversalClient_Expecter) ZRevRangeByScoreWithScores(ctx interface{}, key interface{}, opt interface{}) *MockUniversalClient_ZRevRangeByScoreWithScores_Call {
	return &MockUniversalClient_ZRevRangeByScoreWithScores_Call{Call: _e.mock.On("ZRevRangeByScoreWithScores", ctx, key, opt)}
}

func (_c *MockUniversalClient_ZRevRangeByScoreWithScores_Call) Run(run func(ctx context.Context, key string, opt *redis.ZRangeBy)) *MockUniversalClient_ZRevRangeByScoreWithScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*redis.ZRangeBy))
	})
	return _c
}

func (_c *MockUniversalClient_ZRevRangeByScoreWithScores_Call) Return(_a0 *redis.ZSliceCmd) *MockUniversalClient_ZRevRangeByScoreWithScores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRevRangeByScoreWithScores_Call) RunAndReturn(run func(context.Context, string, *redis.ZRangeBy) *redis.ZSliceCmd) *MockUniversalClient_ZRevRangeByScoreWithScores_Call {
	_c.Call.Return(run)
	return _c
}

// ZRevRangeWithScores provides a mock function with given fields: ctx, key, start, stop
func (_m *MockUniversalClient) ZRevRangeWithScores(ctx context.Context, key string, start int64, stop int64) *redis.ZSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRevRangeWithScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRevRangeWithScores'
type MockUniversalClient_ZRevRangeWithScores_Call struct {
	*mock.Call
}

// ZRevRangeWithScores is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - start int64
//   - stop int64
func (_e *MockUniversalClient_Expecter) ZRevRangeWithScores(ctx interface{}, key interface{}, start interface{}, stop interface{}) *MockUniversalClient_ZRevRangeWithScores_Call {
	return &MockUniversalClient_ZRevRangeWithScores_Call{Call: _e.mock.On("ZRevRangeWithScores", ctx, key, start, stop)}
}

func (_c *MockUniversalClient_ZRevRangeWithScores_Call) Run(run func(ctx context.Context, key string, start int64, stop int64)) *MockUniversalClient_ZRevRangeWithScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_ZRevRangeWithScores_Call) Return(_a0 *redis.ZSliceCmd) *MockUniversalClient_ZRevRangeWithScores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRevRangeWithScores_Call) RunAndReturn(run func(context.Context, string, int64, int64) *redis.ZSliceCmd) *MockUniversalClient_ZRevRangeWithScores_Call {
	_c.Call.Return(run)
	return _c
}

// ZRevRank provides a mock function with given fields: ctx, key, member
func (_m *MockUniversalClient) ZRevRank(ctx context.Context, key string, member string) *redis.IntCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRank")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.IntCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZRevRank_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRevRank'
type MockUniversalClient_ZRevRank_Call struct {
	*mock.Call
}

// ZRevRank is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member string
func (_e *MockUniversalClient_Expecter) ZRevRank(ctx interface{}, key interface{}, member interface{}) *MockUniversalClient_ZRevRank_Call {
	return &MockUniversalClient_ZRevRank_Call{Call: _e.mock.On("ZRevRank", ctx, key, member)}
}

func (_c *MockUniversalClient_ZRevRank_Call) Run(run func(ctx context.Context, key string, member string)) *MockUniversalClient_ZRevRank_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ZRevRank_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZRevRank_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZRevRank_Call) RunAndReturn(run func(context.Context, string, string) *redis.IntCmd) *MockUniversalClient_ZRevRank_Call {
	_c.Call.Return(run)
	return _c
}

// ZScan provides a mock function with given fields: ctx, key, cursor, match, count
func (_m *MockUniversalClient) ZScan(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(ctx, key, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for ZScan")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(ctx, key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZScan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZScan'
type MockUniversalClient_ZScan_Call struct {
	*mock.Call
}

// ZScan is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - cursor uint64
//   - match string
//   - count int64
func (_e *MockUniversalClient_Expecter) ZScan(ctx interface{}, key interface{}, cursor interface{}, match interface{}, count interface{}) *MockUniversalClient_ZScan_Call {
	return &MockUniversalClient_ZScan_Call{Call: _e.mock.On("ZScan", ctx, key, cursor, match, count)}
}

func (_c *MockUniversalClient_ZScan_Call) Run(run func(ctx context.Context, key string, cursor uint64, match string, count int64)) *MockUniversalClient_ZScan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint64), args[3].(string), args[4].(int64))
	})
	return _c
}

func (_c *MockUniversalClient_ZScan_Call) Return(_a0 *redis.ScanCmd) *MockUniversalClient_ZScan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZScan_Call) RunAndReturn(run func(context.Context, string, uint64, string, int64) *redis.ScanCmd) *MockUniversalClient_ZScan_Call {
	_c.Call.Return(run)
	return _c
}

// ZScore provides a mock function with given fields: ctx, key, member
func (_m *MockUniversalClient) ZScore(ctx context.Context, key string, member string) *redis.FloatCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZScore")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *redis.FloatCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZScore'
type MockUniversalClient_ZScore_Call struct {
	*mock.Call
}

// ZScore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member string
func (_e *MockUniversalClient_Expecter) ZScore(ctx interface{}, key interface{}, member interface{}) *MockUniversalClient_ZScore_Call {
	return &MockUniversalClient_ZScore_Call{Call: _e.mock.On("ZScore", ctx, key, member)}
}

func (_c *MockUniversalClient_ZScore_Call) Run(run func(ctx context.Context, key string, member string)) *MockUniversalClient_ZScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockUniversalClient_ZScore_Call) Return(_a0 *redis.FloatCmd) *MockUniversalClient_ZScore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZScore_Call) RunAndReturn(run func(context.Context, string, string) *redis.FloatCmd) *MockUniversalClient_ZScore_Call {
	_c.Call.Return(run)
	return _c
}

// ZUnion provides a mock function with given fields: ctx, store
func (_m *MockUniversalClient) ZUnion(ctx context.Context, store redis.ZStore) *redis.StringSliceCmd {
	ret := _m.Called(ctx, store)

	if len(ret) == 0 {
		panic("no return value specified for ZUnion")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, redis.ZStore) *redis.StringSliceCmd); ok {
		r0 = rf(ctx, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZUnion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZUnion'
type MockUniversalClient_ZUnion_Call struct {
	*mock.Call
}

// ZUnion is a helper method to define mock.On call
//   - ctx context.Context
//   - store redis.ZStore
func (_e *MockUniversalClient_Expecter) ZUnion(ctx interface{}, store interface{}) *MockUniversalClient_ZUnion_Call {
	return &MockUniversalClient_ZUnion_Call{Call: _e.mock.On("ZUnion", ctx, store)}
}

func (_c *MockUniversalClient_ZUnion_Call) Run(run func(ctx context.Context, store redis.ZStore)) *MockUniversalClient_ZUnion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(redis.ZStore))
	})
	return _c
}

func (_c *MockUniversalClient_ZUnion_Call) Return(_a0 *redis.StringSliceCmd) *MockUniversalClient_ZUnion_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZUnion_Call) RunAndReturn(run func(context.Context, redis.ZStore) *redis.StringSliceCmd) *MockUniversalClient_ZUnion_Call {
	_c.Call.Return(run)
	return _c
}

// ZUnionStore provides a mock function with given fields: ctx, dest, store
func (_m *MockUniversalClient) ZUnionStore(ctx context.Context, dest string, store *redis.ZStore) *redis.IntCmd {
	ret := _m.Called(ctx, dest, store)

	if len(ret) == 0 {
		panic("no return value specified for ZUnionStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *redis.ZStore) *redis.IntCmd); ok {
		r0 = rf(ctx, dest, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZUnionStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZUnionStore'
type MockUniversalClient_ZUnionStore_Call struct {
	*mock.Call
}

// ZUnionStore is a helper method to define mock.On call
//   - ctx context.Context
//   - dest string
//   - store *redis.ZStore
func (_e *MockUniversalClient_Expecter) ZUnionStore(ctx interface{}, dest interface{}, store interface{}) *MockUniversalClient_ZUnionStore_Call {
	return &MockUniversalClient_ZUnionStore_Call{Call: _e.mock.On("ZUnionStore", ctx, dest, store)}
}

func (_c *MockUniversalClient_ZUnionStore_Call) Run(run func(ctx context.Context, dest string, store *redis.ZStore)) *MockUniversalClient_ZUnionStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*redis.ZStore))
	})
	return _c
}

func (_c *MockUniversalClient_ZUnionStore_Call) Return(_a0 *redis.IntCmd) *MockUniversalClient_ZUnionStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZUnionStore_Call) RunAndReturn(run func(context.Context, string, *redis.ZStore) *redis.IntCmd) *MockUniversalClient_ZUnionStore_Call {
	_c.Call.Return(run)
	return _c
}

// ZUnionWithScores provides a mock function with given fields: ctx, store
func (_m *MockUniversalClient) ZUnionWithScores(ctx context.Context, store redis.ZStore) *redis.ZSliceCmd {
	ret := _m.Called(ctx, store)

	if len(ret) == 0 {
		panic("no return value specified for ZUnionWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, redis.ZStore) *redis.ZSliceCmd); ok {
		r0 = rf(ctx, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// MockUniversalClient_ZUnionWithScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZUnionWithScores'
type MockUniversalClient_ZUnionWithScores_Call struct {
	*mock.Call
}

// ZUnionWithScores is a helper method to define mock.On call
//   - ctx context.Context
//   - store redis.ZStore
func (_e *MockUniversalClient_Expecter) ZUnionWithScores(ctx interface{}, store interface{}) *MockUniversalClient_ZUnionWithScores_Call {
	return &MockUniversalClient_ZUnionWithScores_Call{Call: _e.mock.On("ZUnionWithScores", ctx, store)}
}

func (_c *MockUniversalClient_ZUnionWithScores_Call) Run(run func(ctx context.Context, store redis.ZStore)) *MockUniversalClient_ZUnionWithScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(redis.ZStore))
	})
	return _c
}

func (_c *MockUniversalClient_ZUnionWithScores_Call) Return(_a0 *redis.ZSliceCmd) *MockUniversalClient_ZUnionWithScores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUniversalClient_ZUnionWithScores_Call) RunAndReturn(run func(context.Context, redis.ZStore) *redis.ZSliceCmd) *MockUniversalClient_ZUnionWithScores_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUniversalClient creates a new instance of MockUniversalClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUniversalClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUniversalClient {
	mock := &MockUniversalClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
