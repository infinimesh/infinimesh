// Code generated by mockery v2.40.1. DO NOT EDIT.

package driver_mocks

import (
	context "context"

	driver "github.com/arangodb/go-driver"
	mock "github.com/stretchr/testify/mock"
)

// MockGraph is an autogenerated mock type for the Graph type
type MockGraph struct {
	mock.Mock
}

type MockGraph_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGraph) EXPECT() *MockGraph_Expecter {
	return &MockGraph_Expecter{mock: &_m.Mock}
}

// CreateEdgeCollection provides a mock function with given fields: ctx, collection, constraints
func (_m *MockGraph) CreateEdgeCollection(ctx context.Context, collection string, constraints driver.VertexConstraints) (driver.Collection, error) {
	ret := _m.Called(ctx, collection, constraints)

	if len(ret) == 0 {
		panic("no return value specified for CreateEdgeCollection")
	}

	var r0 driver.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, driver.VertexConstraints) (driver.Collection, error)); ok {
		return rf(ctx, collection, constraints)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, driver.VertexConstraints) driver.Collection); ok {
		r0 = rf(ctx, collection, constraints)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, driver.VertexConstraints) error); ok {
		r1 = rf(ctx, collection, constraints)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGraph_CreateEdgeCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateEdgeCollection'
type MockGraph_CreateEdgeCollection_Call struct {
	*mock.Call
}

// CreateEdgeCollection is a helper method to define mock.On call
//   - ctx context.Context
//   - collection string
//   - constraints driver.VertexConstraints
func (_e *MockGraph_Expecter) CreateEdgeCollection(ctx interface{}, collection interface{}, constraints interface{}) *MockGraph_CreateEdgeCollection_Call {
	return &MockGraph_CreateEdgeCollection_Call{Call: _e.mock.On("CreateEdgeCollection", ctx, collection, constraints)}
}

func (_c *MockGraph_CreateEdgeCollection_Call) Run(run func(ctx context.Context, collection string, constraints driver.VertexConstraints)) *MockGraph_CreateEdgeCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(driver.VertexConstraints))
	})
	return _c
}

func (_c *MockGraph_CreateEdgeCollection_Call) Return(_a0 driver.Collection, _a1 error) *MockGraph_CreateEdgeCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGraph_CreateEdgeCollection_Call) RunAndReturn(run func(context.Context, string, driver.VertexConstraints) (driver.Collection, error)) *MockGraph_CreateEdgeCollection_Call {
	_c.Call.Return(run)
	return _c
}

// CreateEdgeCollectionWithOptions provides a mock function with given fields: ctx, collection, constraints, options
func (_m *MockGraph) CreateEdgeCollectionWithOptions(ctx context.Context, collection string, constraints driver.VertexConstraints, options driver.CreateEdgeCollectionOptions) (driver.Collection, error) {
	ret := _m.Called(ctx, collection, constraints, options)

	if len(ret) == 0 {
		panic("no return value specified for CreateEdgeCollectionWithOptions")
	}

	var r0 driver.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, driver.VertexConstraints, driver.CreateEdgeCollectionOptions) (driver.Collection, error)); ok {
		return rf(ctx, collection, constraints, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, driver.VertexConstraints, driver.CreateEdgeCollectionOptions) driver.Collection); ok {
		r0 = rf(ctx, collection, constraints, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, driver.VertexConstraints, driver.CreateEdgeCollectionOptions) error); ok {
		r1 = rf(ctx, collection, constraints, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGraph_CreateEdgeCollectionWithOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateEdgeCollectionWithOptions'
type MockGraph_CreateEdgeCollectionWithOptions_Call struct {
	*mock.Call
}

// CreateEdgeCollectionWithOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - collection string
//   - constraints driver.VertexConstraints
//   - options driver.CreateEdgeCollectionOptions
func (_e *MockGraph_Expecter) CreateEdgeCollectionWithOptions(ctx interface{}, collection interface{}, constraints interface{}, options interface{}) *MockGraph_CreateEdgeCollectionWithOptions_Call {
	return &MockGraph_CreateEdgeCollectionWithOptions_Call{Call: _e.mock.On("CreateEdgeCollectionWithOptions", ctx, collection, constraints, options)}
}

func (_c *MockGraph_CreateEdgeCollectionWithOptions_Call) Run(run func(ctx context.Context, collection string, constraints driver.VertexConstraints, options driver.CreateEdgeCollectionOptions)) *MockGraph_CreateEdgeCollectionWithOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(driver.VertexConstraints), args[3].(driver.CreateEdgeCollectionOptions))
	})
	return _c
}

func (_c *MockGraph_CreateEdgeCollectionWithOptions_Call) Return(_a0 driver.Collection, _a1 error) *MockGraph_CreateEdgeCollectionWithOptions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGraph_CreateEdgeCollectionWithOptions_Call) RunAndReturn(run func(context.Context, string, driver.VertexConstraints, driver.CreateEdgeCollectionOptions) (driver.Collection, error)) *MockGraph_CreateEdgeCollectionWithOptions_Call {
	_c.Call.Return(run)
	return _c
}

// CreateVertexCollection provides a mock function with given fields: ctx, collection
func (_m *MockGraph) CreateVertexCollection(ctx context.Context, collection string) (driver.Collection, error) {
	ret := _m.Called(ctx, collection)

	if len(ret) == 0 {
		panic("no return value specified for CreateVertexCollection")
	}

	var r0 driver.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (driver.Collection, error)); ok {
		return rf(ctx, collection)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) driver.Collection); ok {
		r0 = rf(ctx, collection)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, collection)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGraph_CreateVertexCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateVertexCollection'
type MockGraph_CreateVertexCollection_Call struct {
	*mock.Call
}

// CreateVertexCollection is a helper method to define mock.On call
//   - ctx context.Context
//   - collection string
func (_e *MockGraph_Expecter) CreateVertexCollection(ctx interface{}, collection interface{}) *MockGraph_CreateVertexCollection_Call {
	return &MockGraph_CreateVertexCollection_Call{Call: _e.mock.On("CreateVertexCollection", ctx, collection)}
}

func (_c *MockGraph_CreateVertexCollection_Call) Run(run func(ctx context.Context, collection string)) *MockGraph_CreateVertexCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGraph_CreateVertexCollection_Call) Return(_a0 driver.Collection, _a1 error) *MockGraph_CreateVertexCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGraph_CreateVertexCollection_Call) RunAndReturn(run func(context.Context, string) (driver.Collection, error)) *MockGraph_CreateVertexCollection_Call {
	_c.Call.Return(run)
	return _c
}

// CreateVertexCollectionWithOptions provides a mock function with given fields: ctx, collection, options
func (_m *MockGraph) CreateVertexCollectionWithOptions(ctx context.Context, collection string, options driver.CreateVertexCollectionOptions) (driver.Collection, error) {
	ret := _m.Called(ctx, collection, options)

	if len(ret) == 0 {
		panic("no return value specified for CreateVertexCollectionWithOptions")
	}

	var r0 driver.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, driver.CreateVertexCollectionOptions) (driver.Collection, error)); ok {
		return rf(ctx, collection, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, driver.CreateVertexCollectionOptions) driver.Collection); ok {
		r0 = rf(ctx, collection, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, driver.CreateVertexCollectionOptions) error); ok {
		r1 = rf(ctx, collection, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGraph_CreateVertexCollectionWithOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateVertexCollectionWithOptions'
type MockGraph_CreateVertexCollectionWithOptions_Call struct {
	*mock.Call
}

// CreateVertexCollectionWithOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - collection string
//   - options driver.CreateVertexCollectionOptions
func (_e *MockGraph_Expecter) CreateVertexCollectionWithOptions(ctx interface{}, collection interface{}, options interface{}) *MockGraph_CreateVertexCollectionWithOptions_Call {
	return &MockGraph_CreateVertexCollectionWithOptions_Call{Call: _e.mock.On("CreateVertexCollectionWithOptions", ctx, collection, options)}
}

func (_c *MockGraph_CreateVertexCollectionWithOptions_Call) Run(run func(ctx context.Context, collection string, options driver.CreateVertexCollectionOptions)) *MockGraph_CreateVertexCollectionWithOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(driver.CreateVertexCollectionOptions))
	})
	return _c
}

func (_c *MockGraph_CreateVertexCollectionWithOptions_Call) Return(_a0 driver.Collection, _a1 error) *MockGraph_CreateVertexCollectionWithOptions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGraph_CreateVertexCollectionWithOptions_Call) RunAndReturn(run func(context.Context, string, driver.CreateVertexCollectionOptions) (driver.Collection, error)) *MockGraph_CreateVertexCollectionWithOptions_Call {
	_c.Call.Return(run)
	return _c
}

// EdgeCollection provides a mock function with given fields: ctx, name
func (_m *MockGraph) EdgeCollection(ctx context.Context, name string) (driver.Collection, driver.VertexConstraints, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for EdgeCollection")
	}

	var r0 driver.Collection
	var r1 driver.VertexConstraints
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (driver.Collection, driver.VertexConstraints, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) driver.Collection); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) driver.VertexConstraints); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Get(1).(driver.VertexConstraints)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string) error); ok {
		r2 = rf(ctx, name)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockGraph_EdgeCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EdgeCollection'
type MockGraph_EdgeCollection_Call struct {
	*mock.Call
}

// EdgeCollection is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockGraph_Expecter) EdgeCollection(ctx interface{}, name interface{}) *MockGraph_EdgeCollection_Call {
	return &MockGraph_EdgeCollection_Call{Call: _e.mock.On("EdgeCollection", ctx, name)}
}

func (_c *MockGraph_EdgeCollection_Call) Run(run func(ctx context.Context, name string)) *MockGraph_EdgeCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGraph_EdgeCollection_Call) Return(_a0 driver.Collection, _a1 driver.VertexConstraints, _a2 error) *MockGraph_EdgeCollection_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockGraph_EdgeCollection_Call) RunAndReturn(run func(context.Context, string) (driver.Collection, driver.VertexConstraints, error)) *MockGraph_EdgeCollection_Call {
	_c.Call.Return(run)
	return _c
}

// EdgeCollectionExists provides a mock function with given fields: ctx, name
func (_m *MockGraph) EdgeCollectionExists(ctx context.Context, name string) (bool, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for EdgeCollectionExists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGraph_EdgeCollectionExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EdgeCollectionExists'
type MockGraph_EdgeCollectionExists_Call struct {
	*mock.Call
}

// EdgeCollectionExists is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockGraph_Expecter) EdgeCollectionExists(ctx interface{}, name interface{}) *MockGraph_EdgeCollectionExists_Call {
	return &MockGraph_EdgeCollectionExists_Call{Call: _e.mock.On("EdgeCollectionExists", ctx, name)}
}

func (_c *MockGraph_EdgeCollectionExists_Call) Run(run func(ctx context.Context, name string)) *MockGraph_EdgeCollectionExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGraph_EdgeCollectionExists_Call) Return(_a0 bool, _a1 error) *MockGraph_EdgeCollectionExists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGraph_EdgeCollectionExists_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *MockGraph_EdgeCollectionExists_Call {
	_c.Call.Return(run)
	return _c
}

// EdgeCollections provides a mock function with given fields: ctx
func (_m *MockGraph) EdgeCollections(ctx context.Context) ([]driver.Collection, []driver.VertexConstraints, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for EdgeCollections")
	}

	var r0 []driver.Collection
	var r1 []driver.VertexConstraints
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]driver.Collection, []driver.VertexConstraints, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []driver.Collection); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]driver.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) []driver.VertexConstraints); ok {
		r1 = rf(ctx)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]driver.VertexConstraints)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context) error); ok {
		r2 = rf(ctx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockGraph_EdgeCollections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EdgeCollections'
type MockGraph_EdgeCollections_Call struct {
	*mock.Call
}

// EdgeCollections is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockGraph_Expecter) EdgeCollections(ctx interface{}) *MockGraph_EdgeCollections_Call {
	return &MockGraph_EdgeCollections_Call{Call: _e.mock.On("EdgeCollections", ctx)}
}

func (_c *MockGraph_EdgeCollections_Call) Run(run func(ctx context.Context)) *MockGraph_EdgeCollections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockGraph_EdgeCollections_Call) Return(_a0 []driver.Collection, _a1 []driver.VertexConstraints, _a2 error) *MockGraph_EdgeCollections_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockGraph_EdgeCollections_Call) RunAndReturn(run func(context.Context) ([]driver.Collection, []driver.VertexConstraints, error)) *MockGraph_EdgeCollections_Call {
	_c.Call.Return(run)
	return _c
}

// EdgeDefinitions provides a mock function with given fields:
func (_m *MockGraph) EdgeDefinitions() []driver.EdgeDefinition {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for EdgeDefinitions")
	}

	var r0 []driver.EdgeDefinition
	if rf, ok := ret.Get(0).(func() []driver.EdgeDefinition); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]driver.EdgeDefinition)
		}
	}

	return r0
}

// MockGraph_EdgeDefinitions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EdgeDefinitions'
type MockGraph_EdgeDefinitions_Call struct {
	*mock.Call
}

// EdgeDefinitions is a helper method to define mock.On call
func (_e *MockGraph_Expecter) EdgeDefinitions() *MockGraph_EdgeDefinitions_Call {
	return &MockGraph_EdgeDefinitions_Call{Call: _e.mock.On("EdgeDefinitions")}
}

func (_c *MockGraph_EdgeDefinitions_Call) Run(run func()) *MockGraph_EdgeDefinitions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGraph_EdgeDefinitions_Call) Return(_a0 []driver.EdgeDefinition) *MockGraph_EdgeDefinitions_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGraph_EdgeDefinitions_Call) RunAndReturn(run func() []driver.EdgeDefinition) *MockGraph_EdgeDefinitions_Call {
	_c.Call.Return(run)
	return _c
}

// ID provides a mock function with given fields:
func (_m *MockGraph) ID() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ID")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockGraph_ID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ID'
type MockGraph_ID_Call struct {
	*mock.Call
}

// ID is a helper method to define mock.On call
func (_e *MockGraph_Expecter) ID() *MockGraph_ID_Call {
	return &MockGraph_ID_Call{Call: _e.mock.On("ID")}
}

func (_c *MockGraph_ID_Call) Run(run func()) *MockGraph_ID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGraph_ID_Call) Return(_a0 string) *MockGraph_ID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGraph_ID_Call) RunAndReturn(run func() string) *MockGraph_ID_Call {
	_c.Call.Return(run)
	return _c
}

// IsDisjoint provides a mock function with given fields:
func (_m *MockGraph) IsDisjoint() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsDisjoint")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockGraph_IsDisjoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsDisjoint'
type MockGraph_IsDisjoint_Call struct {
	*mock.Call
}

// IsDisjoint is a helper method to define mock.On call
func (_e *MockGraph_Expecter) IsDisjoint() *MockGraph_IsDisjoint_Call {
	return &MockGraph_IsDisjoint_Call{Call: _e.mock.On("IsDisjoint")}
}

func (_c *MockGraph_IsDisjoint_Call) Run(run func()) *MockGraph_IsDisjoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGraph_IsDisjoint_Call) Return(_a0 bool) *MockGraph_IsDisjoint_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGraph_IsDisjoint_Call) RunAndReturn(run func() bool) *MockGraph_IsDisjoint_Call {
	_c.Call.Return(run)
	return _c
}

// IsSatellite provides a mock function with given fields:
func (_m *MockGraph) IsSatellite() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsSatellite")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockGraph_IsSatellite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsSatellite'
type MockGraph_IsSatellite_Call struct {
	*mock.Call
}

// IsSatellite is a helper method to define mock.On call
func (_e *MockGraph_Expecter) IsSatellite() *MockGraph_IsSatellite_Call {
	return &MockGraph_IsSatellite_Call{Call: _e.mock.On("IsSatellite")}
}

func (_c *MockGraph_IsSatellite_Call) Run(run func()) *MockGraph_IsSatellite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGraph_IsSatellite_Call) Return(_a0 bool) *MockGraph_IsSatellite_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGraph_IsSatellite_Call) RunAndReturn(run func() bool) *MockGraph_IsSatellite_Call {
	_c.Call.Return(run)
	return _c
}

// IsSmart provides a mock function with given fields:
func (_m *MockGraph) IsSmart() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsSmart")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MockGraph_IsSmart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsSmart'
type MockGraph_IsSmart_Call struct {
	*mock.Call
}

// IsSmart is a helper method to define mock.On call
func (_e *MockGraph_Expecter) IsSmart() *MockGraph_IsSmart_Call {
	return &MockGraph_IsSmart_Call{Call: _e.mock.On("IsSmart")}
}

func (_c *MockGraph_IsSmart_Call) Run(run func()) *MockGraph_IsSmart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGraph_IsSmart_Call) Return(_a0 bool) *MockGraph_IsSmart_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGraph_IsSmart_Call) RunAndReturn(run func() bool) *MockGraph_IsSmart_Call {
	_c.Call.Return(run)
	return _c
}

// Key provides a mock function with given fields:
func (_m *MockGraph) Key() driver.DocumentID {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Key")
	}

	var r0 driver.DocumentID
	if rf, ok := ret.Get(0).(func() driver.DocumentID); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(driver.DocumentID)
	}

	return r0
}

// MockGraph_Key_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Key'
type MockGraph_Key_Call struct {
	*mock.Call
}

// Key is a helper method to define mock.On call
func (_e *MockGraph_Expecter) Key() *MockGraph_Key_Call {
	return &MockGraph_Key_Call{Call: _e.mock.On("Key")}
}

func (_c *MockGraph_Key_Call) Run(run func()) *MockGraph_Key_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGraph_Key_Call) Return(_a0 driver.DocumentID) *MockGraph_Key_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGraph_Key_Call) RunAndReturn(run func() driver.DocumentID) *MockGraph_Key_Call {
	_c.Call.Return(run)
	return _c
}

// MinReplicationFactor provides a mock function with given fields:
func (_m *MockGraph) MinReplicationFactor() int {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for MinReplicationFactor")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// MockGraph_MinReplicationFactor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MinReplicationFactor'
type MockGraph_MinReplicationFactor_Call struct {
	*mock.Call
}

// MinReplicationFactor is a helper method to define mock.On call
func (_e *MockGraph_Expecter) MinReplicationFactor() *MockGraph_MinReplicationFactor_Call {
	return &MockGraph_MinReplicationFactor_Call{Call: _e.mock.On("MinReplicationFactor")}
}

func (_c *MockGraph_MinReplicationFactor_Call) Run(run func()) *MockGraph_MinReplicationFactor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGraph_MinReplicationFactor_Call) Return(_a0 int) *MockGraph_MinReplicationFactor_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGraph_MinReplicationFactor_Call) RunAndReturn(run func() int) *MockGraph_MinReplicationFactor_Call {
	_c.Call.Return(run)
	return _c
}

// Name provides a mock function with given fields:
func (_m *MockGraph) Name() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockGraph_Name_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Name'
type MockGraph_Name_Call struct {
	*mock.Call
}

// Name is a helper method to define mock.On call
func (_e *MockGraph_Expecter) Name() *MockGraph_Name_Call {
	return &MockGraph_Name_Call{Call: _e.mock.On("Name")}
}

func (_c *MockGraph_Name_Call) Run(run func()) *MockGraph_Name_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGraph_Name_Call) Return(_a0 string) *MockGraph_Name_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGraph_Name_Call) RunAndReturn(run func() string) *MockGraph_Name_Call {
	_c.Call.Return(run)
	return _c
}

// NumberOfShards provides a mock function with given fields:
func (_m *MockGraph) NumberOfShards() int {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for NumberOfShards")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// MockGraph_NumberOfShards_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NumberOfShards'
type MockGraph_NumberOfShards_Call struct {
	*mock.Call
}

// NumberOfShards is a helper method to define mock.On call
func (_e *MockGraph_Expecter) NumberOfShards() *MockGraph_NumberOfShards_Call {
	return &MockGraph_NumberOfShards_Call{Call: _e.mock.On("NumberOfShards")}
}

func (_c *MockGraph_NumberOfShards_Call) Run(run func()) *MockGraph_NumberOfShards_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGraph_NumberOfShards_Call) Return(_a0 int) *MockGraph_NumberOfShards_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGraph_NumberOfShards_Call) RunAndReturn(run func() int) *MockGraph_NumberOfShards_Call {
	_c.Call.Return(run)
	return _c
}

// OrphanCollections provides a mock function with given fields:
func (_m *MockGraph) OrphanCollections() []string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for OrphanCollections")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// MockGraph_OrphanCollections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrphanCollections'
type MockGraph_OrphanCollections_Call struct {
	*mock.Call
}

// OrphanCollections is a helper method to define mock.On call
func (_e *MockGraph_Expecter) OrphanCollections() *MockGraph_OrphanCollections_Call {
	return &MockGraph_OrphanCollections_Call{Call: _e.mock.On("OrphanCollections")}
}

func (_c *MockGraph_OrphanCollections_Call) Run(run func()) *MockGraph_OrphanCollections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGraph_OrphanCollections_Call) Return(_a0 []string) *MockGraph_OrphanCollections_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGraph_OrphanCollections_Call) RunAndReturn(run func() []string) *MockGraph_OrphanCollections_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function with given fields: ctx
func (_m *MockGraph) Remove(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGraph_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type MockGraph_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockGraph_Expecter) Remove(ctx interface{}) *MockGraph_Remove_Call {
	return &MockGraph_Remove_Call{Call: _e.mock.On("Remove", ctx)}
}

func (_c *MockGraph_Remove_Call) Run(run func(ctx context.Context)) *MockGraph_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockGraph_Remove_Call) Return(_a0 error) *MockGraph_Remove_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGraph_Remove_Call) RunAndReturn(run func(context.Context) error) *MockGraph_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// ReplicationFactor provides a mock function with given fields:
func (_m *MockGraph) ReplicationFactor() int {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ReplicationFactor")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// MockGraph_ReplicationFactor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReplicationFactor'
type MockGraph_ReplicationFactor_Call struct {
	*mock.Call
}

// ReplicationFactor is a helper method to define mock.On call
func (_e *MockGraph_Expecter) ReplicationFactor() *MockGraph_ReplicationFactor_Call {
	return &MockGraph_ReplicationFactor_Call{Call: _e.mock.On("ReplicationFactor")}
}

func (_c *MockGraph_ReplicationFactor_Call) Run(run func()) *MockGraph_ReplicationFactor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGraph_ReplicationFactor_Call) Return(_a0 int) *MockGraph_ReplicationFactor_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGraph_ReplicationFactor_Call) RunAndReturn(run func() int) *MockGraph_ReplicationFactor_Call {
	_c.Call.Return(run)
	return _c
}

// Rev provides a mock function with given fields:
func (_m *MockGraph) Rev() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Rev")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockGraph_Rev_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rev'
type MockGraph_Rev_Call struct {
	*mock.Call
}

// Rev is a helper method to define mock.On call
func (_e *MockGraph_Expecter) Rev() *MockGraph_Rev_Call {
	return &MockGraph_Rev_Call{Call: _e.mock.On("Rev")}
}

func (_c *MockGraph_Rev_Call) Run(run func()) *MockGraph_Rev_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGraph_Rev_Call) Return(_a0 string) *MockGraph_Rev_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGraph_Rev_Call) RunAndReturn(run func() string) *MockGraph_Rev_Call {
	_c.Call.Return(run)
	return _c
}

// SetVertexConstraints provides a mock function with given fields: ctx, collection, constraints
func (_m *MockGraph) SetVertexConstraints(ctx context.Context, collection string, constraints driver.VertexConstraints) error {
	ret := _m.Called(ctx, collection, constraints)

	if len(ret) == 0 {
		panic("no return value specified for SetVertexConstraints")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, driver.VertexConstraints) error); ok {
		r0 = rf(ctx, collection, constraints)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockGraph_SetVertexConstraints_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetVertexConstraints'
type MockGraph_SetVertexConstraints_Call struct {
	*mock.Call
}

// SetVertexConstraints is a helper method to define mock.On call
//   - ctx context.Context
//   - collection string
//   - constraints driver.VertexConstraints
func (_e *MockGraph_Expecter) SetVertexConstraints(ctx interface{}, collection interface{}, constraints interface{}) *MockGraph_SetVertexConstraints_Call {
	return &MockGraph_SetVertexConstraints_Call{Call: _e.mock.On("SetVertexConstraints", ctx, collection, constraints)}
}

func (_c *MockGraph_SetVertexConstraints_Call) Run(run func(ctx context.Context, collection string, constraints driver.VertexConstraints)) *MockGraph_SetVertexConstraints_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(driver.VertexConstraints))
	})
	return _c
}

func (_c *MockGraph_SetVertexConstraints_Call) Return(_a0 error) *MockGraph_SetVertexConstraints_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGraph_SetVertexConstraints_Call) RunAndReturn(run func(context.Context, string, driver.VertexConstraints) error) *MockGraph_SetVertexConstraints_Call {
	_c.Call.Return(run)
	return _c
}

// SmartGraphAttribute provides a mock function with given fields:
func (_m *MockGraph) SmartGraphAttribute() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for SmartGraphAttribute")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockGraph_SmartGraphAttribute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SmartGraphAttribute'
type MockGraph_SmartGraphAttribute_Call struct {
	*mock.Call
}

// SmartGraphAttribute is a helper method to define mock.On call
func (_e *MockGraph_Expecter) SmartGraphAttribute() *MockGraph_SmartGraphAttribute_Call {
	return &MockGraph_SmartGraphAttribute_Call{Call: _e.mock.On("SmartGraphAttribute")}
}

func (_c *MockGraph_SmartGraphAttribute_Call) Run(run func()) *MockGraph_SmartGraphAttribute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGraph_SmartGraphAttribute_Call) Return(_a0 string) *MockGraph_SmartGraphAttribute_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGraph_SmartGraphAttribute_Call) RunAndReturn(run func() string) *MockGraph_SmartGraphAttribute_Call {
	_c.Call.Return(run)
	return _c
}

// VertexCollection provides a mock function with given fields: ctx, name
func (_m *MockGraph) VertexCollection(ctx context.Context, name string) (driver.Collection, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for VertexCollection")
	}

	var r0 driver.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (driver.Collection, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) driver.Collection); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGraph_VertexCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VertexCollection'
type MockGraph_VertexCollection_Call struct {
	*mock.Call
}

// VertexCollection is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockGraph_Expecter) VertexCollection(ctx interface{}, name interface{}) *MockGraph_VertexCollection_Call {
	return &MockGraph_VertexCollection_Call{Call: _e.mock.On("VertexCollection", ctx, name)}
}

func (_c *MockGraph_VertexCollection_Call) Run(run func(ctx context.Context, name string)) *MockGraph_VertexCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGraph_VertexCollection_Call) Return(_a0 driver.Collection, _a1 error) *MockGraph_VertexCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGraph_VertexCollection_Call) RunAndReturn(run func(context.Context, string) (driver.Collection, error)) *MockGraph_VertexCollection_Call {
	_c.Call.Return(run)
	return _c
}

// VertexCollectionExists provides a mock function with given fields: ctx, name
func (_m *MockGraph) VertexCollectionExists(ctx context.Context, name string) (bool, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for VertexCollectionExists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGraph_VertexCollectionExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VertexCollectionExists'
type MockGraph_VertexCollectionExists_Call struct {
	*mock.Call
}

// VertexCollectionExists is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockGraph_Expecter) VertexCollectionExists(ctx interface{}, name interface{}) *MockGraph_VertexCollectionExists_Call {
	return &MockGraph_VertexCollectionExists_Call{Call: _e.mock.On("VertexCollectionExists", ctx, name)}
}

func (_c *MockGraph_VertexCollectionExists_Call) Run(run func(ctx context.Context, name string)) *MockGraph_VertexCollectionExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGraph_VertexCollectionExists_Call) Return(_a0 bool, _a1 error) *MockGraph_VertexCollectionExists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGraph_VertexCollectionExists_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *MockGraph_VertexCollectionExists_Call {
	_c.Call.Return(run)
	return _c
}

// VertexCollections provides a mock function with given fields: ctx
func (_m *MockGraph) VertexCollections(ctx context.Context) ([]driver.Collection, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for VertexCollections")
	}

	var r0 []driver.Collection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]driver.Collection, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []driver.Collection); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]driver.Collection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockGraph_VertexCollections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VertexCollections'
type MockGraph_VertexCollections_Call struct {
	*mock.Call
}

// VertexCollections is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockGraph_Expecter) VertexCollections(ctx interface{}) *MockGraph_VertexCollections_Call {
	return &MockGraph_VertexCollections_Call{Call: _e.mock.On("VertexCollections", ctx)}
}

func (_c *MockGraph_VertexCollections_Call) Run(run func(ctx context.Context)) *MockGraph_VertexCollections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockGraph_VertexCollections_Call) Return(_a0 []driver.Collection, _a1 error) *MockGraph_VertexCollections_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockGraph_VertexCollections_Call) RunAndReturn(run func(context.Context) ([]driver.Collection, error)) *MockGraph_VertexCollections_Call {
	_c.Call.Return(run)
	return _c
}

// WriteConcern provides a mock function with given fields:
func (_m *MockGraph) WriteConcern() int {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for WriteConcern")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// MockGraph_WriteConcern_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteConcern'
type MockGraph_WriteConcern_Call struct {
	*mock.Call
}

// WriteConcern is a helper method to define mock.On call
func (_e *MockGraph_Expecter) WriteConcern() *MockGraph_WriteConcern_Call {
	return &MockGraph_WriteConcern_Call{Call: _e.mock.On("WriteConcern")}
}

func (_c *MockGraph_WriteConcern_Call) Run(run func()) *MockGraph_WriteConcern_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockGraph_WriteConcern_Call) Return(_a0 int) *MockGraph_WriteConcern_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGraph_WriteConcern_Call) RunAndReturn(run func() int) *MockGraph_WriteConcern_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockGraph creates a new instance of MockGraph. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGraph(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGraph {
	mock := &MockGraph{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
