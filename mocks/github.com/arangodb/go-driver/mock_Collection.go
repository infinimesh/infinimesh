// Code generated by mockery v2.40.1. DO NOT EDIT.

package driver_mocks

import (
	context "context"

	driver "github.com/arangodb/go-driver"
	mock "github.com/stretchr/testify/mock"
)

// MockCollection is an autogenerated mock type for the Collection type
type MockCollection struct {
	mock.Mock
}

type MockCollection_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCollection) EXPECT() *MockCollection_Expecter {
	return &MockCollection_Expecter{mock: &_m.Mock}
}

// Checksum provides a mock function with given fields: ctx, withRevisions, withData
func (_m *MockCollection) Checksum(ctx context.Context, withRevisions bool, withData bool) (driver.CollectionChecksum, error) {
	ret := _m.Called(ctx, withRevisions, withData)

	if len(ret) == 0 {
		panic("no return value specified for Checksum")
	}

	var r0 driver.CollectionChecksum
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, bool, bool) (driver.CollectionChecksum, error)); ok {
		return rf(ctx, withRevisions, withData)
	}
	if rf, ok := ret.Get(0).(func(context.Context, bool, bool) driver.CollectionChecksum); ok {
		r0 = rf(ctx, withRevisions, withData)
	} else {
		r0 = ret.Get(0).(driver.CollectionChecksum)
	}

	if rf, ok := ret.Get(1).(func(context.Context, bool, bool) error); ok {
		r1 = rf(ctx, withRevisions, withData)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollection_Checksum_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Checksum'
type MockCollection_Checksum_Call struct {
	*mock.Call
}

// Checksum is a helper method to define mock.On call
//   - ctx context.Context
//   - withRevisions bool
//   - withData bool
func (_e *MockCollection_Expecter) Checksum(ctx interface{}, withRevisions interface{}, withData interface{}) *MockCollection_Checksum_Call {
	return &MockCollection_Checksum_Call{Call: _e.mock.On("Checksum", ctx, withRevisions, withData)}
}

func (_c *MockCollection_Checksum_Call) Run(run func(ctx context.Context, withRevisions bool, withData bool)) *MockCollection_Checksum_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(bool), args[2].(bool))
	})
	return _c
}

func (_c *MockCollection_Checksum_Call) Return(_a0 driver.CollectionChecksum, _a1 error) *MockCollection_Checksum_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollection_Checksum_Call) RunAndReturn(run func(context.Context, bool, bool) (driver.CollectionChecksum, error)) *MockCollection_Checksum_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function with given fields: ctx
func (_m *MockCollection) Count(ctx context.Context) (int64, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollection_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockCollection_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockCollection_Expecter) Count(ctx interface{}) *MockCollection_Count_Call {
	return &MockCollection_Count_Call{Call: _e.mock.On("Count", ctx)}
}

func (_c *MockCollection_Count_Call) Run(run func(ctx context.Context)) *MockCollection_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockCollection_Count_Call) Return(_a0 int64, _a1 error) *MockCollection_Count_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollection_Count_Call) RunAndReturn(run func(context.Context) (int64, error)) *MockCollection_Count_Call {
	_c.Call.Return(run)
	return _c
}

// CreateDocument provides a mock function with given fields: ctx, document
func (_m *MockCollection) CreateDocument(ctx context.Context, document interface{}) (driver.DocumentMeta, error) {
	ret := _m.Called(ctx, document)

	if len(ret) == 0 {
		panic("no return value specified for CreateDocument")
	}

	var r0 driver.DocumentMeta
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}) (driver.DocumentMeta, error)); ok {
		return rf(ctx, document)
	}
	if rf, ok := ret.Get(0).(func(context.Context, interface{}) driver.DocumentMeta); ok {
		r0 = rf(ctx, document)
	} else {
		r0 = ret.Get(0).(driver.DocumentMeta)
	}

	if rf, ok := ret.Get(1).(func(context.Context, interface{}) error); ok {
		r1 = rf(ctx, document)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollection_CreateDocument_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDocument'
type MockCollection_CreateDocument_Call struct {
	*mock.Call
}

// CreateDocument is a helper method to define mock.On call
//   - ctx context.Context
//   - document interface{}
func (_e *MockCollection_Expecter) CreateDocument(ctx interface{}, document interface{}) *MockCollection_CreateDocument_Call {
	return &MockCollection_CreateDocument_Call{Call: _e.mock.On("CreateDocument", ctx, document)}
}

func (_c *MockCollection_CreateDocument_Call) Run(run func(ctx context.Context, document interface{})) *MockCollection_CreateDocument_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(interface{}))
	})
	return _c
}

func (_c *MockCollection_CreateDocument_Call) Return(_a0 driver.DocumentMeta, _a1 error) *MockCollection_CreateDocument_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollection_CreateDocument_Call) RunAndReturn(run func(context.Context, interface{}) (driver.DocumentMeta, error)) *MockCollection_CreateDocument_Call {
	_c.Call.Return(run)
	return _c
}

// CreateDocuments provides a mock function with given fields: ctx, documents
func (_m *MockCollection) CreateDocuments(ctx context.Context, documents interface{}) (driver.DocumentMetaSlice, driver.ErrorSlice, error) {
	ret := _m.Called(ctx, documents)

	if len(ret) == 0 {
		panic("no return value specified for CreateDocuments")
	}

	var r0 driver.DocumentMetaSlice
	var r1 driver.ErrorSlice
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}) (driver.DocumentMetaSlice, driver.ErrorSlice, error)); ok {
		return rf(ctx, documents)
	}
	if rf, ok := ret.Get(0).(func(context.Context, interface{}) driver.DocumentMetaSlice); ok {
		r0 = rf(ctx, documents)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.DocumentMetaSlice)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, interface{}) driver.ErrorSlice); ok {
		r1 = rf(ctx, documents)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(driver.ErrorSlice)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, interface{}) error); ok {
		r2 = rf(ctx, documents)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCollection_CreateDocuments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDocuments'
type MockCollection_CreateDocuments_Call struct {
	*mock.Call
}

// CreateDocuments is a helper method to define mock.On call
//   - ctx context.Context
//   - documents interface{}
func (_e *MockCollection_Expecter) CreateDocuments(ctx interface{}, documents interface{}) *MockCollection_CreateDocuments_Call {
	return &MockCollection_CreateDocuments_Call{Call: _e.mock.On("CreateDocuments", ctx, documents)}
}

func (_c *MockCollection_CreateDocuments_Call) Run(run func(ctx context.Context, documents interface{})) *MockCollection_CreateDocuments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(interface{}))
	})
	return _c
}

func (_c *MockCollection_CreateDocuments_Call) Return(_a0 driver.DocumentMetaSlice, _a1 driver.ErrorSlice, _a2 error) *MockCollection_CreateDocuments_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockCollection_CreateDocuments_Call) RunAndReturn(run func(context.Context, interface{}) (driver.DocumentMetaSlice, driver.ErrorSlice, error)) *MockCollection_CreateDocuments_Call {
	_c.Call.Return(run)
	return _c
}

// Database provides a mock function with given fields:
func (_m *MockCollection) Database() driver.Database {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Database")
	}

	var r0 driver.Database
	if rf, ok := ret.Get(0).(func() driver.Database); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.Database)
		}
	}

	return r0
}

// MockCollection_Database_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Database'
type MockCollection_Database_Call struct {
	*mock.Call
}

// Database is a helper method to define mock.On call
func (_e *MockCollection_Expecter) Database() *MockCollection_Database_Call {
	return &MockCollection_Database_Call{Call: _e.mock.On("Database")}
}

func (_c *MockCollection_Database_Call) Run(run func()) *MockCollection_Database_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockCollection_Database_Call) Return(_a0 driver.Database) *MockCollection_Database_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCollection_Database_Call) RunAndReturn(run func() driver.Database) *MockCollection_Database_Call {
	_c.Call.Return(run)
	return _c
}

// DocumentExists provides a mock function with given fields: ctx, key
func (_m *MockCollection) DocumentExists(ctx context.Context, key string) (bool, error) {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for DocumentExists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollection_DocumentExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DocumentExists'
type MockCollection_DocumentExists_Call struct {
	*mock.Call
}

// DocumentExists is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockCollection_Expecter) DocumentExists(ctx interface{}, key interface{}) *MockCollection_DocumentExists_Call {
	return &MockCollection_DocumentExists_Call{Call: _e.mock.On("DocumentExists", ctx, key)}
}

func (_c *MockCollection_DocumentExists_Call) Run(run func(ctx context.Context, key string)) *MockCollection_DocumentExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockCollection_DocumentExists_Call) Return(_a0 bool, _a1 error) *MockCollection_DocumentExists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollection_DocumentExists_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *MockCollection_DocumentExists_Call {
	_c.Call.Return(run)
	return _c
}

// EnsureFullTextIndex provides a mock function with given fields: ctx, fields, options
func (_m *MockCollection) EnsureFullTextIndex(ctx context.Context, fields []string, options *driver.EnsureFullTextIndexOptions) (driver.Index, bool, error) {
	ret := _m.Called(ctx, fields, options)

	if len(ret) == 0 {
		panic("no return value specified for EnsureFullTextIndex")
	}

	var r0 driver.Index
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, *driver.EnsureFullTextIndexOptions) (driver.Index, bool, error)); ok {
		return rf(ctx, fields, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, *driver.EnsureFullTextIndexOptions) driver.Index); ok {
		r0 = rf(ctx, fields, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.Index)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, *driver.EnsureFullTextIndexOptions) bool); ok {
		r1 = rf(ctx, fields, options)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, []string, *driver.EnsureFullTextIndexOptions) error); ok {
		r2 = rf(ctx, fields, options)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCollection_EnsureFullTextIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnsureFullTextIndex'
type MockCollection_EnsureFullTextIndex_Call struct {
	*mock.Call
}

// EnsureFullTextIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - fields []string
//   - options *driver.EnsureFullTextIndexOptions
func (_e *MockCollection_Expecter) EnsureFullTextIndex(ctx interface{}, fields interface{}, options interface{}) *MockCollection_EnsureFullTextIndex_Call {
	return &MockCollection_EnsureFullTextIndex_Call{Call: _e.mock.On("EnsureFullTextIndex", ctx, fields, options)}
}

func (_c *MockCollection_EnsureFullTextIndex_Call) Run(run func(ctx context.Context, fields []string, options *driver.EnsureFullTextIndexOptions)) *MockCollection_EnsureFullTextIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string), args[2].(*driver.EnsureFullTextIndexOptions))
	})
	return _c
}

func (_c *MockCollection_EnsureFullTextIndex_Call) Return(_a0 driver.Index, _a1 bool, _a2 error) *MockCollection_EnsureFullTextIndex_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockCollection_EnsureFullTextIndex_Call) RunAndReturn(run func(context.Context, []string, *driver.EnsureFullTextIndexOptions) (driver.Index, bool, error)) *MockCollection_EnsureFullTextIndex_Call {
	_c.Call.Return(run)
	return _c
}

// EnsureGeoIndex provides a mock function with given fields: ctx, fields, options
func (_m *MockCollection) EnsureGeoIndex(ctx context.Context, fields []string, options *driver.EnsureGeoIndexOptions) (driver.Index, bool, error) {
	ret := _m.Called(ctx, fields, options)

	if len(ret) == 0 {
		panic("no return value specified for EnsureGeoIndex")
	}

	var r0 driver.Index
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, *driver.EnsureGeoIndexOptions) (driver.Index, bool, error)); ok {
		return rf(ctx, fields, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, *driver.EnsureGeoIndexOptions) driver.Index); ok {
		r0 = rf(ctx, fields, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.Index)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, *driver.EnsureGeoIndexOptions) bool); ok {
		r1 = rf(ctx, fields, options)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, []string, *driver.EnsureGeoIndexOptions) error); ok {
		r2 = rf(ctx, fields, options)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCollection_EnsureGeoIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnsureGeoIndex'
type MockCollection_EnsureGeoIndex_Call struct {
	*mock.Call
}

// EnsureGeoIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - fields []string
//   - options *driver.EnsureGeoIndexOptions
func (_e *MockCollection_Expecter) EnsureGeoIndex(ctx interface{}, fields interface{}, options interface{}) *MockCollection_EnsureGeoIndex_Call {
	return &MockCollection_EnsureGeoIndex_Call{Call: _e.mock.On("EnsureGeoIndex", ctx, fields, options)}
}

func (_c *MockCollection_EnsureGeoIndex_Call) Run(run func(ctx context.Context, fields []string, options *driver.EnsureGeoIndexOptions)) *MockCollection_EnsureGeoIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string), args[2].(*driver.EnsureGeoIndexOptions))
	})
	return _c
}

func (_c *MockCollection_EnsureGeoIndex_Call) Return(_a0 driver.Index, _a1 bool, _a2 error) *MockCollection_EnsureGeoIndex_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockCollection_EnsureGeoIndex_Call) RunAndReturn(run func(context.Context, []string, *driver.EnsureGeoIndexOptions) (driver.Index, bool, error)) *MockCollection_EnsureGeoIndex_Call {
	_c.Call.Return(run)
	return _c
}

// EnsureHashIndex provides a mock function with given fields: ctx, fields, options
func (_m *MockCollection) EnsureHashIndex(ctx context.Context, fields []string, options *driver.EnsureHashIndexOptions) (driver.Index, bool, error) {
	ret := _m.Called(ctx, fields, options)

	if len(ret) == 0 {
		panic("no return value specified for EnsureHashIndex")
	}

	var r0 driver.Index
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, *driver.EnsureHashIndexOptions) (driver.Index, bool, error)); ok {
		return rf(ctx, fields, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, *driver.EnsureHashIndexOptions) driver.Index); ok {
		r0 = rf(ctx, fields, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.Index)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, *driver.EnsureHashIndexOptions) bool); ok {
		r1 = rf(ctx, fields, options)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, []string, *driver.EnsureHashIndexOptions) error); ok {
		r2 = rf(ctx, fields, options)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCollection_EnsureHashIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnsureHashIndex'
type MockCollection_EnsureHashIndex_Call struct {
	*mock.Call
}

// EnsureHashIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - fields []string
//   - options *driver.EnsureHashIndexOptions
func (_e *MockCollection_Expecter) EnsureHashIndex(ctx interface{}, fields interface{}, options interface{}) *MockCollection_EnsureHashIndex_Call {
	return &MockCollection_EnsureHashIndex_Call{Call: _e.mock.On("EnsureHashIndex", ctx, fields, options)}
}

func (_c *MockCollection_EnsureHashIndex_Call) Run(run func(ctx context.Context, fields []string, options *driver.EnsureHashIndexOptions)) *MockCollection_EnsureHashIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string), args[2].(*driver.EnsureHashIndexOptions))
	})
	return _c
}

func (_c *MockCollection_EnsureHashIndex_Call) Return(_a0 driver.Index, _a1 bool, _a2 error) *MockCollection_EnsureHashIndex_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockCollection_EnsureHashIndex_Call) RunAndReturn(run func(context.Context, []string, *driver.EnsureHashIndexOptions) (driver.Index, bool, error)) *MockCollection_EnsureHashIndex_Call {
	_c.Call.Return(run)
	return _c
}

// EnsureInvertedIndex provides a mock function with given fields: ctx, options
func (_m *MockCollection) EnsureInvertedIndex(ctx context.Context, options *driver.InvertedIndexOptions) (driver.Index, bool, error) {
	ret := _m.Called(ctx, options)

	if len(ret) == 0 {
		panic("no return value specified for EnsureInvertedIndex")
	}

	var r0 driver.Index
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *driver.InvertedIndexOptions) (driver.Index, bool, error)); ok {
		return rf(ctx, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *driver.InvertedIndexOptions) driver.Index); ok {
		r0 = rf(ctx, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.Index)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *driver.InvertedIndexOptions) bool); ok {
		r1 = rf(ctx, options)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *driver.InvertedIndexOptions) error); ok {
		r2 = rf(ctx, options)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCollection_EnsureInvertedIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnsureInvertedIndex'
type MockCollection_EnsureInvertedIndex_Call struct {
	*mock.Call
}

// EnsureInvertedIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - options *driver.InvertedIndexOptions
func (_e *MockCollection_Expecter) EnsureInvertedIndex(ctx interface{}, options interface{}) *MockCollection_EnsureInvertedIndex_Call {
	return &MockCollection_EnsureInvertedIndex_Call{Call: _e.mock.On("EnsureInvertedIndex", ctx, options)}
}

func (_c *MockCollection_EnsureInvertedIndex_Call) Run(run func(ctx context.Context, options *driver.InvertedIndexOptions)) *MockCollection_EnsureInvertedIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*driver.InvertedIndexOptions))
	})
	return _c
}

func (_c *MockCollection_EnsureInvertedIndex_Call) Return(_a0 driver.Index, _a1 bool, _a2 error) *MockCollection_EnsureInvertedIndex_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockCollection_EnsureInvertedIndex_Call) RunAndReturn(run func(context.Context, *driver.InvertedIndexOptions) (driver.Index, bool, error)) *MockCollection_EnsureInvertedIndex_Call {
	_c.Call.Return(run)
	return _c
}

// EnsurePersistentIndex provides a mock function with given fields: ctx, fields, options
func (_m *MockCollection) EnsurePersistentIndex(ctx context.Context, fields []string, options *driver.EnsurePersistentIndexOptions) (driver.Index, bool, error) {
	ret := _m.Called(ctx, fields, options)

	if len(ret) == 0 {
		panic("no return value specified for EnsurePersistentIndex")
	}

	var r0 driver.Index
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, *driver.EnsurePersistentIndexOptions) (driver.Index, bool, error)); ok {
		return rf(ctx, fields, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, *driver.EnsurePersistentIndexOptions) driver.Index); ok {
		r0 = rf(ctx, fields, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.Index)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, *driver.EnsurePersistentIndexOptions) bool); ok {
		r1 = rf(ctx, fields, options)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, []string, *driver.EnsurePersistentIndexOptions) error); ok {
		r2 = rf(ctx, fields, options)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCollection_EnsurePersistentIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnsurePersistentIndex'
type MockCollection_EnsurePersistentIndex_Call struct {
	*mock.Call
}

// EnsurePersistentIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - fields []string
//   - options *driver.EnsurePersistentIndexOptions
func (_e *MockCollection_Expecter) EnsurePersistentIndex(ctx interface{}, fields interface{}, options interface{}) *MockCollection_EnsurePersistentIndex_Call {
	return &MockCollection_EnsurePersistentIndex_Call{Call: _e.mock.On("EnsurePersistentIndex", ctx, fields, options)}
}

func (_c *MockCollection_EnsurePersistentIndex_Call) Run(run func(ctx context.Context, fields []string, options *driver.EnsurePersistentIndexOptions)) *MockCollection_EnsurePersistentIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string), args[2].(*driver.EnsurePersistentIndexOptions))
	})
	return _c
}

func (_c *MockCollection_EnsurePersistentIndex_Call) Return(_a0 driver.Index, _a1 bool, _a2 error) *MockCollection_EnsurePersistentIndex_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockCollection_EnsurePersistentIndex_Call) RunAndReturn(run func(context.Context, []string, *driver.EnsurePersistentIndexOptions) (driver.Index, bool, error)) *MockCollection_EnsurePersistentIndex_Call {
	_c.Call.Return(run)
	return _c
}

// EnsureSkipListIndex provides a mock function with given fields: ctx, fields, options
func (_m *MockCollection) EnsureSkipListIndex(ctx context.Context, fields []string, options *driver.EnsureSkipListIndexOptions) (driver.Index, bool, error) {
	ret := _m.Called(ctx, fields, options)

	if len(ret) == 0 {
		panic("no return value specified for EnsureSkipListIndex")
	}

	var r0 driver.Index
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, *driver.EnsureSkipListIndexOptions) (driver.Index, bool, error)); ok {
		return rf(ctx, fields, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, *driver.EnsureSkipListIndexOptions) driver.Index); ok {
		r0 = rf(ctx, fields, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.Index)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, *driver.EnsureSkipListIndexOptions) bool); ok {
		r1 = rf(ctx, fields, options)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, []string, *driver.EnsureSkipListIndexOptions) error); ok {
		r2 = rf(ctx, fields, options)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCollection_EnsureSkipListIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnsureSkipListIndex'
type MockCollection_EnsureSkipListIndex_Call struct {
	*mock.Call
}

// EnsureSkipListIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - fields []string
//   - options *driver.EnsureSkipListIndexOptions
func (_e *MockCollection_Expecter) EnsureSkipListIndex(ctx interface{}, fields interface{}, options interface{}) *MockCollection_EnsureSkipListIndex_Call {
	return &MockCollection_EnsureSkipListIndex_Call{Call: _e.mock.On("EnsureSkipListIndex", ctx, fields, options)}
}

func (_c *MockCollection_EnsureSkipListIndex_Call) Run(run func(ctx context.Context, fields []string, options *driver.EnsureSkipListIndexOptions)) *MockCollection_EnsureSkipListIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string), args[2].(*driver.EnsureSkipListIndexOptions))
	})
	return _c
}

func (_c *MockCollection_EnsureSkipListIndex_Call) Return(_a0 driver.Index, _a1 bool, _a2 error) *MockCollection_EnsureSkipListIndex_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockCollection_EnsureSkipListIndex_Call) RunAndReturn(run func(context.Context, []string, *driver.EnsureSkipListIndexOptions) (driver.Index, bool, error)) *MockCollection_EnsureSkipListIndex_Call {
	_c.Call.Return(run)
	return _c
}

// EnsureTTLIndex provides a mock function with given fields: ctx, field, expireAfter, options
func (_m *MockCollection) EnsureTTLIndex(ctx context.Context, field string, expireAfter int, options *driver.EnsureTTLIndexOptions) (driver.Index, bool, error) {
	ret := _m.Called(ctx, field, expireAfter, options)

	if len(ret) == 0 {
		panic("no return value specified for EnsureTTLIndex")
	}

	var r0 driver.Index
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *driver.EnsureTTLIndexOptions) (driver.Index, bool, error)); ok {
		return rf(ctx, field, expireAfter, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, *driver.EnsureTTLIndexOptions) driver.Index); ok {
		r0 = rf(ctx, field, expireAfter, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.Index)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, *driver.EnsureTTLIndexOptions) bool); ok {
		r1 = rf(ctx, field, expireAfter, options)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, int, *driver.EnsureTTLIndexOptions) error); ok {
		r2 = rf(ctx, field, expireAfter, options)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCollection_EnsureTTLIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnsureTTLIndex'
type MockCollection_EnsureTTLIndex_Call struct {
	*mock.Call
}

// EnsureTTLIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - field string
//   - expireAfter int
//   - options *driver.EnsureTTLIndexOptions
func (_e *MockCollection_Expecter) EnsureTTLIndex(ctx interface{}, field interface{}, expireAfter interface{}, options interface{}) *MockCollection_EnsureTTLIndex_Call {
	return &MockCollection_EnsureTTLIndex_Call{Call: _e.mock.On("EnsureTTLIndex", ctx, field, expireAfter, options)}
}

func (_c *MockCollection_EnsureTTLIndex_Call) Run(run func(ctx context.Context, field string, expireAfter int, options *driver.EnsureTTLIndexOptions)) *MockCollection_EnsureTTLIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(*driver.EnsureTTLIndexOptions))
	})
	return _c
}

func (_c *MockCollection_EnsureTTLIndex_Call) Return(_a0 driver.Index, _a1 bool, _a2 error) *MockCollection_EnsureTTLIndex_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockCollection_EnsureTTLIndex_Call) RunAndReturn(run func(context.Context, string, int, *driver.EnsureTTLIndexOptions) (driver.Index, bool, error)) *MockCollection_EnsureTTLIndex_Call {
	_c.Call.Return(run)
	return _c
}

// EnsureZKDIndex provides a mock function with given fields: ctx, fields, options
func (_m *MockCollection) EnsureZKDIndex(ctx context.Context, fields []string, options *driver.EnsureZKDIndexOptions) (driver.Index, bool, error) {
	ret := _m.Called(ctx, fields, options)

	if len(ret) == 0 {
		panic("no return value specified for EnsureZKDIndex")
	}

	var r0 driver.Index
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, *driver.EnsureZKDIndexOptions) (driver.Index, bool, error)); ok {
		return rf(ctx, fields, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, *driver.EnsureZKDIndexOptions) driver.Index); ok {
		r0 = rf(ctx, fields, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.Index)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, *driver.EnsureZKDIndexOptions) bool); ok {
		r1 = rf(ctx, fields, options)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, []string, *driver.EnsureZKDIndexOptions) error); ok {
		r2 = rf(ctx, fields, options)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCollection_EnsureZKDIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnsureZKDIndex'
type MockCollection_EnsureZKDIndex_Call struct {
	*mock.Call
}

// EnsureZKDIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - fields []string
//   - options *driver.EnsureZKDIndexOptions
func (_e *MockCollection_Expecter) EnsureZKDIndex(ctx interface{}, fields interface{}, options interface{}) *MockCollection_EnsureZKDIndex_Call {
	return &MockCollection_EnsureZKDIndex_Call{Call: _e.mock.On("EnsureZKDIndex", ctx, fields, options)}
}

func (_c *MockCollection_EnsureZKDIndex_Call) Run(run func(ctx context.Context, fields []string, options *driver.EnsureZKDIndexOptions)) *MockCollection_EnsureZKDIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string), args[2].(*driver.EnsureZKDIndexOptions))
	})
	return _c
}

func (_c *MockCollection_EnsureZKDIndex_Call) Return(_a0 driver.Index, _a1 bool, _a2 error) *MockCollection_EnsureZKDIndex_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockCollection_EnsureZKDIndex_Call) RunAndReturn(run func(context.Context, []string, *driver.EnsureZKDIndexOptions) (driver.Index, bool, error)) *MockCollection_EnsureZKDIndex_Call {
	_c.Call.Return(run)
	return _c
}

// ImportDocuments provides a mock function with given fields: ctx, documents, options
func (_m *MockCollection) ImportDocuments(ctx context.Context, documents interface{}, options *driver.ImportDocumentOptions) (driver.ImportDocumentStatistics, error) {
	ret := _m.Called(ctx, documents, options)

	if len(ret) == 0 {
		panic("no return value specified for ImportDocuments")
	}

	var r0 driver.ImportDocumentStatistics
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, *driver.ImportDocumentOptions) (driver.ImportDocumentStatistics, error)); ok {
		return rf(ctx, documents, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, *driver.ImportDocumentOptions) driver.ImportDocumentStatistics); ok {
		r0 = rf(ctx, documents, options)
	} else {
		r0 = ret.Get(0).(driver.ImportDocumentStatistics)
	}

	if rf, ok := ret.Get(1).(func(context.Context, interface{}, *driver.ImportDocumentOptions) error); ok {
		r1 = rf(ctx, documents, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollection_ImportDocuments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportDocuments'
type MockCollection_ImportDocuments_Call struct {
	*mock.Call
}

// ImportDocuments is a helper method to define mock.On call
//   - ctx context.Context
//   - documents interface{}
//   - options *driver.ImportDocumentOptions
func (_e *MockCollection_Expecter) ImportDocuments(ctx interface{}, documents interface{}, options interface{}) *MockCollection_ImportDocuments_Call {
	return &MockCollection_ImportDocuments_Call{Call: _e.mock.On("ImportDocuments", ctx, documents, options)}
}

func (_c *MockCollection_ImportDocuments_Call) Run(run func(ctx context.Context, documents interface{}, options *driver.ImportDocumentOptions)) *MockCollection_ImportDocuments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(interface{}), args[2].(*driver.ImportDocumentOptions))
	})
	return _c
}

func (_c *MockCollection_ImportDocuments_Call) Return(_a0 driver.ImportDocumentStatistics, _a1 error) *MockCollection_ImportDocuments_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollection_ImportDocuments_Call) RunAndReturn(run func(context.Context, interface{}, *driver.ImportDocumentOptions) (driver.ImportDocumentStatistics, error)) *MockCollection_ImportDocuments_Call {
	_c.Call.Return(run)
	return _c
}

// Index provides a mock function with given fields: ctx, name
func (_m *MockCollection) Index(ctx context.Context, name string) (driver.Index, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for Index")
	}

	var r0 driver.Index
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (driver.Index, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) driver.Index); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.Index)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollection_Index_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Index'
type MockCollection_Index_Call struct {
	*mock.Call
}

// Index is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockCollection_Expecter) Index(ctx interface{}, name interface{}) *MockCollection_Index_Call {
	return &MockCollection_Index_Call{Call: _e.mock.On("Index", ctx, name)}
}

func (_c *MockCollection_Index_Call) Run(run func(ctx context.Context, name string)) *MockCollection_Index_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockCollection_Index_Call) Return(_a0 driver.Index, _a1 error) *MockCollection_Index_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollection_Index_Call) RunAndReturn(run func(context.Context, string) (driver.Index, error)) *MockCollection_Index_Call {
	_c.Call.Return(run)
	return _c
}

// IndexExists provides a mock function with given fields: ctx, name
func (_m *MockCollection) IndexExists(ctx context.Context, name string) (bool, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for IndexExists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollection_IndexExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IndexExists'
type MockCollection_IndexExists_Call struct {
	*mock.Call
}

// IndexExists is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockCollection_Expecter) IndexExists(ctx interface{}, name interface{}) *MockCollection_IndexExists_Call {
	return &MockCollection_IndexExists_Call{Call: _e.mock.On("IndexExists", ctx, name)}
}

func (_c *MockCollection_IndexExists_Call) Run(run func(ctx context.Context, name string)) *MockCollection_IndexExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockCollection_IndexExists_Call) Return(_a0 bool, _a1 error) *MockCollection_IndexExists_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollection_IndexExists_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *MockCollection_IndexExists_Call {
	_c.Call.Return(run)
	return _c
}

// Indexes provides a mock function with given fields: ctx
func (_m *MockCollection) Indexes(ctx context.Context) ([]driver.Index, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Indexes")
	}

	var r0 []driver.Index
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]driver.Index, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []driver.Index); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]driver.Index)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollection_Indexes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Indexes'
type MockCollection_Indexes_Call struct {
	*mock.Call
}

// Indexes is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockCollection_Expecter) Indexes(ctx interface{}) *MockCollection_Indexes_Call {
	return &MockCollection_Indexes_Call{Call: _e.mock.On("Indexes", ctx)}
}

func (_c *MockCollection_Indexes_Call) Run(run func(ctx context.Context)) *MockCollection_Indexes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockCollection_Indexes_Call) Return(_a0 []driver.Index, _a1 error) *MockCollection_Indexes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollection_Indexes_Call) RunAndReturn(run func(context.Context) ([]driver.Index, error)) *MockCollection_Indexes_Call {
	_c.Call.Return(run)
	return _c
}

// Load provides a mock function with given fields: ctx
func (_m *MockCollection) Load(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Load")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCollection_Load_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Load'
type MockCollection_Load_Call struct {
	*mock.Call
}

// Load is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockCollection_Expecter) Load(ctx interface{}) *MockCollection_Load_Call {
	return &MockCollection_Load_Call{Call: _e.mock.On("Load", ctx)}
}

func (_c *MockCollection_Load_Call) Run(run func(ctx context.Context)) *MockCollection_Load_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockCollection_Load_Call) Return(_a0 error) *MockCollection_Load_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCollection_Load_Call) RunAndReturn(run func(context.Context) error) *MockCollection_Load_Call {
	_c.Call.Return(run)
	return _c
}

// Name provides a mock function with given fields:
func (_m *MockCollection) Name() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockCollection_Name_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Name'
type MockCollection_Name_Call struct {
	*mock.Call
}

// Name is a helper method to define mock.On call
func (_e *MockCollection_Expecter) Name() *MockCollection_Name_Call {
	return &MockCollection_Name_Call{Call: _e.mock.On("Name")}
}

func (_c *MockCollection_Name_Call) Run(run func()) *MockCollection_Name_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockCollection_Name_Call) Return(_a0 string) *MockCollection_Name_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCollection_Name_Call) RunAndReturn(run func() string) *MockCollection_Name_Call {
	_c.Call.Return(run)
	return _c
}

// Properties provides a mock function with given fields: ctx
func (_m *MockCollection) Properties(ctx context.Context) (driver.CollectionProperties, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Properties")
	}

	var r0 driver.CollectionProperties
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (driver.CollectionProperties, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) driver.CollectionProperties); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(driver.CollectionProperties)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollection_Properties_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Properties'
type MockCollection_Properties_Call struct {
	*mock.Call
}

// Properties is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockCollection_Expecter) Properties(ctx interface{}) *MockCollection_Properties_Call {
	return &MockCollection_Properties_Call{Call: _e.mock.On("Properties", ctx)}
}

func (_c *MockCollection_Properties_Call) Run(run func(ctx context.Context)) *MockCollection_Properties_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockCollection_Properties_Call) Return(_a0 driver.CollectionProperties, _a1 error) *MockCollection_Properties_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollection_Properties_Call) RunAndReturn(run func(context.Context) (driver.CollectionProperties, error)) *MockCollection_Properties_Call {
	_c.Call.Return(run)
	return _c
}

// ReadDocument provides a mock function with given fields: ctx, key, result
func (_m *MockCollection) ReadDocument(ctx context.Context, key string, result interface{}) (driver.DocumentMeta, error) {
	ret := _m.Called(ctx, key, result)

	if len(ret) == 0 {
		panic("no return value specified for ReadDocument")
	}

	var r0 driver.DocumentMeta
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) (driver.DocumentMeta, error)); ok {
		return rf(ctx, key, result)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) driver.DocumentMeta); ok {
		r0 = rf(ctx, key, result)
	} else {
		r0 = ret.Get(0).(driver.DocumentMeta)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, interface{}) error); ok {
		r1 = rf(ctx, key, result)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollection_ReadDocument_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadDocument'
type MockCollection_ReadDocument_Call struct {
	*mock.Call
}

// ReadDocument is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - result interface{}
func (_e *MockCollection_Expecter) ReadDocument(ctx interface{}, key interface{}, result interface{}) *MockCollection_ReadDocument_Call {
	return &MockCollection_ReadDocument_Call{Call: _e.mock.On("ReadDocument", ctx, key, result)}
}

func (_c *MockCollection_ReadDocument_Call) Run(run func(ctx context.Context, key string, result interface{})) *MockCollection_ReadDocument_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockCollection_ReadDocument_Call) Return(_a0 driver.DocumentMeta, _a1 error) *MockCollection_ReadDocument_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollection_ReadDocument_Call) RunAndReturn(run func(context.Context, string, interface{}) (driver.DocumentMeta, error)) *MockCollection_ReadDocument_Call {
	_c.Call.Return(run)
	return _c
}

// ReadDocuments provides a mock function with given fields: ctx, keys, results
func (_m *MockCollection) ReadDocuments(ctx context.Context, keys []string, results interface{}) (driver.DocumentMetaSlice, driver.ErrorSlice, error) {
	ret := _m.Called(ctx, keys, results)

	if len(ret) == 0 {
		panic("no return value specified for ReadDocuments")
	}

	var r0 driver.DocumentMetaSlice
	var r1 driver.ErrorSlice
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, interface{}) (driver.DocumentMetaSlice, driver.ErrorSlice, error)); ok {
		return rf(ctx, keys, results)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, interface{}) driver.DocumentMetaSlice); ok {
		r0 = rf(ctx, keys, results)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.DocumentMetaSlice)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, interface{}) driver.ErrorSlice); ok {
		r1 = rf(ctx, keys, results)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(driver.ErrorSlice)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, []string, interface{}) error); ok {
		r2 = rf(ctx, keys, results)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCollection_ReadDocuments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadDocuments'
type MockCollection_ReadDocuments_Call struct {
	*mock.Call
}

// ReadDocuments is a helper method to define mock.On call
//   - ctx context.Context
//   - keys []string
//   - results interface{}
func (_e *MockCollection_Expecter) ReadDocuments(ctx interface{}, keys interface{}, results interface{}) *MockCollection_ReadDocuments_Call {
	return &MockCollection_ReadDocuments_Call{Call: _e.mock.On("ReadDocuments", ctx, keys, results)}
}

func (_c *MockCollection_ReadDocuments_Call) Run(run func(ctx context.Context, keys []string, results interface{})) *MockCollection_ReadDocuments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockCollection_ReadDocuments_Call) Return(_a0 driver.DocumentMetaSlice, _a1 driver.ErrorSlice, _a2 error) *MockCollection_ReadDocuments_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockCollection_ReadDocuments_Call) RunAndReturn(run func(context.Context, []string, interface{}) (driver.DocumentMetaSlice, driver.ErrorSlice, error)) *MockCollection_ReadDocuments_Call {
	_c.Call.Return(run)
	return _c
}

// Remove provides a mock function with given fields: ctx
func (_m *MockCollection) Remove(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Remove")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCollection_Remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Remove'
type MockCollection_Remove_Call struct {
	*mock.Call
}

// Remove is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockCollection_Expecter) Remove(ctx interface{}) *MockCollection_Remove_Call {
	return &MockCollection_Remove_Call{Call: _e.mock.On("Remove", ctx)}
}

func (_c *MockCollection_Remove_Call) Run(run func(ctx context.Context)) *MockCollection_Remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockCollection_Remove_Call) Return(_a0 error) *MockCollection_Remove_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCollection_Remove_Call) RunAndReturn(run func(context.Context) error) *MockCollection_Remove_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveDocument provides a mock function with given fields: ctx, key
func (_m *MockCollection) RemoveDocument(ctx context.Context, key string) (driver.DocumentMeta, error) {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for RemoveDocument")
	}

	var r0 driver.DocumentMeta
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (driver.DocumentMeta, error)); ok {
		return rf(ctx, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) driver.DocumentMeta); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(driver.DocumentMeta)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollection_RemoveDocument_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveDocument'
type MockCollection_RemoveDocument_Call struct {
	*mock.Call
}

// RemoveDocument is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockCollection_Expecter) RemoveDocument(ctx interface{}, key interface{}) *MockCollection_RemoveDocument_Call {
	return &MockCollection_RemoveDocument_Call{Call: _e.mock.On("RemoveDocument", ctx, key)}
}

func (_c *MockCollection_RemoveDocument_Call) Run(run func(ctx context.Context, key string)) *MockCollection_RemoveDocument_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockCollection_RemoveDocument_Call) Return(_a0 driver.DocumentMeta, _a1 error) *MockCollection_RemoveDocument_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollection_RemoveDocument_Call) RunAndReturn(run func(context.Context, string) (driver.DocumentMeta, error)) *MockCollection_RemoveDocument_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveDocuments provides a mock function with given fields: ctx, keys
func (_m *MockCollection) RemoveDocuments(ctx context.Context, keys []string) (driver.DocumentMetaSlice, driver.ErrorSlice, error) {
	ret := _m.Called(ctx, keys)

	if len(ret) == 0 {
		panic("no return value specified for RemoveDocuments")
	}

	var r0 driver.DocumentMetaSlice
	var r1 driver.ErrorSlice
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) (driver.DocumentMetaSlice, driver.ErrorSlice, error)); ok {
		return rf(ctx, keys)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) driver.DocumentMetaSlice); ok {
		r0 = rf(ctx, keys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.DocumentMetaSlice)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) driver.ErrorSlice); ok {
		r1 = rf(ctx, keys)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(driver.ErrorSlice)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, []string) error); ok {
		r2 = rf(ctx, keys)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCollection_RemoveDocuments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveDocuments'
type MockCollection_RemoveDocuments_Call struct {
	*mock.Call
}

// RemoveDocuments is a helper method to define mock.On call
//   - ctx context.Context
//   - keys []string
func (_e *MockCollection_Expecter) RemoveDocuments(ctx interface{}, keys interface{}) *MockCollection_RemoveDocuments_Call {
	return &MockCollection_RemoveDocuments_Call{Call: _e.mock.On("RemoveDocuments", ctx, keys)}
}

func (_c *MockCollection_RemoveDocuments_Call) Run(run func(ctx context.Context, keys []string)) *MockCollection_RemoveDocuments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockCollection_RemoveDocuments_Call) Return(_a0 driver.DocumentMetaSlice, _a1 driver.ErrorSlice, _a2 error) *MockCollection_RemoveDocuments_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockCollection_RemoveDocuments_Call) RunAndReturn(run func(context.Context, []string) (driver.DocumentMetaSlice, driver.ErrorSlice, error)) *MockCollection_RemoveDocuments_Call {
	_c.Call.Return(run)
	return _c
}

// Rename provides a mock function with given fields: ctx, newName
func (_m *MockCollection) Rename(ctx context.Context, newName string) error {
	ret := _m.Called(ctx, newName)

	if len(ret) == 0 {
		panic("no return value specified for Rename")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, newName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCollection_Rename_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rename'
type MockCollection_Rename_Call struct {
	*mock.Call
}

// Rename is a helper method to define mock.On call
//   - ctx context.Context
//   - newName string
func (_e *MockCollection_Expecter) Rename(ctx interface{}, newName interface{}) *MockCollection_Rename_Call {
	return &MockCollection_Rename_Call{Call: _e.mock.On("Rename", ctx, newName)}
}

func (_c *MockCollection_Rename_Call) Run(run func(ctx context.Context, newName string)) *MockCollection_Rename_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockCollection_Rename_Call) Return(_a0 error) *MockCollection_Rename_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCollection_Rename_Call) RunAndReturn(run func(context.Context, string) error) *MockCollection_Rename_Call {
	_c.Call.Return(run)
	return _c
}

// ReplaceDocument provides a mock function with given fields: ctx, key, document
func (_m *MockCollection) ReplaceDocument(ctx context.Context, key string, document interface{}) (driver.DocumentMeta, error) {
	ret := _m.Called(ctx, key, document)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceDocument")
	}

	var r0 driver.DocumentMeta
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) (driver.DocumentMeta, error)); ok {
		return rf(ctx, key, document)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) driver.DocumentMeta); ok {
		r0 = rf(ctx, key, document)
	} else {
		r0 = ret.Get(0).(driver.DocumentMeta)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, interface{}) error); ok {
		r1 = rf(ctx, key, document)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollection_ReplaceDocument_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReplaceDocument'
type MockCollection_ReplaceDocument_Call struct {
	*mock.Call
}

// ReplaceDocument is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - document interface{}
func (_e *MockCollection_Expecter) ReplaceDocument(ctx interface{}, key interface{}, document interface{}) *MockCollection_ReplaceDocument_Call {
	return &MockCollection_ReplaceDocument_Call{Call: _e.mock.On("ReplaceDocument", ctx, key, document)}
}

func (_c *MockCollection_ReplaceDocument_Call) Run(run func(ctx context.Context, key string, document interface{})) *MockCollection_ReplaceDocument_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockCollection_ReplaceDocument_Call) Return(_a0 driver.DocumentMeta, _a1 error) *MockCollection_ReplaceDocument_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollection_ReplaceDocument_Call) RunAndReturn(run func(context.Context, string, interface{}) (driver.DocumentMeta, error)) *MockCollection_ReplaceDocument_Call {
	_c.Call.Return(run)
	return _c
}

// ReplaceDocuments provides a mock function with given fields: ctx, keys, documents
func (_m *MockCollection) ReplaceDocuments(ctx context.Context, keys []string, documents interface{}) (driver.DocumentMetaSlice, driver.ErrorSlice, error) {
	ret := _m.Called(ctx, keys, documents)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceDocuments")
	}

	var r0 driver.DocumentMetaSlice
	var r1 driver.ErrorSlice
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, interface{}) (driver.DocumentMetaSlice, driver.ErrorSlice, error)); ok {
		return rf(ctx, keys, documents)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, interface{}) driver.DocumentMetaSlice); ok {
		r0 = rf(ctx, keys, documents)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.DocumentMetaSlice)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, interface{}) driver.ErrorSlice); ok {
		r1 = rf(ctx, keys, documents)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(driver.ErrorSlice)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, []string, interface{}) error); ok {
		r2 = rf(ctx, keys, documents)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCollection_ReplaceDocuments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReplaceDocuments'
type MockCollection_ReplaceDocuments_Call struct {
	*mock.Call
}

// ReplaceDocuments is a helper method to define mock.On call
//   - ctx context.Context
//   - keys []string
//   - documents interface{}
func (_e *MockCollection_Expecter) ReplaceDocuments(ctx interface{}, keys interface{}, documents interface{}) *MockCollection_ReplaceDocuments_Call {
	return &MockCollection_ReplaceDocuments_Call{Call: _e.mock.On("ReplaceDocuments", ctx, keys, documents)}
}

func (_c *MockCollection_ReplaceDocuments_Call) Run(run func(ctx context.Context, keys []string, documents interface{})) *MockCollection_ReplaceDocuments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockCollection_ReplaceDocuments_Call) Return(_a0 driver.DocumentMetaSlice, _a1 driver.ErrorSlice, _a2 error) *MockCollection_ReplaceDocuments_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockCollection_ReplaceDocuments_Call) RunAndReturn(run func(context.Context, []string, interface{}) (driver.DocumentMetaSlice, driver.ErrorSlice, error)) *MockCollection_ReplaceDocuments_Call {
	_c.Call.Return(run)
	return _c
}

// Revision provides a mock function with given fields: ctx
func (_m *MockCollection) Revision(ctx context.Context) (string, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Revision")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (string, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollection_Revision_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Revision'
type MockCollection_Revision_Call struct {
	*mock.Call
}

// Revision is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockCollection_Expecter) Revision(ctx interface{}) *MockCollection_Revision_Call {
	return &MockCollection_Revision_Call{Call: _e.mock.On("Revision", ctx)}
}

func (_c *MockCollection_Revision_Call) Run(run func(ctx context.Context)) *MockCollection_Revision_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockCollection_Revision_Call) Return(_a0 string, _a1 error) *MockCollection_Revision_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollection_Revision_Call) RunAndReturn(run func(context.Context) (string, error)) *MockCollection_Revision_Call {
	_c.Call.Return(run)
	return _c
}

// SetProperties provides a mock function with given fields: ctx, options
func (_m *MockCollection) SetProperties(ctx context.Context, options driver.SetCollectionPropertiesOptions) error {
	ret := _m.Called(ctx, options)

	if len(ret) == 0 {
		panic("no return value specified for SetProperties")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, driver.SetCollectionPropertiesOptions) error); ok {
		r0 = rf(ctx, options)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCollection_SetProperties_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetProperties'
type MockCollection_SetProperties_Call struct {
	*mock.Call
}

// SetProperties is a helper method to define mock.On call
//   - ctx context.Context
//   - options driver.SetCollectionPropertiesOptions
func (_e *MockCollection_Expecter) SetProperties(ctx interface{}, options interface{}) *MockCollection_SetProperties_Call {
	return &MockCollection_SetProperties_Call{Call: _e.mock.On("SetProperties", ctx, options)}
}

func (_c *MockCollection_SetProperties_Call) Run(run func(ctx context.Context, options driver.SetCollectionPropertiesOptions)) *MockCollection_SetProperties_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(driver.SetCollectionPropertiesOptions))
	})
	return _c
}

func (_c *MockCollection_SetProperties_Call) Return(_a0 error) *MockCollection_SetProperties_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCollection_SetProperties_Call) RunAndReturn(run func(context.Context, driver.SetCollectionPropertiesOptions) error) *MockCollection_SetProperties_Call {
	_c.Call.Return(run)
	return _c
}

// Shards provides a mock function with given fields: ctx, details
func (_m *MockCollection) Shards(ctx context.Context, details bool) (driver.CollectionShards, error) {
	ret := _m.Called(ctx, details)

	if len(ret) == 0 {
		panic("no return value specified for Shards")
	}

	var r0 driver.CollectionShards
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, bool) (driver.CollectionShards, error)); ok {
		return rf(ctx, details)
	}
	if rf, ok := ret.Get(0).(func(context.Context, bool) driver.CollectionShards); ok {
		r0 = rf(ctx, details)
	} else {
		r0 = ret.Get(0).(driver.CollectionShards)
	}

	if rf, ok := ret.Get(1).(func(context.Context, bool) error); ok {
		r1 = rf(ctx, details)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollection_Shards_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Shards'
type MockCollection_Shards_Call struct {
	*mock.Call
}

// Shards is a helper method to define mock.On call
//   - ctx context.Context
//   - details bool
func (_e *MockCollection_Expecter) Shards(ctx interface{}, details interface{}) *MockCollection_Shards_Call {
	return &MockCollection_Shards_Call{Call: _e.mock.On("Shards", ctx, details)}
}

func (_c *MockCollection_Shards_Call) Run(run func(ctx context.Context, details bool)) *MockCollection_Shards_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(bool))
	})
	return _c
}

func (_c *MockCollection_Shards_Call) Return(_a0 driver.CollectionShards, _a1 error) *MockCollection_Shards_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollection_Shards_Call) RunAndReturn(run func(context.Context, bool) (driver.CollectionShards, error)) *MockCollection_Shards_Call {
	_c.Call.Return(run)
	return _c
}

// Statistics provides a mock function with given fields: ctx
func (_m *MockCollection) Statistics(ctx context.Context) (driver.CollectionStatistics, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Statistics")
	}

	var r0 driver.CollectionStatistics
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (driver.CollectionStatistics, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) driver.CollectionStatistics); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(driver.CollectionStatistics)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollection_Statistics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Statistics'
type MockCollection_Statistics_Call struct {
	*mock.Call
}

// Statistics is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockCollection_Expecter) Statistics(ctx interface{}) *MockCollection_Statistics_Call {
	return &MockCollection_Statistics_Call{Call: _e.mock.On("Statistics", ctx)}
}

func (_c *MockCollection_Statistics_Call) Run(run func(ctx context.Context)) *MockCollection_Statistics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockCollection_Statistics_Call) Return(_a0 driver.CollectionStatistics, _a1 error) *MockCollection_Statistics_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollection_Statistics_Call) RunAndReturn(run func(context.Context) (driver.CollectionStatistics, error)) *MockCollection_Statistics_Call {
	_c.Call.Return(run)
	return _c
}

// Status provides a mock function with given fields: ctx
func (_m *MockCollection) Status(ctx context.Context) (driver.CollectionStatus, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Status")
	}

	var r0 driver.CollectionStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (driver.CollectionStatus, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) driver.CollectionStatus); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(driver.CollectionStatus)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollection_Status_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Status'
type MockCollection_Status_Call struct {
	*mock.Call
}

// Status is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockCollection_Expecter) Status(ctx interface{}) *MockCollection_Status_Call {
	return &MockCollection_Status_Call{Call: _e.mock.On("Status", ctx)}
}

func (_c *MockCollection_Status_Call) Run(run func(ctx context.Context)) *MockCollection_Status_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockCollection_Status_Call) Return(_a0 driver.CollectionStatus, _a1 error) *MockCollection_Status_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollection_Status_Call) RunAndReturn(run func(context.Context) (driver.CollectionStatus, error)) *MockCollection_Status_Call {
	_c.Call.Return(run)
	return _c
}

// Truncate provides a mock function with given fields: ctx
func (_m *MockCollection) Truncate(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Truncate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCollection_Truncate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Truncate'
type MockCollection_Truncate_Call struct {
	*mock.Call
}

// Truncate is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockCollection_Expecter) Truncate(ctx interface{}) *MockCollection_Truncate_Call {
	return &MockCollection_Truncate_Call{Call: _e.mock.On("Truncate", ctx)}
}

func (_c *MockCollection_Truncate_Call) Run(run func(ctx context.Context)) *MockCollection_Truncate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockCollection_Truncate_Call) Return(_a0 error) *MockCollection_Truncate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCollection_Truncate_Call) RunAndReturn(run func(context.Context) error) *MockCollection_Truncate_Call {
	_c.Call.Return(run)
	return _c
}

// Unload provides a mock function with given fields: ctx
func (_m *MockCollection) Unload(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Unload")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCollection_Unload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unload'
type MockCollection_Unload_Call struct {
	*mock.Call
}

// Unload is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockCollection_Expecter) Unload(ctx interface{}) *MockCollection_Unload_Call {
	return &MockCollection_Unload_Call{Call: _e.mock.On("Unload", ctx)}
}

func (_c *MockCollection_Unload_Call) Run(run func(ctx context.Context)) *MockCollection_Unload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockCollection_Unload_Call) Return(_a0 error) *MockCollection_Unload_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCollection_Unload_Call) RunAndReturn(run func(context.Context) error) *MockCollection_Unload_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateDocument provides a mock function with given fields: ctx, key, update
func (_m *MockCollection) UpdateDocument(ctx context.Context, key string, update interface{}) (driver.DocumentMeta, error) {
	ret := _m.Called(ctx, key, update)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDocument")
	}

	var r0 driver.DocumentMeta
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) (driver.DocumentMeta, error)); ok {
		return rf(ctx, key, update)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) driver.DocumentMeta); ok {
		r0 = rf(ctx, key, update)
	} else {
		r0 = ret.Get(0).(driver.DocumentMeta)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, interface{}) error); ok {
		r1 = rf(ctx, key, update)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCollection_UpdateDocument_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateDocument'
type MockCollection_UpdateDocument_Call struct {
	*mock.Call
}

// UpdateDocument is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - update interface{}
func (_e *MockCollection_Expecter) UpdateDocument(ctx interface{}, key interface{}, update interface{}) *MockCollection_UpdateDocument_Call {
	return &MockCollection_UpdateDocument_Call{Call: _e.mock.On("UpdateDocument", ctx, key, update)}
}

func (_c *MockCollection_UpdateDocument_Call) Run(run func(ctx context.Context, key string, update interface{})) *MockCollection_UpdateDocument_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockCollection_UpdateDocument_Call) Return(_a0 driver.DocumentMeta, _a1 error) *MockCollection_UpdateDocument_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCollection_UpdateDocument_Call) RunAndReturn(run func(context.Context, string, interface{}) (driver.DocumentMeta, error)) *MockCollection_UpdateDocument_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateDocuments provides a mock function with given fields: ctx, keys, updates
func (_m *MockCollection) UpdateDocuments(ctx context.Context, keys []string, updates interface{}) (driver.DocumentMetaSlice, driver.ErrorSlice, error) {
	ret := _m.Called(ctx, keys, updates)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDocuments")
	}

	var r0 driver.DocumentMetaSlice
	var r1 driver.ErrorSlice
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, interface{}) (driver.DocumentMetaSlice, driver.ErrorSlice, error)); ok {
		return rf(ctx, keys, updates)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, interface{}) driver.DocumentMetaSlice); ok {
		r0 = rf(ctx, keys, updates)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(driver.DocumentMetaSlice)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, interface{}) driver.ErrorSlice); ok {
		r1 = rf(ctx, keys, updates)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(driver.ErrorSlice)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, []string, interface{}) error); ok {
		r2 = rf(ctx, keys, updates)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCollection_UpdateDocuments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateDocuments'
type MockCollection_UpdateDocuments_Call struct {
	*mock.Call
}

// UpdateDocuments is a helper method to define mock.On call
//   - ctx context.Context
//   - keys []string
//   - updates interface{}
func (_e *MockCollection_Expecter) UpdateDocuments(ctx interface{}, keys interface{}, updates interface{}) *MockCollection_UpdateDocuments_Call {
	return &MockCollection_UpdateDocuments_Call{Call: _e.mock.On("UpdateDocuments", ctx, keys, updates)}
}

func (_c *MockCollection_UpdateDocuments_Call) Run(run func(ctx context.Context, keys []string, updates interface{})) *MockCollection_UpdateDocuments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockCollection_UpdateDocuments_Call) Return(_a0 driver.DocumentMetaSlice, _a1 driver.ErrorSlice, _a2 error) *MockCollection_UpdateDocuments_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockCollection_UpdateDocuments_Call) RunAndReturn(run func(context.Context, []string, interface{}) (driver.DocumentMetaSlice, driver.ErrorSlice, error)) *MockCollection_UpdateDocuments_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockCollection creates a new instance of MockCollection. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCollection(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCollection {
	mock := &MockCollection{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
